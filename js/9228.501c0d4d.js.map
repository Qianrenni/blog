{"version":3,"file":"js/9228.501c0d4d.js","mappings":"mHAAA,mkN","sources":["webpack://myblog/./src/assets/md/javascript/content/008-作用域与闭包.md"],"sourcesContent":["export default \"## **作用域与闭包**\\r\\n\\r\\n作用域和闭包是 JavaScript 中非常重要的概念，它们决定了变量的可见性和生命周期。理解这些概念可以帮助开发者写出更清晰、更高效的代码。\\r\\n\\r\\n---\\r\\n\\r\\n### **1. 全局作用域与局部作用域**\\r\\n\\r\\n#### **全局作用域**\\r\\n\\r\\n- **定义**：在函数外部声明的变量属于全局作用域。\\r\\n- **特点**：\\r\\n  - 在全局作用域中声明的变量可以在任何地方访问（包括函数内部）。\\r\\n  - 全局变量会一直存在，直到页面关闭或脚本结束。\\r\\n  - 过多的全局变量可能会导致命名冲突和内存泄漏。\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nconst globalVar = \\\"I am global\\\";\\r\\n\\r\\nfunction showGlobal() {\\r\\n    console.log(globalVar); // 可以访问全局变量\\r\\n}\\r\\n\\r\\nshowGlobal(); // 输出：I am global\\r\\nconsole.log(globalVar); // 输出：I am global\\r\\n```\\r\\n\\r\\n#### **局部作用域**\\r\\n\\r\\n- **定义**：在函数内部声明的变量属于局部作用域。\\r\\n- **特点**：\\r\\n  - 局部变量只能在声明它的函数内部访问。\\r\\n  - 函数执行完毕后，局部变量会被销毁（除非通过闭包保留）。\\r\\n  - 局部作用域可以避免变量污染全局作用域。\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nfunction showLocal() {\\r\\n    const localVar = \\\"I am local\\\";\\r\\n    console.log(localVar); // 可以访问局部变量\\r\\n}\\r\\n\\r\\nshowLocal(); // 输出：I am local\\r\\nconsole.log(localVar); // 报错：localVar is not defined\\r\\n```\\r\\n\\r\\n#### **注意事项**\\r\\n\\r\\n1. **避免全局变量滥用**：\\r\\n   - 尽量减少全局变量的使用，推荐使用模块化或 IIFE（立即调用函数表达式）来封装变量。\\r\\n\\r\\n     ```javascript\\r\\n     (function() {\\r\\n         const privateVar = \\\"I am private\\\";\\r\\n         console.log(privateVar);\\r\\n     })();\\r\\n     console.log(privateVar); // 报错：privateVar is not defined\\r\\n     ```\\r\\n\\r\\n2. **隐式全局变量**：\\r\\n   - 如果在函数内部未使用 `var`、`let` 或 `const` 声明变量，则会自动成为全局变量。\\r\\n\\r\\n     ```javascript\\r\\n     function createGlobal() {\\r\\n         implicitGlobal = \\\"I am implicit global\\\"; // 没有声明关键字\\r\\n     }\\r\\n\\r\\n     createGlobal();\\r\\n     console.log(implicitGlobal); // 输出：I am implicit global\\r\\n     ```\\r\\n\\r\\n---\\r\\n\\r\\n### **2. 块级作用域（`let` 和 `const`）**\\r\\n\\r\\n块级作用域是 ES6 引入的概念，由 `{}` 定义的作用域范围。`let` 和 `const` 是声明块级作用域变量的关键字。\\r\\n\\r\\n#### **`let`**\\r\\n\\r\\n- **定义**：使用 `let` 声明的变量具有块级作用域。\\r\\n- **特点**：\\r\\n  - 只能在声明它的块（如 `if`、`for`、`while` 等）内访问。\\r\\n  - 不允许重复声明同一变量。\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nif (true) {\\r\\n    let blockVar = \\\"I am block scoped\\\";\\r\\n    console.log(blockVar); // 输出：I am block scoped\\r\\n}\\r\\nconsole.log(blockVar); // 报错：blockVar is not defined\\r\\n```\\r\\n\\r\\n#### **`const`**\\r\\n\\r\\n- **定义**：使用 `const` 声明的常量也具有块级作用域。\\r\\n- **特点**：\\r\\n  - 常量必须在声明时初始化。\\r\\n  - 常量的值不能被重新赋值，但引用类型的值可以被修改。\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nconst PI = 3.14;\\r\\nPI = 3.14159; // 报错：Assignment to constant variable\\r\\n\\r\\nconst arr = [1, 2, 3];\\r\\narr.push(4); // 允许修改数组内容\\r\\nconsole.log(arr); // 输出：[1, 2, 3, 4]\\r\\n```\\r\\n\\r\\n#### **对比 `var`、`let` 和 `const`**\\r\\n\\r\\n| 特性                | `var`                          | `let`                           | `const`                      |\\r\\n|---------------------|--------------------------------|----------------------------------|------------------------------|\\r\\n| **作用域**           | 函数作用域                     | 块级作用域                       | 块级作用域                   |\\r\\n| **重复声明**         | 允许                          | 不允许                          | 不允许                      |\\r\\n| **提升**             | 提升到作用域顶部               | 存在暂时性死区（TDZ）            | 存在暂时性死区（TDZ）        |\\r\\n| **可变性**           | 可变                          | 可变                            | 不可重新赋值                 |\\r\\n\\r\\n---\\r\\n\\r\\n### **3. 闭包的概念及应用**\\r\\n\\r\\n#### **闭包的定义**\\r\\n\\r\\n- **定义**：闭包是指一个函数能够访问其外部作用域中的变量，即使外部函数已经执行完毕。\\r\\n- **关键点**：\\r\\n  - 外部函数返回内部函数。\\r\\n  - 内部函数持有对外部函数变量的引用。\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nfunction outerFunction() {\\r\\n    let count = 0; // 外部函数的局部变量\\r\\n    return function innerFunction() { // 返回内部函数\\r\\n        count++; // 访问并修改外部变量\\r\\n        return count;\\r\\n    };\\r\\n}\\r\\n\\r\\nconst counter = outerFunction(); // 调用外部函数，返回内部函数\\r\\nconsole.log(counter()); // 输出：1\\r\\nconsole.log(counter()); // 输出：2\\r\\n```\\r\\n\\r\\n#### **闭包的特点**\\r\\n\\r\\n1. **数据封装**：\\r\\n   - 闭包可以用来封装私有变量，避免全局污染。\\r\\n\\r\\n     ```javascript\\r\\n     function createCounter() {\\r\\n         let count = 0; // 私有变量\\r\\n         return {\\r\\n             increment: function() {\\r\\n                 count++;\\r\\n                 return count;\\r\\n             },\\r\\n             decrement: function() {\\r\\n                 count--;\\r\\n                 return count;\\r\\n             }\\r\\n         };\\r\\n     }\\r\\n\\r\\n     const counter = createCounter();\\r\\n     console.log(counter.increment()); // 输出：1\\r\\n     console.log(counter.increment()); // 输出：2\\r\\n     console.log(counter.decrement()); // 输出：1\\r\\n     ```\\r\\n\\r\\n2. **持久化状态**：\\r\\n   - 闭包中的变量在外部函数执行完毕后仍然存在。\\r\\n\\r\\n     ```javascript\\r\\n     function createMultiplier(factor) {\\r\\n         return function(value) {\\r\\n             return value * factor; // 保留对外部变量 factor 的引用\\r\\n         };\\r\\n     }\\r\\n\\r\\n     const double = createMultiplier(2);\\r\\n     console.log(double(5)); // 输出：10\\r\\n     ```\\r\\n\\r\\n3. **回调函数中的闭包**：\\r\\n   - 闭包常用于回调函数中，保存上下文信息。\\r\\n\\r\\n     ```javascript\\r\\n     function delayedGreeting(name) {\\r\\n         setTimeout(function() {\\r\\n             console.log(`Hello, ${name}!`);\\r\\n         }, 1000);\\r\\n     }\\r\\n\\r\\n     delayedGreeting(\\\"Alice\\\"); // 1秒后输出：Hello, Alice!\\r\\n     ```\\r\\n\\r\\n#### **闭包的应用场景**\\r\\n\\r\\n1. **模块化开发**：\\r\\n   - 使用闭包实现模块模式，封装私有变量和方法。\\r\\n\\r\\n     ```javascript\\r\\n     const Module = (function() {\\r\\n         let privateVar = \\\"I am private\\\";\\r\\n\\r\\n         function privateMethod() {\\r\\n             console.log(privateVar);\\r\\n         }\\r\\n\\r\\n         return {\\r\\n             publicMethod: function() {\\r\\n                 privateMethod();\\r\\n             }\\r\\n         };\\r\\n     })();\\r\\n\\r\\n     Module.publicMethod(); // 输出：I am private\\r\\n     console.log(Module.privateVar); // 报错：undefined\\r\\n     ```\\r\\n\\r\\n2. **函数工厂**：\\r\\n   - 使用闭包生成特定功能的函数。\\r\\n\\r\\n     ```javascript\\r\\n     function createAdder(base) {\\r\\n         return function(value) {\\r\\n             return base + value;\\r\\n         };\\r\\n     }\\r\\n\\r\\n     const addFive = createAdder(5);\\r\\n     console.log(addFive(10)); // 输出：15\\r\\n     ```\\r\\n\\r\\n3. **事件处理**：\\r\\n   - 使用闭包保存事件处理器的状态。\\r\\n\\r\\n     ```javascript\\r\\n     function setupButton() {\\r\\n         let clicks = 0;\\r\\n         document.getElementById(\\\"myButton\\\").addEventListener(\\\"click\\\", function() {\\r\\n             clicks++;\\r\\n             console.log(`Button clicked ${clicks} times.`);\\r\\n         });\\r\\n     }\\r\\n\\r\\n     setupButton();\\r\\n     ```\\r\\n\\r\\n4. **缓存机制**：\\r\\n   - 使用闭包实现简单的缓存功能。\\r\\n\\r\\n     ```javascript\\r\\n     function createCache() {\\r\\n         const cache = {};\\r\\n         return function(key, value) {\\r\\n             if (value !== undefined) {\\r\\n                 cache[key] = value; // 缓存值\\r\\n             }\\r\\n             return cache[key]; // 获取值\\r\\n         };\\r\\n     }\\r\\n\\r\\n     const cache = createCache();\\r\\n     cache(\\\"name\\\", \\\"Alice\\\");\\r\\n     console.log(cache(\\\"name\\\")); // 输出：Alice\\r\\n     ```\\r\\n\\r\\n---\";"],"names":[],"sourceRoot":""}