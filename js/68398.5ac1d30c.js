"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[68398],{68398:function(r,n,e){e.r(n),n["default"]='## **异步编程**\r\n\r\nJavaScript 是一种单线程语言，但通过异步编程机制，可以实现高效的并发操作。异步编程是现代 JavaScript 的核心概念之一，特别适用于处理耗时任务（如网络请求、文件读写等）。以下是关于异步编程的详细讲解。\r\n\r\n### **1. 同步与异步的区别**\r\n\r\n#### **同步**\r\n\r\n- **定义**：代码按照顺序执行，每行代码必须等待前一行代码执行完成后才能运行。\r\n- **特点**：\r\n  - 简单直观，易于理解和调试。\r\n  - 如果某段代码耗时较长（如网络请求），会导致程序阻塞，影响用户体验。\r\n- **示例**：\r\n\r\n  ```javascript\r\n  console.log("Start");\r\n  for (let i = 0; i < 1e9; i++) {} // 模拟耗时任务\r\n  console.log("End");\r\n  ```\r\n\r\n  输出顺序：\r\n\r\n  ```\r\n  Start\r\n  End\r\n  ```\r\n\r\n#### **异步**\r\n\r\n- **定义**：某些代码在后台执行，不会阻塞主线程。当任务完成时，通过回调函数或 Promise 处理结果。\r\n- **特点**：\r\n  - 提高程序性能和响应速度。\r\n  - 需要额外的机制（如回调函数、Promise 或 `async/await`）来处理异步逻辑。\r\n- **示例**：\r\n\r\n  ```javascript\r\n  console.log("Start");\r\n  setTimeout(() => {\r\n      console.log("Timeout completed");\r\n  }, 1000);\r\n  console.log("End");\r\n  ```\r\n\r\n  输出顺序：\r\n\r\n  ```\r\n  Start\r\n  End\r\n  Timeout completed\r\n  ```\r\n\r\n---\r\n\r\n### **2. 回调函数及其问题（回调地狱）**\r\n\r\n#### **回调函数**\r\n\r\n- **定义**：将一个函数作为参数传递给另一个函数，并在异步操作完成后调用该函数。\r\n- **示例**：\r\n\r\n  ```javascript\r\n  function fetchData(callback) {\r\n      setTimeout(() => {\r\n          callback("Data received");\r\n      }, 1000);\r\n  }\r\n\r\n  fetchData((data) => {\r\n      console.log(data); // 输出：Data received\r\n  });\r\n  ```\r\n\r\n#### **回调地狱**\r\n\r\n- **问题**：当多个异步操作嵌套时，代码会变得难以阅读和维护。\r\n- **示例**：\r\n\r\n  ```javascript\r\n  fetchData1((data1) => {\r\n      console.log(data1);\r\n      fetchData2((data2) => {\r\n          console.log(data2);\r\n          fetchData3((data3) => {\r\n              console.log(data3);\r\n          });\r\n      });\r\n  });\r\n  ```\r\n\r\n  上述代码中，嵌套层级较深，导致“回调地狱”问题。\r\n\r\n---\r\n\r\n### **3. `Promise`**\r\n\r\n`Promise` 是 ES6 引入的一种更优雅的异步编程解决方案，用于替代回调函数。\r\n\r\n#### **3.1 创建 Promise**\r\n\r\n- **语法**：\r\n\r\n  ```javascript\r\n  const promise = new Promise((resolve, reject) => {\r\n      // 异步操作\r\n      if (成功) {\r\n          resolve(结果);\r\n      } else {\r\n          reject(错误信息);\r\n      }\r\n  });\r\n  ```\r\n\r\n- **示例**：\r\n\r\n  ```javascript\r\n  const fetchData = () => {\r\n      return new Promise((resolve, reject) => {\r\n          setTimeout(() => {\r\n              const success = true;\r\n              if (success) {\r\n                  resolve("Data received");\r\n              } else {\r\n                  reject("Error occurred");\r\n              }\r\n          }, 1000);\r\n      });\r\n  };\r\n\r\n  fetchData()\r\n      .then((data) => console.log(data)) // 输出：Data received\r\n      .catch((error) => console.error(error));\r\n  ```\r\n\r\n#### **3.2 方法**\r\n\r\n- **`then`**：\r\n  - 处理 `resolve` 的结果。\r\n  - 支持链式调用。\r\n- **`catch`**：\r\n  - 捕获 `reject` 的错误。\r\n- **`finally`**：\r\n  - 无论成功还是失败都会执行。\r\n\r\n**示例**：\r\n\r\n```javascript\r\nfetchData()\r\n    .then((data) => {\r\n        console.log(data); // 输出：Data received\r\n        return data.toUpperCase();\r\n    })\r\n    .then((upperData) => {\r\n        console.log(upperData); // 输出：DATA RECEIVED\r\n    })\r\n    .catch((error) => {\r\n        console.error(error); // 如果发生错误，输出错误信息\r\n    })\r\n    .finally(() => {\r\n        console.log("Operation completed."); // 总是执行\r\n    });\r\n```\r\n\r\n#### **3.3 链式调用**\r\n\r\n- **特点**：每个 `then` 方法返回一个新的 Promise，支持连续处理异步结果。\r\n- **示例**：\r\n\r\n  ```javascript\r\n  const fetchUser = () => Promise.resolve({ name: "Alice" });\r\n  const fetchPosts = (user) => Promise.resolve([{ title: "Post 1" }, { title: "Post 2" }]);\r\n\r\n  fetchUser()\r\n      .then((user) => {\r\n          console.log("User:", user.name); // 输出：User: Alice\r\n          return fetchPosts(user);\r\n      })\r\n      .then((posts) => {\r\n          console.log("Posts:", posts); // 输出：Posts: [{ title: "Post 1" }, { title: "Post 2" }]\r\n      })\r\n      .catch((error) => {\r\n          console.error(error);\r\n      });\r\n  ```\r\n\r\n---\r\n\r\n### **4. `async/await`**\r\n\r\n`async/await` 是基于 Promise 的语法糖，使异步代码看起来像同步代码，更加简洁易读。\r\n\r\n#### **4.1 基本用法**\r\n\r\n- **`async`**：\r\n  - 定义一个异步函数，其返回值始终是一个 Promise。\r\n- **`await`**：\r\n  - 暂停异步函数的执行，直到 Promise 被解决（`resolve` 或 `reject`）。\r\n\r\n**示例**：\r\n\r\n```javascript\r\nconst fetchData = () => {\r\n    return new Promise((resolve) => {\r\n        setTimeout(() => resolve("Data received"), 1000);\r\n    });\r\n};\r\n\r\nconst main = async () => {\r\n    const data = await fetchData();\r\n    console.log(data); // 输出：Data received\r\n};\r\n\r\nmain();\r\n```\r\n\r\n#### **4.2 错误处理：`try...catch`**\r\n\r\n- 使用 `try...catch` 捕获异步操作中的错误。\r\n\r\n**示例**：\r\n\r\n```javascript\r\nconst fetchData = () => {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(() => reject("Error occurred"), 1000);\r\n    });\r\n};\r\n\r\nconst main = async () => {\r\n    try {\r\n        const data = await fetchData();\r\n        console.log(data);\r\n    } catch (error) {\r\n        console.error(error); // 输出：Error occurred\r\n    }\r\n};\r\n\r\nmain();\r\n```\r\n\r\n---\r\n\r\n### **5. 宏任务与微任务（Event Loop）**\r\n\r\nJavaScript 的事件循环机制决定了异步任务的执行顺序。\r\n\r\n#### **宏任务（Macrotask）**\r\n\r\n- 包括：`setTimeout`、`setInterval`、I/O 操作、UI 渲染等。\r\n- **特点**：每次事件循环只执行一个宏任务。\r\n\r\n#### **微任务（Microtask）**\r\n\r\n- 包括：`Promise.then/catch/finally`、`MutationObserver` 等。\r\n- **特点**：在当前宏任务结束后立即执行所有微任务。\r\n\r\n#### **执行顺序**\r\n\r\n1. 执行同步代码。\r\n2. 执行当前宏任务队列中的任务。\r\n3. 执行所有微任务队列中的任务。\r\n4. 渲染 UI。\r\n5. 返回步骤 2，继续下一个宏任务。\r\n\r\n**示例**：\r\n\r\n```javascript\r\nconsole.log("Script start");\r\n\r\nsetTimeout(() => {\r\n    console.log("Timeout 1");\r\n}, 0);\r\n\r\nPromise.resolve().then(() => {\r\n    console.log("Promise 1");\r\n});\r\n\r\nsetTimeout(() => {\r\n    console.log("Timeout 2");\r\n}, 0);\r\n\r\nPromise.resolve().then(() => {\r\n    console.log("Promise 2");\r\n});\r\n\r\nconsole.log("Script end");\r\n```\r\n\r\n输出顺序：\r\n\r\n```\r\nScript start\r\nScript end\r\nPromise 1\r\nPromise 2\r\nTimeout 1\r\nTimeout 2\r\n```\r\n\r\n---'}}]);
//# sourceMappingURL=68398.5ac1d30c.js.map