"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[9765],{9765:function(n,r,e){e.r(r),r["default"]='## **4. 线程间通信**\r\n\r\n### **4.1 `wait()`, `notify()`, `notifyAll()`**\r\n\r\n这些方法用于线程间的协作，必须在同步块中使用。\r\n\r\n```java\r\nsynchronized (obj) {\r\n    while (conditionNotMet) {\r\n        obj.wait(); // 当前线程等待\r\n    }\r\n    // 执行逻辑\r\n    obj.notify(); // 唤醒一个等待线程\r\n    obj.notifyAll(); // 唤醒所有等待线程\r\n}\r\n```\r\n\r\n---\r\n\r\n### **4.2 生产者-消费者模式**\r\n\r\n生产者-消费者模式是一种经典的线程间通信模型。\r\n\r\n```java\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\n\r\npublic class ProducerConsumer {\r\n    private final Queue<Integer> queue = new LinkedList<>();\r\n    private final int CAPACITY = 5;\r\n    private final Object lock = new Object();\r\n\r\n    public void produce() throws InterruptedException {\r\n        int value = 0;\r\n        while (true) {\r\n            synchronized (lock) {\r\n                while (queue.size() == CAPACITY) {\r\n                    lock.wait();\r\n                }\r\n                queue.add(value++);\r\n                lock.notify();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void consume() throws InterruptedException {\r\n        while (true) {\r\n            synchronized (lock) {\r\n                while (queue.isEmpty()) {\r\n                    lock.wait();\r\n                }\r\n                int value = queue.poll();\r\n                System.out.println("Consumed: " + value);\r\n                lock.notify();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---'}}]);
//# sourceMappingURL=9765.ebfea237.js.map