{"version":3,"file":"js/50129.bf4cd826.js","mappings":"qHAAA,4oG","sources":["webpack://myblog/./src/assets/md/algorithm/content/014-6 滑动窗口.md"],"sourcesContent":["export default \"## **6. 滑动窗口**\\r\\n\\r\\n滑动窗口（Sliding Window）是一种常用的算法技巧，主要用于处理数组、字符串或序列中的子数组、子字符串等问题。它的核心思想是通过维护一个窗口（通常是一个区间或子集），在遍历过程中动态调整窗口的起始和结束位置，从而避免重复计算，提高算法效率。\\r\\n\\r\\n### **两数之和**\\r\\n\\r\\n> **问题描述**:\\r\\n给定一个有序数组 nums 和一个目标值 target，请在数组中找到两个数，使它们的和等于目标值，并返回这两个数的索引。假设每个输入有且仅有一个解，且同一个元素不能使用两次。\\r\\n\\r\\n```python\\r\\ndef two_sum_sorted(nums, target):\\r\\n    # 初始化左右指针\\r\\n    left, right = 0, len(nums) - 1\\r\\n\\r\\n    while left < right:\\r\\n        current_sum = nums[left] + nums[right]\\r\\n\\r\\n        if current_sum == target:\\r\\n            return [left, right]  # 返回索引\\r\\n        elif current_sum < target:\\r\\n            left += 1  # 和太小，移动左指针\\r\\n        else:\\r\\n            right -= 1  # 和太大，移动右指针\\r\\n\\r\\n    return [-1, -1]  # 如果未找到，返回 [-1, -1]\\r\\n```\\r\\n\\r\\n### **三数之和**\\r\\n\\r\\n> **问题描述**:\\r\\n给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a ，b ，c ，使得 a + b + c = 0 ？请找出所有和为 0 且 不重复 的三元组。\\r\\n\\r\\n```python\\r\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\r\\n        # 对数组进行排序\\r\\n        nums.sort()\\r\\n        result = []\\r\\n        n = len(nums)\\r\\n\\r\\n        for i in range(n):\\r\\n            # 跳过重复的固定数\\r\\n            if i > 0 and nums[i] == nums[i - 1]:\\r\\n                continue\\r\\n\\r\\n            # 固定 nums[i]，寻找两数之和等于 -nums[i]\\r\\n            target = -nums[i]\\r\\n            left, right = i + 1, n - 1\\r\\n\\r\\n            while left < right:\\r\\n                current_sum = nums[left] + nums[right]\\r\\n\\r\\n                if current_sum == target:\\r\\n                    # 找到一组满足条件的三元组\\r\\n                    result.append([nums[i], nums[left], nums[right]])\\r\\n\\r\\n                    # 移动指针并跳过重复的数字\\r\\n                    left += 1\\r\\n                    right -= 1\\r\\n                    while left < right and nums[left] == nums[left - 1]:\\r\\n                        left += 1\\r\\n                    while left < right and nums[right] == nums[right + 1]:\\r\\n                        right -= 1\\r\\n\\r\\n                elif current_sum < target:\\r\\n                    left += 1  # 和太小，移动左指针\\r\\n                else:\\r\\n                    right -= 1  # 和太大，移动右指针\\r\\n\\r\\n        return result\\r\\n```\\r\\n\\r\\n### **统计好子数组的数目**\\r\\n>\\r\\n> **问题描述**:\\r\\n给你一个整数数组 nums 和一个整数 k ，请你返回 nums 中 好 子数组的数目。\\r\\n一个子数组 arr 如果有 至少 k 对下标 (i, j) 满足 i < j 且 arr[i] == arr[j] ，那么称它是一个 好 子数组。\\r\\n子数组 是原数组中一段连续 非空 的元素序列。\\r\\n\\r\\n```python\\r\\n\\r\\nclass Solution:\\r\\n    def countGood(self, nums: List[int], k: int) -> int:\\r\\n        left = 0\\r\\n        pairs = 0\\r\\n        freq = defaultdict(int)\\r\\n        res = 0\\r\\n        \\r\\n        for right in range(len(nums)):\\r\\n            # 更新当前数字的频率，并增加新产生的数对数量\\r\\n            freq[nums[right]] += 1\\r\\n            pairs += freq[nums[right]] - 1\\r\\n            \\r\\n            # 当满足条件时，收缩左边界并累加结果\\r\\n            while pairs >= k:\\r\\n                res += len(nums) - right  # 当前窗口的所有子数组都满足条件\\r\\n                freq[nums[left]] -= 1\\r\\n                pairs -= freq[nums[left]]  # 减去移除元素导致的数对减少\\r\\n                left += 1\\r\\n        \\r\\n        return res\\r\\n```\\r\\n\\r\\n**总结**\\r\\n\\r\\n滑动窗口的主要适用范围包括：\\r\\n\\r\\n1. **连续性**：问题涉及连续子数组或子字符串。\\r\\n2. **窗口特性**：窗口大小可以是固定的或动态变化的。\\r\\n3. **优化需求**：需要优化时间复杂度，避免暴力枚举。\\r\\n4. **频率或统计**：需要统计窗口内元素的频率或其他属性。\\r\\n5. **流式数据处理**：需要处理实时数据或数据流。\";"],"names":[],"sourceRoot":""}