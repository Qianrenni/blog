"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[810],{10810:function(n,r,e){e.r(r),r["default"]='## **1. 线程基础**\r\n\r\n### **1.1 线程的概念与生命周期**\r\n\r\n- **线程的概念**：  \r\n  线程是操作系统能够独立调度的基本单位，是进程中的一个执行路径。一个进程可以包含多个线程，所有线程共享进程的内存空间（如堆、方法区等），但每个线程有自己的栈。\r\n  \r\n- **线程的生命周期**：  \r\n  Java线程有以下几种状态：\r\n  1. **新建 (New)**：线程对象被创建，但尚未启动。\r\n  2. **就绪 (Runnable)**：线程已启动，等待CPU调度执行。\r\n  3. **运行 (Running)**：线程正在CPU上执行。\r\n  4. **阻塞 (Blocked)**：线程因等待资源（如I/O操作、锁）而暂停。\r\n  5. **等待 (Waiting)**：线程进入无限期等待，直到其他线程显式唤醒（如调用`wait()`）。\r\n  6. **超时等待 (Timed Waiting)**：线程进入有限期等待（如调用`sleep()`或带超时参数的`wait()`）。\r\n  7. **终止 (Terminated)**：线程执行完毕或因异常退出。\r\n\r\n---\r\n\r\n### **1.2 创建线程的方式**\r\n\r\nJava中有多种方式创建线程：\r\n\r\n#### **1.2.1 继承 `Thread` 类**\r\n\r\n```java\r\nclass MyThread extends Thread {\r\n    @Override\r\n    public void run() {\r\n        System.out.println("Thread is running");\r\n    }\r\n}\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        MyThread thread = new MyThread();\r\n        thread.start(); // 启动线程\r\n    }\r\n}\r\n```\r\n\r\n- **优点**：简单直观。\r\n- **缺点**：由于Java不支持多继承，如果类已经继承了其他类，则无法使用该方式。\r\n\r\n---\r\n\r\n#### **1.2.2 实现 `Runnable` 接口**\r\n\r\n```java\r\nclass MyRunnable implements Runnable {\r\n    @Override\r\n    public void run() {\r\n        System.out.println("Runnable is running");\r\n    }\r\n}\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        Thread thread = new Thread(new MyRunnable());\r\n        thread.start();\r\n    }\r\n}\r\n```\r\n\r\n- **优点**：避免单继承限制，更灵活。\r\n- **缺点**：需要额外创建`Thread`对象。\r\n\r\n---\r\n\r\n#### **1.2.3 使用线程池**\r\n\r\n线程池是一种管理线程的高级方式，通过复用线程减少频繁创建和销毁线程的开销。\r\n\r\n```java\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.Executors;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        ExecutorService executor = Executors.newFixedThreadPool(2); // 创建固定大小的线程池\r\n        for (int i = 0; i < 5; i++) {\r\n            executor.submit(() -> System.out.println("Task executed by " + Thread.currentThread().getName()));\r\n        }\r\n        executor.shutdown(); // 关闭线程池\r\n    }\r\n}\r\n```\r\n\r\n- **优点**：高效、可控性强。\r\n- **常见实现**：\r\n  - `Executors.newFixedThreadPool(int nThreads)`：创建固定大小的线程池。\r\n  - `Executors.newCachedThreadPool()`：根据需要动态调整线程数量。\r\n  - `Executors.newSingleThreadExecutor()`：单线程的线程池。\r\n\r\n---'}}]);
//# sourceMappingURL=810.e412da91.js.map