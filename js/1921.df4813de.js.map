{"version":3,"file":"js/1921.df4813de.js","mappings":"oHAAA,w3F","sources":["webpack://myblog/./src/assets/md/python/content/016-asyncio 模块.md"],"sourcesContent":["export default \"## **asyncio 模块**\\r\\n\\r\\n异步编程是一种编程范式，允许程序在等待某些操作（如 I/O 操作）完成时继续执行其他任务，而不是阻塞整个程序的执行。这种编程方式特别适用于需要处理大量并发任务的场景，例如网络请求、文件读写等。\\r\\n\\r\\nPython 提供了 `asyncio` 模块来支持异步编程，并通过 `async` 和 `await` 关键字简化了异步代码的编写。\\r\\n\\r\\n`asyncio` 是 Python 的一个标准库模块，专门用于编写异步代码。它提供了事件循环、协程、任务调度等功能，帮助开发者高效地管理并发任务。\\r\\n\\r\\n### 核心概念\\r\\n\\r\\n1. **事件循环 (Event Loop)**:\\r\\n   - 事件循环是异步编程的核心，负责调度和运行协程。\\r\\n   - 它会监听所有任务的状态，并在任务准备好时调用它们。\\r\\n\\r\\n2. **协程 (Coroutine)**:\\r\\n   - 协程是异步函数的实现形式，使用 `async def` 定义。\\r\\n   - 协程不会立即执行，而是返回一个协程对象，必须通过事件循环或 `await` 来运行。\\r\\n\\r\\n3. **任务 (Task)**:\\r\\n   - 任务是对协程的封装，允许事件循环并发地运行多个协程。\\r\\n\\r\\n4. **Future**:\\r\\n   - 表示一个尚未完成的计算结果，通常由协程返回。\\r\\n\\r\\n---\\r\\n\\r\\n### `async` 和 `await` 关键字\\r\\n\\r\\n- **`async`**:\\r\\n  - 用于定义一个异步函数（协程）。\\r\\n  - 使用 `async def` 定义的函数会返回一个协程对象，而不是直接执行函数体。\\r\\n\\r\\n- **`await`**:\\r\\n  - 用于暂停当前协程的执行，直到等待的操作完成。\\r\\n  - `await` 后面通常跟另一个协程或一个 `awaitable` 对象（如 `asyncio.sleep`）。\\r\\n\\r\\n---\\r\\n\\r\\n### 示例解析\\r\\n\\r\\n以下是一个简单的异步编程示例：\\r\\n\\r\\n```python\\r\\nimport asyncio\\r\\n\\r\\nasync def main():\\r\\n    print(\\\"Start\\\")\\r\\n    await asyncio.sleep(1)  # 模拟一个耗时操作\\r\\n    print(\\\"End\\\")\\r\\n\\r\\nasyncio.run(main())\\r\\n```\\r\\n\\r\\n### 执行流程\\r\\n\\r\\n1. **定义协程**:\\r\\n   - `main()` 是一个异步函数，使用 `async def` 定义。\\r\\n   - 当调用 `main()` 时，它不会立即执行，而是返回一个协程对象。\\r\\n\\r\\n2. **运行协程**:\\r\\n   - `asyncio.run(main())` 启动事件循环，并运行 `main()` 协程。\\r\\n   - 事件循环接管控制权，开始执行 `main()` 中的代码。\\r\\n\\r\\n3. **执行 `print(\\\"Start\\\")`**:\\r\\n   - 程序首先打印 `\\\"Start\\\"`。\\r\\n\\r\\n4. **遇到 `await asyncio.sleep(1)`**:\\r\\n   - `asyncio.sleep(1)` 是一个异步操作，模拟等待 1 秒钟。\\r\\n   - `await` 关键字暂停 `main()` 协程的执行，并将控制权交还给事件循环。\\r\\n   - 在这 1 秒内，事件循环可以运行其他任务（如果有）。\\r\\n\\r\\n5. **恢复协程**:\\r\\n   - 1 秒后，`asyncio.sleep(1)` 完成，事件循环恢复 `main()` 协程的执行。\\r\\n   - 程序继续执行 `print(\\\"End\\\")`。\\r\\n\\r\\n6. **结束程序**:\\r\\n   - 协程执行完毕，事件循环退出。\\r\\n\\r\\n---\\r\\n\\r\\n### 异步编程的优势\\r\\n\\r\\n1. **提高效率**:\\r\\n   - 异步编程避免了阻塞等待，利用等待时间执行其他任务，从而提高了程序的整体效率。\\r\\n\\r\\n2. **适合 I/O 密集型任务**:\\r\\n   - 对于涉及大量 I/O 操作的任务（如网络请求、文件读写），异步编程能显著减少等待时间。\\r\\n\\r\\n3. **简化并发**:\\r\\n   - 使用 `asyncio` 可以轻松管理多个并发任务，而无需复杂的线程或进程管理。\\r\\n\\r\\n---\\r\\n\\r\\n### 注意事项\\r\\n\\r\\n1. **不要阻塞事件循环**:\\r\\n   - 避免在协程中使用阻塞操作（如 `time.sleep`），否则会阻塞整个事件循环。\\r\\n   - 应该使用非阻塞的替代方法（如 `asyncio.sleep`）。\\r\\n\\r\\n2. **任务调度**:\\r\\n   - 如果需要并发执行多个协程，可以使用 `asyncio.gather` 或 `asyncio.create_task`。\\r\\n\\r\\n3. **调试复杂性**:\\r\\n   - 异步代码的执行顺序可能不如同步代码直观，调试时需要注意任务的状态和调度。\\r\\n\\r\\n---\\r\\n\\r\\n### 更复杂的示例：并发任务\\r\\n\\r\\n以下示例展示了如何使用 `asyncio` 并发执行多个任务：\\r\\n\\r\\n```python\\r\\nimport asyncio\\r\\n\\r\\nasync def task(name, delay):\\r\\n    print(f\\\"Task {name} started\\\")\\r\\n    await asyncio.sleep(delay)\\r\\n    print(f\\\"Task {name} finished\\\")\\r\\n\\r\\nasync def main():\\r\\n    # 创建多个任务并并发执行\\r\\n    await asyncio.gather(\\r\\n        task(\\\"A\\\", 2),\\r\\n        task(\\\"B\\\", 1),\\r\\n        task(\\\"C\\\", 3)\\r\\n    )\\r\\n\\r\\nasyncio.run(main())\\r\\n```\\r\\n\\r\\n### 输出结果\\r\\n\\r\\n```\\r\\nTask A started\\r\\nTask B started\\r\\nTask C started\\r\\nTask B finished\\r\\nTask A finished\\r\\nTask C finished\\r\\n```\\r\\n\\r\\n在这个例子中，三个任务并发执行，但由于每个任务的延迟不同，完成的顺序也不同。\\r\\n\\r\\n---\";"],"names":[],"sourceRoot":""}