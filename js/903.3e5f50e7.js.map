{"version":3,"file":"js/903.3e5f50e7.js","mappings":"mHAAA,y3E","sources":["webpack://myblog/./src/assets/md/c-plus/content/026-2 异常安全.md"],"sourcesContent":["export default \"## **2. 异常安全**\\r\\n\\r\\n异常安全是指在发生异常时，程序仍然能够保持一致的状态，避免资源泄漏或其他问题。以下是实现异常安全的关键原则。\\r\\n\\r\\n### **2.1 异常安全的代码设计**\\r\\n\\r\\n异常安全的设计通常遵循以下三种级别：\\r\\n\\r\\n1. **基本保证**：\\r\\n   - 程序在发生异常后能够保持一致的状态，但可能无法完成预期的操作。\\r\\n   - 示例：如果文件读取失败，程序应确保文件句柄被正确关闭。\\r\\n\\r\\n2. **强保证**：\\r\\n   - 程序在发生异常后能够回滚到操作前的状态。\\r\\n   - 示例：如果转账失败，账户余额应恢复到初始状态。\\r\\n\\r\\n3. **无抛出保证**：\\r\\n   - 程序在某些关键操作中保证不会抛出异常。\\r\\n   - 示例：析构函数不应抛出异常，否则可能导致未定义行为。\\r\\n\\r\\n**示例**：\\r\\n以下是一个实现强保证的示例：\\r\\n\\r\\n```cpp\\r\\n#include <iostream>\\r\\n#include <vector>\\r\\n#include <stdexcept>\\r\\nusing namespace std;\\r\\n\\r\\nvoid appendElements(vector<int>& v, int x, int y) {\\r\\n    vector<int> temp = v; // 创建临时副本\\r\\n    temp.push_back(x);\\r\\n    temp.push_back(y);\\r\\n\\r\\n    // 如果执行到这里没有抛出异常，则交换数据\\r\\n    v.swap(temp); // 提供强保证\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    vector<int> v = {1, 2, 3};\\r\\n    try {\\r\\n        appendElements(v, 4, 5);\\r\\n    } catch (const exception& e) {\\r\\n        cout << \\\"Error: \\\" << e.what() << endl;\\r\\n    }\\r\\n    for (int x : v) cout << x << \\\" \\\"; // 输出：1 2 3 4 5\\r\\n    cout << endl;\\r\\n    return 0;\\r\\n}\\r\\n```\\r\\n\\r\\n### **2.2 RAII 在异常处理中的作用**\\r\\n\\r\\nRAII（Resource Acquisition Is Initialization）是一种编程范式，强调资源的获取和释放应与对象的生命周期绑定。通过 RAII，我们可以确保即使发生异常，资源也能被正确释放。\\r\\n\\r\\n- **智能指针**：\\r\\n  使用智能指针（如 `std::unique_ptr` 和 `std::shared_ptr`）可以自动管理动态分配的内存，避免内存泄漏。\\r\\n\\r\\n**示例**：\\r\\n以下是一个使用 `std::unique_ptr` 的示例：\\r\\n\\r\\n```cpp\\r\\n#include <iostream>\\r\\n#include <memory>\\r\\nusing namespace std;\\r\\n\\r\\nvoid allocateMemory() {\\r\\n    unique_ptr<int> ptr(new int(42)); // 动态分配内存\\r\\n    if (*ptr != 42) {\\r\\n        throw runtime_error(\\\"Unexpected value\\\");\\r\\n    }\\r\\n    // 不需要手动释放内存，智能指针会在离开作用域时自动释放\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    try {\\r\\n        allocateMemory();\\r\\n    } catch (const exception& e) {\\r\\n        cout << \\\"Error: \\\" << e.what() << endl;\\r\\n    }\\r\\n    return 0;\\r\\n}\\r\\n```\\r\\n\\r\\n- **锁管理**：\\r\\n  使用 `std::lock_guard` 或 `std::unique_lock` 可以确保在发生异常时自动释放锁。\\r\\n\\r\\n**示例**：\\r\\n以下是一个使用 `std::lock_guard` 的示例：\\r\\n\\r\\n```cpp\\r\\n#include <iostream>\\r\\n#include <thread>\\r\\n#include <mutex>\\r\\nusing namespace std;\\r\\n\\r\\nmutex mtx;\\r\\n\\r\\nvoid criticalSection() {\\r\\n    lock_guard<mutex> lock(mtx); // 自动加锁\\r\\n    cout << \\\"Thread ID: \\\" << this_thread::get_id() << endl;\\r\\n    // 如果发生异常，锁会自动释放\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    thread t1(criticalSection);\\r\\n    thread t2(criticalSection);\\r\\n    t1.join();\\r\\n    t2.join();\\r\\n    return 0;\\r\\n}\\r\\n```\\r\\n\\r\\n---\";"],"names":[],"sourceRoot":""}