"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[1864],{81864:function(n,r,e){e.r(r),r["default"]='# **八、数据库与网络编程**\r\n\r\n## **1. JDBC**\r\n\r\nJDBC（Java Database Connectivity）是 Java 提供的一组 API，用于与关系型数据库进行交互。它通过标准接口屏蔽了底层数据库的实现细节，使得开发者可以使用统一的方式操作不同的数据库。\r\n\r\n---\r\n\r\n### **1.1 JDBC 的基本使用**\r\n\r\nJDBC 操作数据库的基本步骤如下：\r\n\r\n1. **加载驱动程序**\r\n   - 使用 `Class.forName()` 方法加载数据库驱动程序。\r\n   - 现代 JDBC 驱动程序通常支持自动加载，因此在某些情况下可以省略这一步。\r\n\r\n   ```java\r\n   Class.forName("com.mysql.cj.jdbc.Driver");\r\n   ```\r\n\r\n2. **建立连接**\r\n   - 使用 `DriverManager.getConnection()` 方法创建数据库连接。\r\n   - URL 格式因数据库而异，例如 MySQL 的连接 URL 是：\r\n\r\n     ```\r\n     jdbc:mysql://[host]:[port]/[database]?user=[username]&password=[password]\r\n     ```\r\n\r\n   ```java\r\n   String url = "jdbc:mysql://localhost:3306/testdb";\r\n   String user = "root";\r\n   String password = "password";\r\n   Connection conn = DriverManager.getConnection(url, user, password);\r\n   ```\r\n\r\n3. **执行 SQL**\r\n   - 创建 `Statement` 或 `PreparedStatement` 对象来执行 SQL 查询。\r\n   - 使用 `executeQuery()` 执行查询语句，返回 `ResultSet`。\r\n   - 使用 `executeUpdate()` 执行更新、插入或删除语句，返回受影响的行数。\r\n\r\n   ```java\r\n   // 查询示例\r\n   Statement stmt = conn.createStatement();\r\n   ResultSet rs = stmt.executeQuery("SELECT * FROM users");\r\n\r\n   while (rs.next()) {\r\n       System.out.println(rs.getString("name"));\r\n   }\r\n\r\n   // 插入示例\r\n   PreparedStatement pstmt = conn.prepareStatement("INSERT INTO users(name, age) VALUES(?, ?)");\r\n   pstmt.setString(1, "Alice");\r\n   pstmt.setInt(2, 25);\r\n   int rowsAffected = pstmt.executeUpdate();\r\n   ```\r\n\r\n4. **关闭资源**\r\n   - 按照打开顺序的逆序关闭资源（`ResultSet` -> `Statement` -> `Connection`）。\r\n   - 使用 try-with-resources 自动关闭资源。\r\n\r\n   ```java\r\n   try (Connection conn = DriverManager.getConnection(url, user, password);\r\n        Statement stmt = conn.createStatement();\r\n        ResultSet rs = stmt.executeQuery("SELECT * FROM users")) {\r\n\r\n       while (rs.next()) {\r\n           System.out.println(rs.getString("name"));\r\n       }\r\n   } catch (SQLException e) {\r\n       e.printStackTrace();\r\n   }\r\n   ```\r\n\r\n---\r\n\r\n### **1.2 事务管理**\r\n\r\n事务是一组逻辑操作单元，要么全部成功提交，要么全部回滚。JDBC 支持事务管理，主要通过以下方法实现：\r\n\r\n1. **设置自动提交模式**\r\n   - 默认情况下，JDBC 连接处于自动提交模式（`autoCommit=true`），即每条 SQL 语句都会立即生效。\r\n   - 可以通过 `conn.setAutoCommit(false)` 关闭自动提交模式，手动控制事务。\r\n\r\n   ```java\r\n   conn.setAutoCommit(false); // 关闭自动提交\r\n   ```\r\n\r\n2. **提交事务**\r\n   - 在所有操作完成后调用 `conn.commit()` 提交事务。\r\n\r\n   ```java\r\n   conn.commit(); // 提交事务\r\n   ```\r\n\r\n3. **回滚事务**\r\n   - 如果发生异常，调用 `conn.rollback()` 回滚事务。\r\n\r\n   ```java\r\n   try {\r\n       conn.setAutoCommit(false);\r\n       // 执行多个 SQL 操作\r\n       conn.commit();\r\n   } catch (SQLException e) {\r\n       conn.rollback(); // 发生异常时回滚\r\n       e.printStackTrace();\r\n   } finally {\r\n       conn.setAutoCommit(true); // 恢复默认的自动提交模式\r\n   }\r\n   ```\r\n\r\n---\r\n\r\n### **1.3 连接池**\r\n\r\n频繁地创建和关闭数据库连接会导致性能开销，因此引入了连接池技术。连接池预先创建一组数据库连接，并在需要时分配给应用程序使用，使用完毕后归还到池中。\r\n\r\n常见的连接池实现包括 HikariCP、C3P0 和 DBCP。\r\n\r\n#### **HikariCP 示例**\r\n\r\n```java\r\nimport com.zaxxer.hikari.HikariConfig;\r\nimport com.zaxxer.hikari.HikariDataSource;\r\n\r\npublic class HikariExample {\r\n    public static void main(String[] args) throws Exception {\r\n        HikariConfig config = new HikariConfig();\r\n        config.setJdbcUrl("jdbc:mysql://localhost:3306/testdb");\r\n        config.setUsername("root");\r\n        config.setPassword("password");\r\n        config.setMaximumPoolSize(10);\r\n\r\n        try (HikariDataSource ds = new HikariDataSource(config);\r\n             Connection conn = ds.getConnection()) {\r\n\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet rs = stmt.executeQuery("SELECT * FROM users");\r\n\r\n            while (rs.next()) {\r\n                System.out.println(rs.getString("name"));\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## **2.网络编程**\r\n\r\n网络编程是指通过计算机网络实现不同设备之间的通信。Java 提供了丰富的网络编程 API，主要包括 TCP/IP 和 UDP 协议的支持。\r\n\r\n---\r\n\r\n### **2.1 TCP/IP 协议与 UDP 协议**\r\n\r\n- **TCP/IP**\r\n  - 面向连接的协议，提供可靠的、有序的数据传输。\r\n  - 常用于需要高可靠性的场景，如文件传输、电子邮件等。\r\n  - 基于三次握手建立连接。\r\n\r\n- **UDP**\r\n  - 面向无连接的协议，不保证数据包的可靠性，但效率更高。\r\n  - 常用于实时性要求较高的场景，如视频会议、在线游戏等。\r\n\r\n---\r\n\r\n### **2.2 Socket 编程**\r\n\r\nSocket 是网络通信的基础，Java 提供了 `java.net.Socket` 和 `java.net.ServerSocket` 类分别用于客户端和服务器端的通信。\r\n\r\n#### **服务器端实现**\r\n\r\n```java\r\nimport java.io.*;\r\nimport java.net.*;\r\n\r\npublic class Server {\r\n    public static void main(String[] args) throws IOException {\r\n        ServerSocket serverSocket = new ServerSocket(8080);\r\n        System.out.println("Server is listening on port 8080...");\r\n\r\n        while (true) {\r\n            Socket clientSocket = serverSocket.accept(); // 接受客户端连接\r\n            System.out.println("Client connected: " + clientSocket.getInetAddress());\r\n\r\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\r\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\r\n\r\n            String inputLine;\r\n            while ((inputLine = in.readLine()) != null) {\r\n                System.out.println("Received: " + inputLine);\r\n                out.println("Echo: " + inputLine); // 返回响应\r\n            }\r\n\r\n            clientSocket.close();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n#### **客户端实现**\r\n\r\n```java\r\nimport java.io.*;\r\nimport java.net.*;\r\n\r\npublic class Client {\r\n    public static void main(String[] args) throws IOException {\r\n        Socket socket = new Socket("localhost", 8080);\r\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\r\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\r\n\r\n        BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in));\r\n        String userInput;\r\n\r\n        while ((userInput = stdIn.readLine()) != null) {\r\n            out.println(userInput); // 发送数据到服务器\r\n            System.out.println("Server response: " + in.readLine()); // 接收服务器响应\r\n        }\r\n\r\n        socket.close();\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### **2.3 NIO 在网络编程中的应用**\r\n\r\nNIO（New I/O）是 Java 提供的一种高效 I/O 模型，基于缓冲区和通道，可以实现非阻塞式网络通信。\r\n\r\n#### **NIO 示例：非阻塞服务器**\r\n\r\n```java\r\nimport java.io.IOException;\r\nimport java.net.InetSocketAddress;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.channels.SelectionKey;\r\nimport java.nio.channels.Selector;\r\nimport java.nio.channels.ServerSocketChannel;\r\nimport java.nio.channels.SocketChannel;\r\nimport java.util.Iterator;\r\n\r\npublic class NIOServer {\r\n    public static void main(String[] args) throws IOException {\r\n        Selector selector = Selector.open();\r\n        ServerSocketChannel serverSocket = ServerSocketChannel.open();\r\n        serverSocket.bind(new InetSocketAddress(8080));\r\n        serverSocket.configureBlocking(false);\r\n        serverSocket.register(selector, SelectionKey.OP_ACCEPT);\r\n\r\n        ByteBuffer buffer = ByteBuffer.allocate(256);\r\n\r\n        while (true) {\r\n            selector.select();\r\n            Iterator<SelectionKey> keys = selector.selectedKeys().iterator();\r\n\r\n            while (keys.hasNext()) {\r\n                SelectionKey key = keys.next();\r\n                keys.remove();\r\n\r\n                if (key.isAcceptable()) {\r\n                    ServerSocketChannel server = (ServerSocketChannel) key.channel();\r\n                    SocketChannel client = server.accept();\r\n                    client.configureBlocking(false);\r\n                    client.register(selector, SelectionKey.OP_READ);\r\n                    System.out.println("Client connected: " + client.getRemoteAddress());\r\n                } else if (key.isReadable()) {\r\n                    SocketChannel client = (SocketChannel) key.channel();\r\n                    buffer.clear();\r\n                    int read = client.read(buffer);\r\n                    if (read == -1) {\r\n                        client.close();\r\n                    } else {\r\n                        buffer.flip();\r\n                        byte[] data = new byte[buffer.remaining()];\r\n                        buffer.get(data);\r\n                        System.out.println("Received: " + new String(data));\r\n                        client.write(ByteBuffer.wrap(("Echo: " + new String(data)).getBytes()));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---'}}]);
//# sourceMappingURL=1864.6997181e.js.map