"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[18254],{18254:function(n,r,e){e.r(r),r["default"]="## **3.4. 多级页表（Multi-level Page Table）**\r\n\r\n### **背景**\r\n\r\n传统的单级页表在处理大地址空间时存在严重的内存浪费问题。例如，在 32 位系统中，如果页大小为 4KB，页表需要存储 \\(2^{20}\\) 个条目（因为 \\(2^{32} / 2^{12} = 2^{20}\\)），即使只使用少量页也会占用大量内存。\r\n\r\n### **基本思想**\r\n\r\n多级页表通过将页表分层，仅保留实际使用的部分，从而减少内存开销。\r\n\r\n### **工作原理**\r\n\r\n以两级页表为例：\r\n\r\n1. **虚拟地址结构**：\r\n   - 页目录号（Page Directory Index）\r\n   - 页表号（Page Table Index）\r\n   - 页内偏移量（Offset）\r\n2. **页目录（Page Directory）**：\r\n   - 每个页目录项指向一个页表。\r\n3. **页表（Page Table）**：\r\n   - 每个页表项指向一个物理页框。\r\n4. **查找过程**：\r\n   - 根据页目录号找到对应的页表。\r\n   - 根据页表号找到对应的物理页框。\r\n   - 结合页内偏移量计算最终物理地址。\r\n\r\n### **优点**\r\n\r\n- **节省内存**：只有实际使用的页表才被分配内存。\r\n- **扩展性强**：支持更大的地址空间（如 64 位系统）。\r\n\r\n### **缺点**\r\n\r\n- **访问延迟增加**：需要多次查表操作（可以通过 TLB 缓存优化）。\r\n- **实现复杂**：需要维护多级结构。\r\n\r\n### **示例**\r\n\r\n假设页大小为 4KB，页表项大小为 4 字节：\r\n\r\n- 单级页表需要 \\(2^{20} \\times 4\\) 字节（即 4MB）。\r\n- 使用两级页表后，每级只需要 \\(2^{10} \\times 4\\) 字节（即 4KB），总共只需要两份 4KB 的页表。\r\n\r\n---\r\n\r\n好的！接下来我们将以类似的方式讲解段页式内存管理（Segmented Paging Memory Management）。段页式内存管理结合了分段和分页两种技术的优点，既提供了逻辑上的模块化划分（分段），又通过分页实现了高效的内存使用和管理。\r\n\r\n---"}}]);
//# sourceMappingURL=18254.0be0a2a5.js.map