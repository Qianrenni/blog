{"version":3,"file":"js/40.173fd73c.js","mappings":"kHAAA,g9S","sources":["webpack://myblog/./src/assets/md/java/content/005-五IO 流.md"],"sourcesContent":["export default \"# **五、I/O 流**\\r\\n\\r\\n以下是关于 **Java I/O 流** 的详细讲解，涵盖文件操作、字节流与字符流、序列化与反序列化以及 NIO 的核心内容。\\r\\n\\r\\n---\\r\\n\\r\\n## **1. 文件操作**\\r\\n\\r\\n### **1.1 文件的创建、删除、读取与写入**\\r\\n\\r\\nJava 中通过 `File` 类可以对文件和目录进行操作。以下是一些常见的文件操作：\\r\\n\\r\\n#### **1.1.1 创建文件**\\r\\n\\r\\n```java\\r\\nimport java.io.File;\\r\\nimport java.io.IOException;\\r\\n\\r\\npublic class FileExample {\\r\\n    public static void main(String[] args) throws IOException {\\r\\n        File file = new File(\\\"example.txt\\\");\\r\\n        if (file.createNewFile()) {\\r\\n            System.out.println(\\\"File created: \\\" + file.getName());\\r\\n        } else {\\r\\n            System.out.println(\\\"File already exists.\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n#### **1.1.2 删除文件**\\r\\n\\r\\n```java\\r\\nFile file = new File(\\\"example.txt\\\");\\r\\nif (file.delete()) {\\r\\n    System.out.println(\\\"File deleted: \\\" + file.getName());\\r\\n} else {\\r\\n    System.out.println(\\\"Failed to delete the file.\\\");\\r\\n}\\r\\n```\\r\\n\\r\\n#### **1.1.3 读取文件**\\r\\n\\r\\n使用 `FileInputStream` 或 `BufferedReader` 读取文件内容：\\r\\n\\r\\n```java\\r\\nimport java.io.BufferedReader;\\r\\nimport java.io.FileReader;\\r\\nimport java.io.IOException;\\r\\n\\r\\npublic class FileReadExample {\\r\\n    public static void main(String[] args) throws IOException {\\r\\n        BufferedReader reader = new BufferedReader(new FileReader(\\\"example.txt\\\"));\\r\\n        String line;\\r\\n        while ((line = reader.readLine()) != null) {\\r\\n            System.out.println(line);\\r\\n        }\\r\\n        reader.close();\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n#### **1.1.4 写入文件**\\r\\n\\r\\n使用 `FileOutputStream` 或 `BufferedWriter` 写入文件内容：\\r\\n\\r\\n```java\\r\\nimport java.io.BufferedWriter;\\r\\nimport java.io.FileWriter;\\r\\nimport java.io.IOException;\\r\\n\\r\\npublic class FileWriteExample {\\r\\n    public static void main(String[] args) throws IOException {\\r\\n        BufferedWriter writer = new BufferedWriter(new FileWriter(\\\"example.txt\\\"));\\r\\n        writer.write(\\\"Hello, World!\\\");\\r\\n        writer.close();\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### **1.2 File 类的常用方法**\\r\\n\\r\\n| 方法名                      | 描述                                   |\\r\\n|-----------------------------|---------------------------------------|\\r\\n| `createNewFile()`           | 创建新文件                           |\\r\\n| `delete()`                  | 删除文件或目录                       |\\r\\n| `exists()`                  | 检查文件或目录是否存在               |\\r\\n| `isFile()`                  | 判断是否为文件                       |\\r\\n| `isDirectory()`             | 判断是否为目录                       |\\r\\n| `getName()`                 | 获取文件或目录的名称                 |\\r\\n| `getPath()`                 | 获取文件或目录的路径                 |\\r\\n| `length()`                  | 获取文件的大小（以字节为单位）       |\\r\\n| `listFiles()`               | 获取目录中的文件和子目录列表         |\\r\\n\\r\\n---\\r\\n\\r\\n## **2. 字节流与字符流**\\r\\n\\r\\n### **2.1 字节流（InputStream 和 OutputStream）**\\r\\n\\r\\n- **定义**：\\r\\n  - 字节流用于处理二进制数据（如图片、音频等），基于字节（8 位）操作。\\r\\n- **常用类**：\\r\\n  - `InputStream`：输入流的基类。\\r\\n  - `OutputStream`：输出流的基类。\\r\\n  - 具体实现类：\\r\\n    - `FileInputStream` 和 `FileOutputStream`\\r\\n    - `BufferedInputStream` 和 `BufferedOutputStream`\\r\\n\\r\\n#### **示例：复制文件（使用字节流）**\\r\\n\\r\\n```java\\r\\nimport java.io.FileInputStream;\\r\\nimport java.io.FileOutputStream;\\r\\nimport java.io.IOException;\\r\\n\\r\\npublic class CopyFileExample {\\r\\n    public static void main(String[] args) throws IOException {\\r\\n        FileInputStream in = new FileInputStream(\\\"source.txt\\\");\\r\\n        FileOutputStream out = new FileOutputStream(\\\"target.txt\\\");\\r\\n\\r\\n        byte[] buffer = new byte[1024];\\r\\n        int bytesRead;\\r\\n        while ((bytesRead = in.read(buffer)) != -1) {\\r\\n            out.write(buffer, 0, bytesRead);\\r\\n        }\\r\\n\\r\\n        in.close();\\r\\n        out.close();\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### **2.2 字符流（Reader 和 Writer）**\\r\\n\\r\\n- **定义**：\\r\\n  - 字符流用于处理文本数据，基于字符（16 位 Unicode）操作。\\r\\n- **常用类**：\\r\\n  - `Reader`：输入流的基类。\\r\\n  - `Writer`：输出流的基类。\\r\\n  - 具体实现类：\\r\\n    - `FileReader` 和 `FileWriter`\\r\\n    - `BufferedReader` 和 `BufferedWriter`\\r\\n\\r\\n#### **示例：读取和写入文本文件（使用字符流）**\\r\\n\\r\\n```java\\r\\nimport java.io.*;\\r\\n\\r\\npublic class TextFileExample {\\r\\n    public static void main(String[] args) throws IOException {\\r\\n        // 写入文件\\r\\n        BufferedWriter writer = new BufferedWriter(new FileWriter(\\\"output.txt\\\"));\\r\\n        writer.write(\\\"Hello, Java I/O!\\\");\\r\\n        writer.close();\\r\\n\\r\\n        // 读取文件\\r\\n        BufferedReader reader = new BufferedReader(new FileReader(\\\"output.txt\\\"));\\r\\n        String line;\\r\\n        while ((line = reader.readLine()) != null) {\\r\\n            System.out.println(line);\\r\\n        }\\r\\n        reader.close();\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **3. 序列化与反序列化**\\r\\n\\r\\n### **3.1 Serializable 接口的作用**\\r\\n\\r\\n- **定义**：\\r\\n  - `Serializable` 是一个标记接口，表示对象可以被序列化（转换为字节流）。\\r\\n- **用途**：\\r\\n  - 主要用于将对象保存到文件或通过网络传输。\\r\\n\\r\\n#### **示例：序列化与反序列化**\\r\\n\\r\\n```java\\r\\nimport java.io.*;\\r\\n\\r\\nclass Person implements Serializable {\\r\\n    private static final long serialVersionUID = 1L;\\r\\n    private String name;\\r\\n    private int age;\\r\\n\\r\\n    public Person(String name, int age) {\\r\\n        this.name = name;\\r\\n        this.age = age;\\r\\n    }\\r\\n\\r\\n    @Override\\r\\n    public String toString() {\\r\\n        return \\\"Person{name='\\\" + name + \\\"', age=\\\" + age + \\\"}\\\";\\r\\n    }\\r\\n}\\r\\n\\r\\npublic class SerializationExample {\\r\\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\\r\\n        // 序列化\\r\\n        Person person = new Person(\\\"Alice\\\", 25);\\r\\n        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\\\"person.ser\\\"));\\r\\n        out.writeObject(person);\\r\\n        out.close();\\r\\n\\r\\n        // 反序列化\\r\\n        ObjectInputStream in = new ObjectInputStream(new FileInputStream(\\\"person.ser\\\"));\\r\\n        Person deserializedPerson = (Person) in.readObject();\\r\\n        in.close();\\r\\n\\r\\n        System.out.println(deserializedPerson); // 输出：Person{name='Alice', age=25}\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### **3.2 注意事项**\\r\\n\\r\\n1. **serialVersionUID**：\\r\\n   - 建议显式声明 `serialVersionUID`，以确保序列化和反序列化的兼容性。\\r\\n2. **静态成员**：\\r\\n   - 静态字段不会被序列化，因为它们属于类而不是对象。\\r\\n3. **瞬态字段**：\\r\\n   - 使用 `transient` 关键字修饰的字段不会被序列化。\\r\\n\\r\\n---\\r\\n\\r\\n## **4. NIO（New I/O）**\\r\\n\\r\\n### **4.1 缓冲区（Buffer）**\\r\\n\\r\\n- **定义**：\\r\\n  - 缓冲区是 NIO 的核心组件，用于存储数据。\\r\\n  - 常见类型：`ByteBuffer`, `CharBuffer`, `IntBuffer` 等。\\r\\n- **基本操作**：\\r\\n  - `put()`：向缓冲区写入数据。\\r\\n  - `get()`：从缓冲区读取数据。\\r\\n  - `flip()`：切换到读模式。\\r\\n  - `clear()`：清空缓冲区，切换到写模式。\\r\\n\\r\\n#### **示例：使用 ByteBuffer**\\r\\n\\r\\n```java\\r\\nimport java.nio.ByteBuffer;\\r\\n\\r\\npublic class BufferExample {\\r\\n    public static void main(String[] args) {\\r\\n        ByteBuffer buffer = ByteBuffer.allocate(10);\\r\\n\\r\\n        // 写入数据\\r\\n        buffer.put((byte) 1);\\r\\n        buffer.put((byte) 2);\\r\\n\\r\\n        // 切换到读模式\\r\\n        buffer.flip();\\r\\n\\r\\n        // 读取数据\\r\\n        while (buffer.hasRemaining()) {\\r\\n            System.out.println(buffer.get());\\r\\n        }\\r\\n\\r\\n        // 清空缓冲区\\r\\n        buffer.clear();\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### **4.2 通道（Channel）**\\r\\n\\r\\n- **定义**：\\r\\n  - 通道是数据传输的载体，支持双向读写。\\r\\n- **常用类**：\\r\\n  - `FileChannel`：用于文件操作。\\r\\n  - `SocketChannel` 和 `ServerSocketChannel`：用于网络通信。\\r\\n\\r\\n#### **示例：使用 FileChannel 复制文件**\\r\\n\\r\\n```java\\r\\nimport java.io.FileInputStream;\\r\\nimport java.io.FileOutputStream;\\r\\nimport java.nio.channels.FileChannel;\\r\\n\\r\\npublic class FileChannelExample {\\r\\n    public static void main(String[] args) throws Exception {\\r\\n        FileInputStream in = new FileInputStream(\\\"source.txt\\\");\\r\\n        FileOutputStream out = new FileOutputStream(\\\"target.txt\\\");\\r\\n\\r\\n        FileChannel inChannel = in.getChannel();\\r\\n        FileChannel outChannel = out.getChannel();\\r\\n\\r\\n        outChannel.transferFrom(inChannel, 0, inChannel.size());\\r\\n\\r\\n        inChannel.close();\\r\\n        outChannel.close();\\r\\n        in.close();\\r\\n        out.close();\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### **4.3 文件锁与内存映射文件**\\r\\n\\r\\n#### **文件锁**\\r\\n\\r\\n- **作用**：\\r\\n  - 防止多个进程同时修改同一文件。\\r\\n- **示例**：\\r\\n\\r\\n  ```java\\r\\n  import java.io.RandomAccessFile;\\r\\n  import java.nio.channels.FileChannel;\\r\\n  import java.nio.channels.FileLock;\\r\\n\\r\\n  public class FileLockExample {\\r\\n      public static void main(String[] args) throws Exception {\\r\\n          RandomAccessFile file = new RandomAccessFile(\\\"test.txt\\\", \\\"rw\\\");\\r\\n          FileChannel channel = file.getChannel();\\r\\n\\r\\n          FileLock lock = channel.lock(); // 加锁\\r\\n          System.out.println(\\\"File is locked.\\\");\\r\\n\\r\\n          lock.release(); // 解锁\\r\\n          System.out.println(\\\"File is unlocked.\\\");\\r\\n\\r\\n          channel.close();\\r\\n          file.close();\\r\\n      }\\r\\n  }\\r\\n  ```\\r\\n\\r\\n#### **内存映射文件**\\r\\n\\r\\n- **定义**：\\r\\n  - 将文件直接映射到内存中，提高文件读写效率。\\r\\n- **示例**：\\r\\n\\r\\n  ```java\\r\\n  import java.io.RandomAccessFile;\\r\\n  import java.nio.MappedByteBuffer;\\r\\n  import java.nio.channels.FileChannel;\\r\\n\\r\\n  public class MappedFileExample {\\r\\n      public static void main(String[] args) throws Exception {\\r\\n          RandomAccessFile file = new RandomAccessFile(\\\"test.txt\\\", \\\"rw\\\");\\r\\n          FileChannel channel = file.getChannel();\\r\\n\\r\\n          MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, channel.size());\\r\\n          buffer.put(0, (byte) 'H');\\r\\n          buffer.put(1, (byte) 'i');\\r\\n\\r\\n          channel.close();\\r\\n          file.close();\\r\\n      }\\r\\n  }\\r\\n  ```\\r\\n\\r\\n---\\r\\n\\r\\n## **总结**\\r\\n\\r\\n- **文件操作** 提供了对文件和目录的基本操作。\\r\\n- **字节流** 和 **字符流** 分别用于处理二进制数据和文本数据。\\r\\n- **序列化** 和 **反序列化** 使得对象可以在不同环境中传递和存储。\\r\\n- **NIO** 提供了更高效的 I/O 操作方式，包括缓冲区、通道、文件锁和内存映射文件。\\r\\n\\r\\n---\";"],"names":[],"sourceRoot":""}