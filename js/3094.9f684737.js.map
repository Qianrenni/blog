{"version":3,"file":"js/3094.9f684737.js","mappings":"oHAAA,yhN","sources":["webpack://myblog/./src/assets/md/python/content/012-装饰器.md"],"sourcesContent":["export default \"## **装饰器**\\r\\n\\r\\n装饰器是 Python 中一种强大的工具，用于在不修改原函数或类代码的情况下，动态地增强其功能。装饰器可以应用于函数、方法和类，分别称为**函数装饰器**和**类装饰器**。\\r\\n\\r\\n---\\r\\n\\r\\n### **装饰器的核心原理**\\r\\n\\r\\n装饰器本质上是一个**高阶函数**，即一个接受函数（或类）作为参数并返回一个新的函数（或类）的可调用对象。装饰器的核心思想是通过包装原始对象来扩展其行为。\\r\\n\\r\\n```python\\r\\n# 装饰器的基本结构\\r\\ndef decorator(original):\\r\\n    def wrapper(*args, **kwargs):\\r\\n        # 增强逻辑\\r\\n        result = original(*args, **kwargs)\\r\\n        return result\\r\\n    return wrapper\\r\\n```\\r\\n\\r\\n- `original` 是被装饰的函数或类。\\r\\n- `wrapper` 是包装后的函数或类。\\r\\n- `*args` 和 `**kwargs` 用于支持任意数量和类型的参数传递。\\r\\n\\r\\n---\\r\\n\\r\\n### **函数装饰器**\\r\\n\\r\\n函数装饰器用于修饰函数或方法的行为。它是最常见的装饰器形式，适用于日志记录、性能测试、输入验证等场景。\\r\\n\\r\\n#### **基本示例**\\r\\n\\r\\n以下是一个简单的函数装饰器，用于打印函数调用信息：\\r\\n\\r\\n```python\\r\\ndef log(func):\\r\\n    def wrapper(*args, **kwargs):\\r\\n        print(f\\\"Calling {func.__name__} with args={args}, kwargs={kwargs}\\\")\\r\\n        return func(*args, **kwargs)\\r\\n    return wrapper\\r\\n\\r\\n@log\\r\\ndef add(a, b):\\r\\n    return a + b\\r\\n\\r\\nresult = add(3, 5)\\r\\nprint(f\\\"Result: {result}\\\")\\r\\n```\\r\\n\\r\\n**输出：**\\r\\n\\r\\n```\\r\\nCalling add with args=(3, 5), kwargs={}\\r\\nResult: 8\\r\\n```\\r\\n\\r\\n#### **带参数的函数装饰器**\\r\\n\\r\\n如果需要让装饰器本身也接受参数，可以通过再嵌套一层函数实现：\\r\\n\\r\\n```python\\r\\ndef log_with_message(message):\\r\\n    def decorator(func):\\r\\n        def wrapper(*args, **kwargs):\\r\\n            print(f\\\"{message}: Calling {func.__name__}\\\")\\r\\n            return func(*args, **kwargs)\\r\\n        return wrapper\\r\\n    return decorator\\r\\n\\r\\n@log_with_message(\\\"INFO\\\")\\r\\ndef greet(name):\\r\\n    print(f\\\"Hello, {name}\\\")\\r\\n\\r\\ngreet(\\\"Alice\\\")\\r\\n```\\r\\n\\r\\n**输出：**\\r\\n\\r\\n```\\r\\nINFO: Calling greet\\r\\nHello, Alice\\r\\n```\\r\\n\\r\\n#### **使用 `functools.wraps`**\\r\\n\\r\\n当使用装饰器时，原始函数的元数据（如 `__name__` 和 `__doc__`）可能会丢失。为了解决这个问题，可以使用 `functools.wraps` 来保留这些信息：\\r\\n\\r\\n```python\\r\\nfrom functools import wraps\\r\\n\\r\\ndef log(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        print(f\\\"Calling {func.__name__}\\\")\\r\\n        return func(*args, **kwargs)\\r\\n    return wrapper\\r\\n\\r\\n@log\\r\\ndef add(a, b):\\r\\n    \\\"\\\"\\\"Add two numbers.\\\"\\\"\\\"\\r\\n    return a + b\\r\\n\\r\\nprint(add.__name__)  # 输出: add\\r\\nprint(add.__doc__)   # 输出: Add two numbers.\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### **类装饰器**\\r\\n\\r\\n类装饰器用于修饰类，能够动态地修改类定义或添加额外的功能。与函数装饰器类似，类装饰器也是一个接受类作为参数的可调用对象。\\r\\n\\r\\n#### **基本示例**\\r\\n\\r\\n以下是一个简单的类装饰器，用于为类添加属性和方法：\\r\\n\\r\\n```python\\r\\ndef add_info(cls):\\r\\n    cls.new_attribute = \\\"This is a new attribute\\\"\\r\\n    \\r\\n    def new_method(self):\\r\\n        print(\\\"This is a new method\\\")\\r\\n    \\r\\n    cls.new_method = new_method\\r\\n    return cls\\r\\n\\r\\n@add_info\\r\\nclass Person:\\r\\n    def __init__(self, name):\\r\\n        self.name = name\\r\\n\\r\\np = Person(\\\"Alice\\\")\\r\\nprint(p.new_attribute)  # 输出: This is a new attribute\\r\\np.new_method()          # 输出: This is a new method\\r\\n```\\r\\n\\r\\n#### **修改类的方法**\\r\\n\\r\\n类装饰器还可以用于修改类的现有方法。例如，在方法调用前后打印日志：\\r\\n\\r\\n```python\\r\\ndef log_methods(cls):\\r\\n    for name, method in cls.__dict__.items():\\r\\n        if callable(method):  # 检查是否为方法\\r\\n            def make_wrapper(m):\\r\\n                def wrapper(*args, **kwargs):\\r\\n                    print(f\\\"Calling method: {m.__name__}\\\")\\r\\n                    return m(*args, **kwargs)\\r\\n                return wrapper\\r\\n            \\r\\n            setattr(cls, name, make_wrapper(method))\\r\\n    return cls\\r\\n\\r\\n@log_methods\\r\\nclass Math:\\r\\n    def add(self, a, b):\\r\\n        return a + b\\r\\n    \\r\\n    def multiply(self, a, b):\\r\\n        return a * b\\r\\n\\r\\nm = Math()\\r\\nprint(m.add(3, 5))       # 输出: Calling method: add \\\\n 8\\r\\nprint(m.multiply(3, 5))  # 输出: Calling method: multiply \\\\n 15\\r\\n```\\r\\n\\r\\n#### **自动注册类**\\r\\n\\r\\n类装饰器常用于将类自动注册到某个全局字典中，便于后续管理：\\r\\n\\r\\n```python\\r\\nregistry = {}\\r\\n\\r\\ndef register(cls):\\r\\n    registry[cls.__name__] = cls\\r\\n    return cls\\r\\n\\r\\n@register\\r\\nclass Person:\\r\\n    pass\\r\\n\\r\\n@register\\r\\nclass Car:\\r\\n    pass\\r\\n\\r\\nprint(registry)  # 输出: {'Person': <class '__main__.Person'>, 'Car': <class '__main__.Car'>}\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### **装饰器的延展应用**\\r\\n\\r\\n#### **1. 性能测试装饰器**\\r\\n\\r\\n以下是一个用于测量函数执行时间的装饰器：\\r\\n\\r\\n```python\\r\\nimport time\\r\\n\\r\\ndef timer(func):\\r\\n    def wrapper(*args, **kwargs):\\r\\n        start_time = time.time()\\r\\n        result = func(*args, **kwargs)\\r\\n        end_time = time.time()\\r\\n        print(f\\\"Execution time: {end_time - start_time:.4f} seconds\\\")\\r\\n        return result\\r\\n    return wrapper\\r\\n\\r\\n@timer\\r\\ndef slow_function():\\r\\n    time.sleep(2)\\r\\n\\r\\nslow_function()\\r\\n\\r\\n#类和方法一起处理\\r\\ndef count_time(func_or_cls):\\r\\n    # 如果是函数\\r\\n    if isfunction(func_or_cls):\\r\\n        @wraps(func_or_cls)\\r\\n        def wrapper(*args, **kwargs):\\r\\n            start = time.time()\\r\\n            result = func_or_cls(*args, **kwargs)\\r\\n            end = time.time()\\r\\n            print(f\\\"{func_or_cls.__name__} cost {end - start:.6f}s\\\")\\r\\n            return result\\r\\n        return wrapper\\r\\n    # 如果是类\\r\\n    elif isclass(func_or_cls):\\r\\n        cls = func_or_cls\\r\\n        for name, method in vars(cls).items():\\r\\n            if callable(method) and not (name.startswith(\\\"__\\\") and name.endswith(\\\"__\\\")):\\r\\n                setattr(cls, name, count_time(method))\\r\\n        return cls\\r\\n    else:\\r\\n        raise TypeError(\\\"count_time can only decorate functions or classes.\\\")\\r\\n```\\r\\n\\r\\n#### **2. 缓存装饰器**\\r\\n\\r\\nPython 提供了内置的 `functools.lru_cache` 装饰器，用于缓存函数的结果以提高性能：\\r\\n\\r\\n```python\\r\\nfrom functools import lru_cache\\r\\n\\r\\n@lru_cache(maxsize=None)\\r\\ndef fibonacci(n):\\r\\n    if n <= 1:\\r\\n        return n\\r\\n    return fibonacci(n - 1) + fibonacci(n - 2)\\r\\n\\r\\nprint(fibonacci(10))  # 输出: 55\\r\\n```\\r\\n\\r\\n#### **3. 权限校验装饰器**\\r\\n\\r\\n以下是一个用于检查用户权限的装饰器：\\r\\n\\r\\n```python\\r\\ndef require_permission(permission):\\r\\n    def decorator(func):\\r\\n        def wrapper(user, *args, **kwargs):\\r\\n            if permission in user.permissions:\\r\\n                return func(user, *args, **kwargs)\\r\\n            raise PermissionError(f\\\"User does not have {permission} permission\\\")\\r\\n        return wrapper\\r\\n    return decorator\\r\\n\\r\\nclass User:\\r\\n    def __init__(self, permissions):\\r\\n        self.permissions = permissions\\r\\n\\r\\n@require_permission(\\\"admin\\\")\\r\\ndef delete_resource(user):\\r\\n    print(\\\"Resource deleted\\\")\\r\\n\\r\\nuser = User([\\\"admin\\\"])\\r\\ndelete_resource(user)  # 输出: Resource deleted\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### **总结**\\r\\n\\r\\n1. **装饰器的核心**：\\r\\n   - 高阶函数（接受函数或类作为参数，并返回新的函数或类）。\\r\\n   - 动态增强功能，无需修改原始代码。\\r\\n\\r\\n2. **函数装饰器**：\\r\\n   - 适用于函数或方法。\\r\\n   - 常见用途：日志记录、性能测试、输入验证等。\\r\\n\\r\\n3. **类装饰器**：\\r\\n   - 适用于类。\\r\\n   - 常见用途：自动注册、接口检查、动态扩展类行为。\\r\\n\\r\\n4. **高级特性**：\\r\\n   - 使用 `functools.wraps` 保留函数元数据。\\r\\n   - 结合缓存、权限校验等功能实现复杂逻辑。\";"],"names":[],"sourceRoot":""}