"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[97036],{97036:function(r,n,e){e.r(n),n["default"]='## **线程并发与同步**\r\n\r\n### **1. 多线程的基本概念**\r\n\r\n- **线程**：线程是操作系统能够调度的最小单元。一个进程可以包含多个线程，这些线程共享进程的内存空间。\r\n- **多线程**：在一个进程中创建多个线程，每个线程执行不同的任务，从而实现并发。\r\n\r\nPython 的 `threading` 模块提供了对线程的支持，但由于 GIL（全局解释器锁）的存在，Python 的多线程在 CPU 密集型任务中并不能真正实现并行计算，但在 I/O 密集型任务中表现良好。\r\n\r\n### **2. `threading` 模块的核心内容**\r\n\r\n#### （1）创建线程\r\n\r\n可以通过以下两种方式创建线程：\r\n\r\n- **继承 `Thread` 类**：自定义一个类继承 `threading.Thread`，重写其 `run()` 方法。\r\n- **使用 `Thread` 构造函数**：直接将目标函数传递给 `Thread` 构造函数。\r\n\r\n- 示例 1：继承 `Thread` 类\r\n\r\n```python\r\nimport threading\r\nimport time\r\n\r\nclass MyThread(threading.Thread):\r\n    def __init__(self, name, delay):\r\n        super().__init__()\r\n        self.name = name\r\n        self.delay = delay\r\n\r\n    def run(self):\r\n        print(f"Thread {self.name} started.")\r\n        for i in range(5):\r\n            time.sleep(self.delay)\r\n            print(f"{self.name}: {i}")\r\n        print(f"Thread {self.name} finished.")\r\n\r\n# 创建线程实例\r\nthread1 = MyThread("Thread-1", 1)\r\nthread2 = MyThread("Thread-2", 2)\r\n\r\n# 启动线程\r\nthread1.start()\r\nthread2.start()\r\n\r\n# 等待线程完成\r\nthread1.join()\r\nthread2.join()\r\n\r\nprint("All threads finished.")\r\n```\r\n\r\n- 示例 2：使用 `Thread` 构造函数\r\n\r\n```python\r\nimport threading\r\nimport time\r\n\r\ndef worker(name, delay):\r\n    print(f"Thread {name} started.")\r\n    for i in range(5):\r\n        time.sleep(delay)\r\n        print(f"{name}: {i}")\r\n    print(f"Thread {name} finished.")\r\n\r\n# 创建线程\r\nthread1 = threading.Thread(target=worker, args=("Thread-1", 1))\r\nthread2 = threading.Thread(target=worker, args=("Thread-2", 2))\r\n\r\n# 启动线程\r\nthread1.start()\r\nthread2.start()\r\n\r\n# 等待线程完成\r\nthread1.join()\r\nthread2.join()\r\n\r\nprint("All threads finished.")\r\n```\r\n\r\n---\r\n\r\n#### （2）线程管理方法\r\n\r\n`threading.Thread` 提供了一些常用的方法来管理线程：\r\n\r\n- `start()`：启动线程，调用线程的 `run()` 方法。\r\n- `join([timeout])`：阻塞主线程，直到子线程完成（或超时）。\r\n- `is_alive()`：检查线程是否还在运行。\r\n- `getName()` 和 `setName(name)`：获取或设置线程名称。\r\n\r\n- 示例：线程状态检查\r\n\r\n```python\r\nimport threading\r\nimport time\r\n\r\ndef worker():\r\n    print(f"Thread {threading.current_thread().name} is running.")\r\n    time.sleep(2)\r\n    print(f"Thread {threading.current_thread().name} is done.")\r\n\r\nthread = threading.Thread(target=worker, name="MyWorkerThread")\r\nthread.start()\r\n\r\nprint(f"Is thread alive? {thread.is_alive()}")\r\nthread.join()\r\nprint(f"Is thread alive? {thread.is_alive()}")\r\n```\r\n\r\n---\r\n\r\n#### （3）线程同步\r\n\r\n当多个线程访问共享资源时，可能会出现竞争条件（Race Condition）。为了解决这个问题，可以使用以下同步机制：\r\n\r\n- **Lock**：互斥锁，确保同一时间只有一个线程访问共享资源。\r\n- **RLock**：可重入锁，允许同一个线程多次获取锁。\r\n\r\n- **Condition**：条件变量，用于线程间的通信。\r\n\r\n    ```python\r\n    import threading\r\n\r\n    # 创建一个条件变量\r\n    condition = threading.Condition()\r\n\r\n    # 共享资源\r\n    shared_resource = False\r\n\r\n    def consumer():\r\n        global shared_resource\r\n        with condition:  # 获取条件变量的锁\r\n            print("Consumer is waiting...")\r\n            while not shared_resource:  # 等待条件满足\r\n                condition.wait()  # 类似于 Java 的 wait()\r\n            print("Consumer found the resource ready!")\r\n\r\n    def producer():\r\n        global shared_resource\r\n        with condition:  # 获取条件变量的锁\r\n            print("Producer is preparing the resource...")\r\n            shared_resource = True\r\n            condition.notify()  # 唤醒等待的线程，类似于 Java 的 notify()\r\n\r\n    # 创建线程\r\n    t1 = threading.Thread(target=consumer)\r\n    t2 = threading.Thread(target=producer)\r\n\r\n    # 启动线程\r\n    t1.start()\r\n    t2.start()\r\n\r\n    # 等待线程完成\r\n    t1.join()\r\n    t2.join()\r\n    ```\r\n\r\n- **Semaphore**：信号量，控制同时访问资源的线程数量。\r\n\r\n- 示例：使用 Lock\r\n\r\n```python\r\nimport threading\r\n\r\n# 共享资源\r\ncounter = 0\r\nlock = threading.Lock()\r\n\r\ndef increment():\r\n    global counter\r\n    for _ in range(100000):\r\n        with lock:  # 加锁\r\n            counter += 1\r\n\r\n# 创建线程\r\nthread1 = threading.Thread(target=increment)\r\nthread2 = threading.Thread(target=increment)\r\n\r\n# 启动线程\r\nthread1.start()\r\nthread2.start()\r\n\r\n# 等待线程完成\r\nthread1.join()\r\nthread2.join()\r\n\r\nprint(f"Final counter value: {counter}")\r\n```\r\n\r\n---\r\n\r\n#### （4）守护线程（Daemon Thread）\r\n\r\n守护线程是一种后台线程，当主线程结束时，守护线程会自动退出。可以通过设置 `daemon=True` 来创建守护线程。\r\n\r\n- 示例：守护线程\r\n\r\n```python\r\nimport threading\r\nimport time\r\n\r\ndef daemon_worker():\r\n    while True:\r\n        print("Daemon thread is running...")\r\n        time.sleep(1)\r\n\r\n# 创建守护线程\r\ndaemon_thread = threading.Thread(target=daemon_worker, daemon=True)\r\ndaemon_thread.start()\r\n\r\nprint("Main thread is running...")\r\ntime.sleep(3)\r\nprint("Main thread finished.")\r\n```\r\n\r\n输出：\r\n\r\n```\r\nMain thread is running...\r\nDaemon thread is running...\r\nDaemon thread is running...\r\nDaemon thread is running...\r\nMain thread finished.\r\n```\r\n\r\n注意：守护线程会在主线程结束后自动终止。\r\n\r\n---\r\n\r\n### **3. 多线程的适用场景**\r\n\r\n- **I/O 密集型任务**：如文件读写、网络请求等。由于线程在等待 I/O 操作时会释放 GIL，因此多线程在这种场景下非常有效。\r\n- **GUI 应用程序**：保持界面响应的同时执行后台任务。\r\n- **轻量级任务**：如简单的并发任务。\r\n\r\n---\r\n\r\n### **4. 注意事项**\r\n\r\n1. **GIL 的限制**：\r\n   - Python 的 GIL 使得多线程在 CPU 密集型任务中无法真正并行。如果需要并行计算，可以考虑使用 `multiprocessing` 模块。\r\n\r\n2. **线程安全**：\r\n   - 在多线程环境中，访问共享资源时必须加锁，否则可能会导致数据不一致。\r\n\r\n3. **调试复杂性**：\r\n   - 多线程程序的调试比单线程程序更复杂，容易出现死锁、竞争条件等问题。\r\n\r\n---'}}]);
//# sourceMappingURL=97036.38931231.js.map