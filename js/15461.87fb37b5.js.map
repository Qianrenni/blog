{"version":3,"file":"js/15461.87fb37b5.js","mappings":"qHAAA,wpN","sources":["webpack://myblog/./src/assets/md/algorithm/content/005-3 高级数据结构.md"],"sourcesContent":["export default \"## **3. 高级数据结构**\\r\\n\\r\\n### **栈（Stack）**\\r\\n\\r\\n- **定义**：后进先出（LIFO）的线性数据结构，仅允许在栈顶进行插入（push）和删除（pop）操作。\\r\\n- **核心操作**：\\r\\n  - `push(x)`：将元素 `x` 压入栈顶。\\r\\n  - `pop()`：弹出栈顶元素。\\r\\n  - `peek()`：查看栈顶元素但不弹出。\\r\\n  - `isEmpty()`：判断栈是否为空。\\r\\n- **时间复杂度**：所有操作均为 \\\\(O(1)\\\\)。\\r\\n- **应用场景**：\\r\\n  - 函数调用栈（递归/非递归）。\\r\\n  - 括号匹配、表达式求值（中缀转后缀）。\\r\\n  - 浏览器前进后退、撤销操作（双栈实现）。\\r\\n\\r\\n### **队列（Queue）**\\r\\n\\r\\n- **定义**：先进先出（FIFO）的线性数据结构，支持在队尾插入（enqueue）和队首删除（dequeue）。\\r\\n- **核心操作**：\\r\\n  - `enqueue(x)`：将元素 `x` 加入队尾。\\r\\n  - `dequeue()`：移除队首元素。\\r\\n  - `front()`：获取队首元素。\\r\\n  - `isEmpty()`：判断队列是否为空。\\r\\n- **变种**：\\r\\n  - **双端队列（Deque）**：两端均可插入和删除。\\r\\n  - **优先队列（Priority Queue）**：按优先级出队（通常用堆实现）。\\r\\n- **时间复杂度**：普通队列操作均为 \\\\(O(1)\\\\)；优先队列的插入/删除为 \\\\(O(\\\\log n)\\\\)。\\r\\n- **应用场景**：\\r\\n  - BFS（广度优先搜索）。\\r\\n  - 任务调度、消息队列。\\r\\n\\r\\n### **堆（Heap）**\\r\\n\\r\\n- **定义**：完全二叉树，满足堆性质（父节点值 ≥ 或 ≤ 子节点值）。\\r\\n- **类型**：\\r\\n  - **大顶堆**：父节点 ≥ 子节点，根节点为最大值。\\r\\n  - **小顶堆**：父节点 ≤ 子节点，根节点为最小值。\\r\\n- **核心操作**：\\r\\n  - `insert(x)`：插入元素并调整堆结构。\\r\\n  - `extractMax()/extractMin()`：取出堆顶元素并调整堆。\\r\\n  - `heapify()`：将无序数组构建为堆。\\r\\n- **时间复杂度**：\\r\\n  - 插入/删除：\\\\(O(\\\\log n)\\\\)。\\r\\n  - 建堆：\\\\(O(n)\\\\)。\\r\\n- **应用场景**：\\r\\n  - 优先队列、Top K 问题。\\r\\n  - 堆排序（时间复杂度 \\\\(O(n \\\\log n)\\\\)）。\\r\\n\\r\\n### **二叉搜索树（Binary Search Tree, BST）**\\r\\n\\r\\n- **定义**：二叉树，满足：\\r\\n  - 左子树所有节点值 < 根节点值。\\r\\n  - 右子树所有节点值 > 根节点值。\\r\\n  - 左右子树也分别为 BST。\\r\\n- **核心操作**：\\r\\n  - `search(x)`：查找值为 `x` 的节点。\\r\\n  - `insert(x)`：插入新节点。\\r\\n  - `delete(x)`：删除节点（需处理子节点合并）。\\r\\n- **时间复杂度**：\\r\\n  - 平均：$O(log n)$（平衡时）。\\r\\n  - 最坏：$O(n)$（退化为链表）。\\r\\n- **缺点**：不平衡时性能退化，需通过平衡二叉树（如 AVL、红黑树）优化。\\r\\n\\r\\n### **红黑树（Red-Black Tree）**\\r\\n\\r\\n- **定义**：自平衡二叉搜索树，通过颜色和规则保持平衡：\\r\\n  1. 节点为红或黑。\\r\\n  2. 根节点和叶子节点（NIL）为黑。\\r\\n  3. 红节点的子节点必须为黑。\\r\\n  4. 从任一节点到叶子节点的路径包含相同数量的黑节点。\\r\\n- **平衡操作**：旋转（左旋/右旋）和颜色调整。\\r\\n- **时间复杂度**：插入、删除、查找均为 $O(\\\\log n)$。\\r\\n- **应用场景**：\\r\\n  - C++ STL `map`/`set`、Java `TreeMap`/`TreeSet`。\\r\\n  - 数据库索引（如 B 树变种）。\\r\\n\\r\\n### **树状数组（Fenwick Tree）**\\r\\n\\r\\n- **定义**：用于高效维护前缀和的动态数据结构，基于二进制低位技术（Lowbit）。\\r\\n- **核心操作**：\\r\\n  - `update(i, delta)`：将第 `i` 个元素的值增加 `delta`。\\r\\n  - `query(i)`：查询前 `i` 个元素的前缀和。\\r\\n- **时间复杂度**：\\r\\n  - 更新和查询均为 $O(\\\\log n)$。\\r\\n- **优势**：代码简洁，空间占用小$O(n)$。\\r\\n- **应用场景**：\\r\\n  - 动态前缀和、逆序对统计。\\r\\n  - 替代线段树处理单点更新+区间查询问题。\\r\\n\\r\\n```python\\r\\n\\r\\nclass BinaryIndexedTree:\\r\\n    def __init__(self, nums):\\r\\n        \\\"\\\"\\\"\\r\\n        初始化树状数组\\r\\n        :param nums: 原始数组\\r\\n        \\\"\\\"\\\"\\r\\n        self.n = len(nums)\\r\\n        self.tree = [0] * (self.n + 1)  # 树状数组从索引1开始\\r\\n        for i in range(self.n):\\r\\n            self.update(i, nums[i])\\r\\n\\r\\n    def lowbit(self, x):\\r\\n        \\\"\\\"\\\"\\r\\n        计算x的lowbit，即x二进制表示中最低位1所对应的值\\r\\n        :param x: 输入值\\r\\n        :return: lowbit(x)\\r\\n        \\\"\\\"\\\"\\r\\n        return x & (-x)\\r\\n\\r\\n    def update(self, index, delta):\\r\\n        \\\"\\\"\\\"\\r\\n        更新数组中index位置的值，增加delta\\r\\n        :param index: 需要更新的位置（原数组中的索引）\\r\\n        :param delta: 增加的值\\r\\n        \\\"\\\"\\\"\\r\\n        # 转换为树状数组中的索引\\r\\n        i = index + 1\\r\\n        while i <= self.n:\\r\\n            self.tree[i] += delta\\r\\n            i += self.lowbit(i)\\r\\n\\r\\n    def query(self, index):\\r\\n        \\\"\\\"\\\"\\r\\n        查询数组中前index个元素的前缀和\\r\\n        :param index: 查询前缀和的索引（原数组中的索引）\\r\\n        :return: 前index个元素的前缀和\\r\\n        \\\"\\\"\\\"\\r\\n        res = 0\\r\\n        i = index + 1\\r\\n        while i > 0:\\r\\n            res += self.tree[i]\\r\\n            i -= self.lowbit(i)\\r\\n        return res\\r\\n\\r\\n    def get_value(self, index):\\r\\n        \\\"\\\"\\\"\\r\\n        获取数组中index位置的值\\r\\n        :param index: 查询位置的索引\\r\\n        :return: index位置的值\\r\\n        \\\"\\\"\\\"\\r\\n        if index < 0 or index >= self.n:\\r\\n            return 0\\r\\n        return self.query(index) - self.query(index - 1)\\r\\n\\r\\n    def set_value(self, index, value):\\r\\n        \\\"\\\"\\\"\\r\\n        设置数组中index位置的值为value\\r\\n        :param index: 设置位置的索引\\r\\n        :param value: 新的值\\r\\n        \\\"\\\"\\\"\\r\\n        current_value = self.get_value(index)\\r\\n        self.update(index, value - current_value)\\r\\n```\\r\\n\\r\\n### **线段树（Segment Tree）**\\r\\n\\r\\n- **定义**：二叉树结构，用于高效处理区间查询（如区间和、最大值）和区间更新。\\r\\n- **核心操作**：\\r\\n  - `build()`：构建线段树。\\r\\n  - `query(l, r)`：查询区间 `[l, r]` 的聚合值。\\r\\n  - `update(i, x)`：单点更新。\\r\\n  - `rangeUpdate(l, r, delta)`：区间更新（需懒惰标记优化）。\\r\\n- **时间复杂度**：\\r\\n  - 构建：$O(n)$。\\r\\n  - 查询/更新：$O(\\\\log n)$。\\r\\n- **变种**：\\r\\n  - **懒惰传播（Lazy Propagation）**：优化区间更新。\\r\\n  - **动态开点**：处理稀疏区间。\\r\\n- **应用场景**：\\r\\n  - 区间最值、区间和、区间覆盖问题。\\r\\n  - 二维线段树（处理矩阵问题）。\\r\\n\\r\\n```python\\r\\nimport sys\\r\\n\\r\\nclass SegmentTree:\\r\\n    \\\"\\\"\\\"\\r\\n    线段树\\r\\n    \\\"\\\"\\\"\\r\\n    def __init__(self, n, nums: list[int]):\\r\\n        if len(nums) != n:\\r\\n            raise ValueError(\\\"Length of nums must be equal to n.\\\")\\r\\n        self.n = n\\r\\n        self.tree = [0] * (4 * n)\\r\\n        self.lazy = [0] * (4 * n)\\r\\n        self.build(1, 0, n - 1, nums)\\r\\n\\r\\n    def build(self, node, start, end, nums):\\r\\n        if start == end:\\r\\n            self.tree[node] = nums[start]\\r\\n            return\\r\\n        mid = start + ((end - start) >> 1)\\r\\n        self.build(2 * node, start, mid, nums)\\r\\n        self.build(2 * node + 1, mid + 1, end, nums)\\r\\n        self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1]\\r\\n\\r\\n    def push_down(self, node, start, end):\\r\\n        if self.lazy[node] and start != end:\\r\\n            mid = start + ((end - start) >> 1)\\r\\n            self.tree[2 * node] += self.lazy[node] * (mid - start + 1)\\r\\n            self.tree[2 * node + 1] += self.lazy[node] * (end - mid)\\r\\n            self.lazy[2 * node] += self.lazy[node]\\r\\n            self.lazy[2 * node + 1] += self.lazy[node]\\r\\n            self.lazy[node] = 0\\r\\n\\r\\n    def update(self, node, start, end, left, right, value):\\r\\n        if left <= start and end <= right:\\r\\n            self.lazy[node] += value\\r\\n            self.tree[node] += value * (end - start + 1)\\r\\n            return\\r\\n        middle = start + ((end - start) >> 1)\\r\\n        self.push_down(node, start, end)\\r\\n        if max(left, start) <= min(right, middle):\\r\\n            self.update(2 * node, start, middle, left, right, value)\\r\\n        if max(left, middle + 1) <= min(right, end):\\r\\n            self.update(2 * node + 1, middle + 1, end, left, right, value)\\r\\n        self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1]\\r\\n\\r\\n    def get(self, node, start, end, left, right):\\r\\n        if left <= start and end <= right:\\r\\n            return self.tree[node]\\r\\n        middle = start + ((end - start) >> 1)\\r\\n        self.push_down(node, start, end)\\r\\n        value = 0\\r\\n        if max(left, start) <= min(right, middle):\\r\\n            value += self.get(2 * node, start, middle, left, right)\\r\\n        if max(left, middle + 1) <= min(right, end):\\r\\n            value += self.get(2 * node + 1, middle + 1, end, left, right)\\r\\n        return value\\r\\n```\\r\\n\\r\\n---\";"],"names":[],"sourceRoot":""}