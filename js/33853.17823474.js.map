{"version":3,"file":"js/33853.17823474.js","mappings":"qHAAA,kyX","sources":["webpack://myblog/./src/assets/md/software/content/006-6 行为型模式详解.md"],"sourcesContent":["export default \"# **6. 行为型模式详解**\\r\\n\\r\\n## **6.1 策略模式**\\r\\n\\r\\n### **定义与特点**\\r\\n\\r\\n策略模式定义了一系列算法，并将每个算法封装起来，使它们可以互换。策略模式让算法的变化独立于使用算法的客户端。\\r\\n\\r\\n### **定义一系列算法并使其可互换**\\r\\n\\r\\n- 将算法抽象为接口或基类。\\r\\n- 客户端根据需求选择具体的算法实现。\\r\\n\\r\\n### **示例：支付策略**\\r\\n\\r\\n```python\\r\\nfrom abc import ABC, abstractmethod\\r\\n\\r\\n# 抽象策略\\r\\nclass PaymentStrategy(ABC):\\r\\n    @abstractmethod\\r\\n    def pay(self, amount):\\r\\n        pass\\r\\n\\r\\n# 具体策略A\\r\\nclass CreditCardPayment(PaymentStrategy):\\r\\n    def pay(self, amount):\\r\\n        return f\\\"Paid {amount} using Credit Card.\\\"\\r\\n\\r\\n# 具体策略B\\r\\nclass PayPalPayment(PaymentStrategy):\\r\\n    def pay(self, amount):\\r\\n        return f\\\"Paid {amount} using PayPal.\\\"\\r\\n\\r\\n# 上下文\\r\\nclass ShoppingCart:\\r\\n    def __init__(self, payment_strategy):\\r\\n        self.payment_strategy = payment_strategy\\r\\n\\r\\n    def checkout(self, amount):\\r\\n        return self.payment_strategy.pay(amount)\\r\\n\\r\\n# 使用示例\\r\\ncredit_card = CreditCardPayment()\\r\\npaypal = PayPalPayment()\\r\\n\\r\\ncart = ShoppingCart(credit_card)\\r\\nprint(cart.checkout(100))  # 输出: Paid 100 using Credit Card.\\r\\n\\r\\ncart = ShoppingCart(paypal)\\r\\nprint(cart.checkout(200))  # 输出: Paid 200 using PayPal.\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **6.2 模板方法模式**\\r\\n\\r\\n### **定义与特点**\\r\\n\\r\\n模板方法模式定义了一个算法的骨架，并允许子类在不改变算法结构的情况下重新定义算法的某些步骤。\\r\\n\\r\\n### **定义算法骨架，允许子类扩展具体步骤**\\r\\n\\r\\n- 基类定义模板方法和通用步骤。\\r\\n- 子类实现具体步骤。\\r\\n\\r\\n### **示例：游戏框架**\\r\\n\\r\\n```python\\r\\nfrom abc import ABC, abstractmethod\\r\\n\\r\\n# 抽象类\\r\\nclass Game(ABC):\\r\\n    def play(self):\\r\\n        self.initialize()\\r\\n        self.start()\\r\\n        self.end()\\r\\n\\r\\n    @abstractmethod\\r\\n    def initialize(self):\\r\\n        pass\\r\\n\\r\\n    @abstractmethod\\r\\n    def start(self):\\r\\n        pass\\r\\n\\r\\n    @abstractmethod\\r\\n    def end(self):\\r\\n        pass\\r\\n\\r\\n# 具体类\\r\\nclass ChessGame(Game):\\r\\n    def initialize(self):\\r\\n        print(\\\"Initializing Chess Game.\\\")\\r\\n\\r\\n    def start(self):\\r\\n        print(\\\"Starting Chess Game.\\\")\\r\\n\\r\\n    def end(self):\\r\\n        print(\\\"Ending Chess Game.\\\")\\r\\n\\r\\n# 使用示例\\r\\ngame = ChessGame()\\r\\ngame.play()\\r\\n# 输出:\\r\\n# Initializing Chess Game.\\r\\n# Starting Chess Game.\\r\\n# Ending Chess Game.\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **6.3 观察者模式**\\r\\n\\r\\n### **定义与特点**\\r\\n\\r\\n观察者模式定义了一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会收到通知并自动更新。\\r\\n\\r\\n### **发布-订阅机制**\\r\\n\\r\\n- 主题（Subject）维护观察者列表。\\r\\n- 观察者（Observer）实现更新接口。\\r\\n\\r\\n### **示例：事件监听器**\\r\\n\\r\\n```python\\r\\nclass Subject:\\r\\n    def __init__(self):\\r\\n        self._observers = []\\r\\n\\r\\n    def attach(self, observer):\\r\\n        self._observers.append(observer)\\r\\n\\r\\n    def notify(self, message):\\r\\n        for observer in self._observers:\\r\\n            observer.update(message)\\r\\n\\r\\nclass Observer:\\r\\n    def update(self, message):\\r\\n        pass\\r\\n\\r\\nclass ConcreteObserver(Observer):\\r\\n    def __init__(self, name):\\r\\n        self.name = name\\r\\n\\r\\n    def update(self, message):\\r\\n        print(f\\\"{self.name} received message: {message}\\\")\\r\\n\\r\\n# 使用示例\\r\\nsubject = Subject()\\r\\nobserver1 = ConcreteObserver(\\\"Observer1\\\")\\r\\nobserver2 = ConcreteObserver(\\\"Observer2\\\")\\r\\n\\r\\nsubject.attach(observer1)\\r\\nsubject.attach(observer2)\\r\\n\\r\\nsubject.notify(\\\"Hello Observers!\\\")\\r\\n# 输出:\\r\\n# Observer1 received message: Hello Observers!\\r\\n# Observer2 received message: Hello Observers!\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **6.4 状态模式**\\r\\n\\r\\n### **定义与特点**\\r\\n\\r\\n状态模式允许对象在内部状态改变时改变其行为，看起来像是改变了类。\\r\\n\\r\\n### **对象行为随状态变化而改变**\\r\\n\\r\\n- 每个状态封装为一个类。\\r\\n- 上下文持有当前状态。\\r\\n\\r\\n### **示例：订单状态管理**\\r\\n\\r\\n```python\\r\\nfrom abc import ABC, abstractmethod\\r\\n\\r\\n# 抽象状态\\r\\nclass OrderState(ABC):\\r\\n    @abstractmethod\\r\\n    def handle(self, order):\\r\\n        pass\\r\\n\\r\\n# 具体状态A\\r\\nclass NewOrderState(OrderState):\\r\\n    def handle(self, order):\\r\\n        print(\\\"Handling new order.\\\")\\r\\n        order.state = ProcessingOrderState()\\r\\n\\r\\n# 具体状态B\\r\\nclass ProcessingOrderState(OrderState):\\r\\n    def handle(self, order):\\r\\n        print(\\\"Processing order.\\\")\\r\\n        order.state = ShippedOrderState()\\r\\n\\r\\n# 具体状态C\\r\\nclass ShippedOrderState(OrderState):\\r\\n    def handle(self, order):\\r\\n        print(\\\"Order shipped.\\\")\\r\\n\\r\\n# 上下文\\r\\nclass Order:\\r\\n    def __init__(self):\\r\\n        self.state = NewOrderState()\\r\\n\\r\\n    def next_state(self):\\r\\n        self.state.handle(self)\\r\\n\\r\\n# 使用示例\\r\\norder = Order()\\r\\norder.next_state()  # 输出: Handling new order.\\r\\norder.next_state()  # 输出: Processing order.\\r\\norder.next_state()  # 输出: Order shipped.\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **6.5 责任链模式**\\r\\n\\r\\n### **定义与特点**\\r\\n\\r\\n责任链模式将请求沿着一条链传递，直到有一个处理者处理它。\\r\\n\\r\\n### **请求在链中传递**\\r\\n\\r\\n- 每个处理者决定是否处理请求或将其传递给下一个处理者。\\r\\n\\r\\n### **示例：日志处理链**\\r\\n\\r\\n```python\\r\\nclass Logger:\\r\\n    def __init__(self, level, next_logger=None):\\r\\n        self.level = level\\r\\n        self.next_logger = next_logger\\r\\n\\r\\n    def log_message(self, level, message):\\r\\n        if self.level <= level:\\r\\n            self.write(message)\\r\\n        if self.next_logger:\\r\\n            self.next_logger.log_message(level, message)\\r\\n\\r\\n    def write(self, message):\\r\\n        pass\\r\\n\\r\\nclass ConsoleLogger(Logger):\\r\\n    def write(self, message):\\r\\n        print(f\\\"Console Logger: {message}\\\")\\r\\n\\r\\nclass FileLogger(Logger):\\r\\n    def write(self, message):\\r\\n        print(f\\\"File Logger: {message}\\\")\\r\\n\\r\\nclass ErrorLogger(Logger):\\r\\n    def write(self, message):\\r\\n        print(f\\\"Error Logger: {message}\\\")\\r\\n\\r\\n# 使用示例\\r\\nerror_logger = ErrorLogger(1)\\r\\nfile_logger = FileLogger(2, error_logger)\\r\\nconsole_logger = ConsoleLogger(3, file_logger)\\r\\n\\r\\nconsole_logger.log_message(1, \\\"This is an error.\\\")  # 输出: Error Logger: This is an error.\\r\\nconsole_logger.log_message(2, \\\"This is a file log.\\\")  # 输出: File Logger: This is a file log.\\r\\nconsole_logger.log_message(3, \\\"This is a console log.\\\")  # 输出: Console Logger: This is a console log.\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **6.6 命令模式**\\r\\n\\r\\n### **定义与特点**\\r\\n\\r\\n命令模式将请求封装为对象，从而使你可以用不同的请求对客户进行参数化。\\r\\n\\r\\n### **将请求封装为对象**\\r\\n\\r\\n- 命令对象包含执行操作的方法。\\r\\n- 调用者通过命令对象间接调用接收者。\\r\\n\\r\\n### **示例：遥控器控制家电**\\r\\n\\r\\n```python\\r\\nfrom abc import ABC, abstractmethod\\r\\n\\r\\n# 命令接口\\r\\nclass Command(ABC):\\r\\n    @abstractmethod\\r\\n    def execute(self):\\r\\n        pass\\r\\n\\r\\n# 具体命令A\\r\\nclass LightOnCommand(Command):\\r\\n    def __init__(self, light):\\r\\n        self.light = light\\r\\n\\r\\n    def execute(self):\\r\\n        self.light.turn_on()\\r\\n\\r\\n# 接收者\\r\\nclass Light:\\r\\n    def turn_on(self):\\r\\n        print(\\\"Light is on.\\\")\\r\\n\\r\\n# 遥控器\\r\\nclass RemoteControl:\\r\\n    def __init__(self):\\r\\n        self.command = None\\r\\n\\r\\n    def set_command(self, command):\\r\\n        self.command = command\\r\\n\\r\\n    def press_button(self):\\r\\n        self.command.execute()\\r\\n\\r\\n# 使用示例\\r\\nlight = Light()\\r\\nlight_on = LightOnCommand(light)\\r\\n\\r\\nremote = RemoteControl()\\r\\nremote.set_command(light_on)\\r\\nremote.press_button()  # 输出: Light is on.\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **6.7 迭代器模式**\\r\\n\\r\\n### **定义与特点**\\r\\n\\r\\n迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而不需要暴露其底层表示。\\r\\n\\r\\n### **提供统一访问集合元素的方式**\\r\\n\\r\\n- 迭代器封装了遍历逻辑。\\r\\n\\r\\n### **示例：遍历集合**\\r\\n\\r\\n```python\\r\\nclass Iterator:\\r\\n    def has_next(self):\\r\\n        pass\\r\\n\\r\\n    def next(self):\\r\\n        pass\\r\\n\\r\\nclass ConcreteIterator(Iterator):\\r\\n    def __init__(self, collection):\\r\\n        self.collection = collection\\r\\n        self.index = 0\\r\\n\\r\\n    def has_next(self):\\r\\n        return self.index < len(self.collection)\\r\\n\\r\\n    def next(self):\\r\\n        if self.has_next():\\r\\n            item = self.collection[self.index]\\r\\n            self.index += 1\\r\\n            return item\\r\\n\\r\\nclass Collection:\\r\\n    def __init__(self):\\r\\n        self.items = []\\r\\n\\r\\n    def add_item(self, item):\\r\\n        self.items.append(item)\\r\\n\\r\\n    def create_iterator(self):\\r\\n        return ConcreteIterator(self.items)\\r\\n\\r\\n# 使用示例\\r\\ncollection = Collection()\\r\\ncollection.add_item(\\\"Item1\\\")\\r\\ncollection.add_item(\\\"Item2\\\")\\r\\n\\r\\niterator = collection.create_iterator()\\r\\nwhile iterator.has_next():\\r\\n    print(iterator.next())\\r\\n# 输出:\\r\\n# Item1\\r\\n# Item2\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **6.8 中介者模式**\\r\\n\\r\\n### **定义与特点**\\r\\n\\r\\n中介者模式通过一个中介对象来封装一系列对象的交互，减少对象之间的直接依赖。\\r\\n\\r\\n### **减少对象间的直接交互**\\r\\n\\r\\n- 中介者协调多个对象的行为。\\r\\n\\r\\n### **示例：聊天室**\\r\\n\\r\\n```python\\r\\nclass ChatRoom:\\r\\n    def show_message(self, user, message):\\r\\n        print(f\\\"[{user.name}]: {message}\\\")\\r\\n\\r\\nclass User:\\r\\n    def __init__(self, name, chat_room):\\r\\n        self.name = name\\r\\n        self.chat_room = chat_room\\r\\n\\r\\n    def send_message(self, message):\\r\\n        self.chat_room.show_message(self, message)\\r\\n\\r\\n# 使用示例\\r\\nchat_room = ChatRoom()\\r\\nuser1 = User(\\\"Alice\\\", chat_room)\\r\\nuser2 = User(\\\"Bob\\\", chat_room)\\r\\n\\r\\nuser1.send_message(\\\"Hi Bob!\\\")  # 输出: [Alice]: Hi Bob!\\r\\nuser2.send_message(\\\"Hello Alice!\\\")  # 输出: [Bob]: Hello Alice!\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **6.9 备忘录模式**\\r\\n\\r\\n### **定义与特点**\\r\\n\\r\\n备忘录模式捕获并外部化对象的内部状态，以便以后恢复到该状态。\\r\\n\\r\\n### **捕获对象状态以便恢复**\\r\\n\\r\\n- 备忘录存储对象的状态。\\r\\n- 发起人创建和恢复状态。\\r\\n\\r\\n### **示例：撤销操作**\\r\\n\\r\\n```python\\r\\nclass Memento:\\r\\n    def __init__(self, state):\\r\\n        self.state = state\\r\\n\\r\\nclass Originator:\\r\\n    def __init__(self):\\r\\n        self.state = None\\r\\n\\r\\n    def set_state(self, state):\\r\\n        self.state = state\\r\\n\\r\\n    def save_to_memento(self):\\r\\n        return Memento(self.state)\\r\\n\\r\\n    def restore_from_memento(self, memento):\\r\\n        self.state = memento.state\\r\\n\\r\\nclass Caretaker:\\r\\n    def __init__(self):\\r\\n        self.mementos = []\\r\\n\\r\\n    def add_memento(self, memento):\\r\\n        self.mementos.append(memento)\\r\\n\\r\\n    def get_memento(self, index):\\r\\n        return self.mementos[index]\\r\\n\\r\\n# 使用示例\\r\\noriginator = Originator()\\r\\ncaretaker = Caretaker()\\r\\n\\r\\noriginator.set_state(\\\"State1\\\")\\r\\ncaretaker.add_memento(originator.save_to_memento())\\r\\n\\r\\noriginator.set_state(\\\"State2\\\")\\r\\ncaretaker.add_memento(originator.save_to_memento())\\r\\n\\r\\noriginator.restore_from_memento(caretaker.get_memento(0))\\r\\nprint(originator.state)  # 输出: State1\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **6.10 解释器模式**\\r\\n\\r\\n### **定义与特点**\\r\\n\\r\\n解释器模式定义了语言的文法表示，并定义一个解释器来处理这些文法。\\r\\n\\r\\n### **解析语言或表达式**\\r\\n\\r\\n- 解释器解析表达式并计算结果。\\r\\n\\r\\n### **示例：简单的数学表达式解析**\\r\\n\\r\\n```python\\r\\nclass Expression:\\r\\n    def interpret(self, context):\\r\\n        pass\\r\\n\\r\\nclass Number(Expression):\\r\\n    def __init__(self, value):\\r\\n        self.value = value\\r\\n\\r\\n    def interpret(self, context):\\r\\n        return self.value\\r\\n\\r\\nclass Add(Expression):\\r\\n    def __init__(self, left, right):\\r\\n        self.left = left\\r\\n        self.right = right\\r\\n\\r\\n    def interpret(self, context):\\r\\n        return self.left.interpret(context) + self.right.interpret(context)\\r\\n\\r\\n# 使用示例\\r\\ncontext = {}\\r\\nexpression = Add(Number(5), Number(3))\\r\\nresult = expression.interpret(context)\\r\\nprint(result)  # 输出: 8\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **6.11 访问者模式**\\r\\n\\r\\n### **定义与特点**\\r\\n\\r\\n访问者模式允许你在不修改类的情况下向已有类添加新的功能。\\r\\n\\r\\n### **在不修改类的情况下添加新操作**\\r\\n\\r\\n- 访问者封装了新的操作。\\r\\n- 元素接受访问者并调用其方法。\\r\\n\\r\\n### **示例：文档处理**\\r\\n\\r\\n```python\\r\\nfrom abc import ABC, abstractmethod\\r\\n\\r\\n# 元素接口\\r\\nclass Element(ABC):\\r\\n    @abstractmethod\\r\\n    def accept(self, visitor):\\r\\n        pass\\r\\n\\r\\n# 具体元素\\r\\nclass Text(Element):\\r\\n    def accept(self, visitor):\\r\\n        visitor.visit_text(self)\\r\\n\\r\\nclass Image(Element):\\r\\n    def accept(self, visitor):\\r\\n        visitor.visit_image(self)\\r\\n\\r\\n# 访问者接口\\r\\nclass Visitor(ABC):\\r\\n    @abstractmethod\\r\\n    def visit_text(self, text):\\r\\n        pass\\r\\n\\r\\n    @abstractmethod\\r\\n    def visit_image(self, image):\\r\\n        pass\\r\\n\\r\\n# 具体访问者\\r\\nclass DocumentProcessor(Visitor):\\r\\n    def visit_text(self, text):\\r\\n        print(\\\"Processing text.\\\")\\r\\n\\r\\n    def visit_image(self, image):\\r\\n        print(\\\"Processing image.\\\")\\r\\n\\r\\n# 使用示例\\r\\nelements = [Text(), Image()]\\r\\nvisitor = DocumentProcessor()\\r\\n\\r\\nfor element in elements:\\r\\n    element.accept(visitor)\\r\\n# 输出:\\r\\n# Processing text.\\r\\n# Processing image.\\r\\n```\\r\\n\\r\\n---\";"],"names":[],"sourceRoot":""}