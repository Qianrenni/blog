"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[45e3],{45e3:function(n,r,e){e.r(r),r["default"]='## **3. 新特性**\r\n\r\n### **3.1 默认参数**\r\n\r\n- **用途**：为函数参数指定默认值，避免未传递参数时出现 `undefined`。\r\n- **语法**：\r\n\r\n  ```javascript\r\n  function greet(name = "Guest") {\r\n      console.log(`Hello, ${name}!`);\r\n  }\r\n\r\n  greet();        // 输出：Hello, Guest!\r\n  greet("Alice"); // 输出：Hello, Alice!\r\n  ```\r\n\r\n### **3.2 剩余参数与展开运算符**\r\n\r\n- **剩余参数**：用于收集不确定数量的参数。\r\n\r\n  ```javascript\r\n  function sum(...numbers) {\r\n      return numbers.reduce((acc, num) => acc + num, 0);\r\n  }\r\n\r\n  console.log(sum(1, 2, 3)); // 输出：6\r\n  ```\r\n\r\n- **展开运算符**：见上文。\r\n\r\n### **3.3 `Symbol` 类型**\r\n\r\n- **用途**：`Symbol` 是一种新的原始数据类型，表示唯一的标识符。\r\n- **特点**：\r\n  - 每个 `Symbol` 都是唯一的，即使它们具有相同的描述。\r\n  - 通常用于定义对象的唯一属性键。\r\n- **示例**：\r\n\r\n  ```javascript\r\n  const sym1 = Symbol("key");\r\n  const sym2 = Symbol("key");\r\n\r\n  console.log(sym1 === sym2); // 输出：false\r\n\r\n  const obj = {};\r\n  obj[sym1] = "value1";\r\n  obj[sym2] = "value2";\r\n\r\n  console.log(obj[sym1]); // 输出：value1\r\n  console.log(obj[sym2]); // 输出：value2\r\n  ```\r\n\r\n### **3.4 `Map` 和 `Set`**\r\n\r\n- **`Map`**：\r\n  - 键值对集合，支持任意类型的键（包括对象）。\r\n\r\n  ```javascript\r\n  const map = new Map();\r\n  map.set("name", "Alice");\r\n  map.set(42, "Answer");\r\n\r\n  console.log(map.get("name")); // 输出：Alice\r\n  console.log(map.get(42));     // 输出：Answer\r\n  ```\r\n\r\n- **`Set`**：\r\n  - 集合，存储唯一值。\r\n\r\n  ```javascript\r\n  const set = new Set([1, 2, 3, 3]);\r\n  console.log(set); // 输出：Set { 1, 2, 3 }\r\n\r\n  set.add(4);\r\n  console.log(set.has(2)); // 输出：true\r\n  set.delete(2);\r\n  console.log(set); // 输出：Set { 1, 3, 4 }\r\n  ```\r\n\r\n### **3.5 `Proxy` 和 `Reflect`**\r\n\r\n- **`Proxy`**：\r\n  - 用于拦截和自定义对象的操作（如读取、写入、删除等）。\r\n\r\n  ```javascript\r\n  const handler = {\r\n      get(target, prop) {\r\n          return prop in target ? target[prop] : "Default";\r\n      },\r\n      set(target, prop, value) {\r\n          if (value < 0) {\r\n              throw new Error("Value cannot be negative.");\r\n          }\r\n          target[prop] = value;\r\n          return true;\r\n      }\r\n  };\r\n\r\n  const proxy = new Proxy({}, handler);\r\n  proxy.age = 25;\r\n  console.log(proxy.age);    // 输出：25\r\n  console.log(proxy.name);   // 输出：Default\r\n  proxy.age = -5;            // 抛出错误：Value cannot be negative.\r\n  ```\r\n\r\n- **`Reflect`**：\r\n  - 提供了一组静态方法，用于操作对象（类似于 `Proxy` 的底层实现）。\r\n\r\n  ```javascript\r\n  const obj = { name: "Alice" };\r\n  console.log(Reflect.get(obj, "name")); // 输出：Alice\r\n  Reflect.set(obj, "age", 25);\r\n  console.log(obj); // 输出：{ name: "Alice", age: 25 }\r\n  ```\r\n\r\n---'}}]);
//# sourceMappingURL=45000.7407a0aa.js.map