{"version":3,"file":"js/6200.647119db.js","mappings":"oHAAA,iiL","sources":["webpack://myblog/./src/assets/md/java/content/010-十Java 动态代理 Dynamic Proxy详解.md"],"sourcesContent":["export default \"# **十、Java 动态代理 （Dynamic Proxy）详解**\\r\\n\\r\\nJava 动态代理是一种**运行时动态生成代理类的技术**，它是 Java 反射机制的一部分。通过动态代理，我们可以在不修改目标对象的前提下，对目标对象的方法进行增强或拦截，是 AOP（面向切面编程）的基础。\\r\\n\\r\\n## **📌 1、什么是动态代理？**\\r\\n\\r\\n### 定义\\r\\n\\r\\n动态代理是指在程序运行过程中，根据传入的真实对象（被代理对象），**动态创建一个代理对象**，并用这个代理对象来代替真实对象完成操作。\\r\\n\\r\\n### 核心作用\\r\\n\\r\\n- **在不修改目标对象的前提下，对方法进行功能增强**\\r\\n- **实现解耦，提高代码的可扩展性和灵活性**\\r\\n- **AOP（如 Spring AOP）底层实现原理**\\r\\n\\r\\n---\\r\\n\\r\\n## **🧱 2、核心 API 和类**\\r\\n\\r\\n| 类/接口 | 说明 |\\r\\n|--------|------|\\r\\n| `java.lang.reflect.Proxy` | 核心类，用于生成代理对象 |\\r\\n| `java.lang.reflect.InvocationHandler` | 接口，用于定义代理逻辑 |\\r\\n| `java.lang.reflect.Method` | 表示被调用的方法对象 |\\r\\n\\r\\n---\\r\\n\\r\\n## **🛠️ 3、动态代理的使用步骤**\\r\\n\\r\\n### ✅ 步骤 1：定义接口（必须）\\r\\n\\r\\n```java\\r\\npublic interface UserService {\\r\\n    void addUser();\\r\\n    void deleteUser();\\r\\n}\\r\\n```\\r\\n\\r\\n> ⚠️ 注意：Java 动态代理只能对接口进行代理！\\r\\n\\r\\n---\\r\\n\\r\\n### ✅ 步骤 2：实现接口类（真实对象）\\r\\n\\r\\n```java\\r\\npublic class UserServiceImpl implements UserService {\\r\\n    @Override\\r\\n    public void addUser() {\\r\\n        System.out.println(\\\"添加用户\\\");\\r\\n    }\\r\\n\\r\\n    @Override\\r\\n    public void deleteUser() {\\r\\n        System.out.println(\\\"删除用户\\\");\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### ✅ 步骤 3：实现 InvocationHandler 接口（定义代理逻辑）\\r\\n\\r\\n```java\\r\\nimport java.lang.reflect.InvocationHandler;\\r\\nimport java.lang.reflect.Method;\\r\\n\\r\\npublic class MyInvocationHandler implements InvocationHandler {\\r\\n\\r\\n    private Object target; // 被代理的对象\\r\\n\\r\\n    public MyInvocationHandler(Object target) {\\r\\n        this.target = target;\\r\\n    }\\r\\n\\r\\n    @Override\\r\\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\\r\\n        System.out.println(\\\"【前置增强】方法执行前：\\\" + method.getName());\\r\\n\\r\\n        // 执行真实对象的方法\\r\\n        Object result = method.invoke(target, args);\\r\\n\\r\\n        System.out.println(\\\"【后置增强】方法执行后：\\\" + method.getName());\\r\\n        return result;\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### ✅ 步骤 4：生成代理对象并调用\\r\\n\\r\\n```java\\r\\nimport java.lang.reflect.Proxy;\\r\\n\\r\\npublic class TestProxy {\\r\\n    public static void main(String[] args) {\\r\\n        // 创建真实对象\\r\\n        UserService userService = new UserServiceImpl();\\r\\n\\r\\n        // 创建代理处理器\\r\\n        MyInvocationHandler handler = new MyInvocationHandler(userService);\\r\\n\\r\\n        // 生成代理对象\\r\\n        UserService proxy = (UserService) Proxy.newProxyInstance(\\r\\n                userService.getClass().getClassLoader(),   // 类加载器\\r\\n                userService.getClass().getInterfaces(),   // 被代理对象实现的接口\\r\\n                handler                                   // 代理逻辑处理器\\r\\n        );\\r\\n\\r\\n        // 调用代理对象的方法\\r\\n        proxy.addUser();\\r\\n        proxy.deleteUser();\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## 📈 4、输出结果\\r\\n\\r\\n```\\r\\n【前置增强】方法执行前：addUser\\r\\n添加用户\\r\\n【后置增强】方法执行后：addUser\\r\\n\\r\\n【前置增强】方法执行前：deleteUser\\r\\n删除用户\\r\\n【后置增强】方法执行后：deleteUser\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## 🔄 5、与静态代理的区别\\r\\n\\r\\n| 特点 | 静态代理 | 动态代理 |\\r\\n|------|----------|-----------|\\r\\n| 代理类是否手动编写 | 是 | 否 |\\r\\n| 是否支持多个接口 | 否 | 是 |\\r\\n| 是否灵活 | 不灵活 | 灵活 |\\r\\n| 实现复杂度 | 简单 | 复杂 |\\r\\n| 性能 | 略高 | 略低（但差距不大） |\\r\\n\\r\\n---\\r\\n\\r\\n## 🔐 6、应用场景\\r\\n\\r\\n| 应用场景 | 说明 |\\r\\n|----------|------|\\r\\n| 日志记录 | 在方法执行前后记录日志 |\\r\\n| 权限控制 | 控制某些方法是否可以被调用 |\\r\\n| 性能监控 | 统计方法执行时间 |\\r\\n| 事务管理 | 在方法执行前后开启和提交事务 |\\r\\n| AOP 编程 | Spring 框架中大量使用动态代理做切面处理 |\\r\\n\\r\\n---\\r\\n\\r\\n## 🧩 7、Spring 中的 AOP 与动态代理的关系\\r\\n\\r\\nSpring AOP 默认使用 JDK 动态代理（基于接口），但如果目标类没有实现接口，则会使用 **CGLIB**（继承方式实现代理）。\\r\\n\\r\\n> ✅ 如果你希望强制使用 CGLIB 代理，可以在配置中设置：\\r\\n\\r\\n```xml\\r\\n<aop:config proxy-target-class=\\\"true\\\"/>\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## 📎 8、动态代理的局限性\\r\\n\\r\\n- **只能代理接口方法**（JDK 原生动态代理）\\r\\n- **不能代理类方法**（除非使用 CGLIB 或 Javassist 等第三方库）\\r\\n- **性能略低于直接调用**（但一般影响不大）\\r\\n- **调试较困难**（因为代理类是运行时生成的）\\r\\n\\r\\n---\\r\\n\\r\\n## 🧪 9、完整代码汇总\\r\\n\\r\\n### 1. 接口定义\\r\\n\\r\\n```java\\r\\npublic interface UserService {\\r\\n    void addUser();\\r\\n    void deleteUser();\\r\\n}\\r\\n```\\r\\n\\r\\n### 2. 实现类\\r\\n\\r\\n```java\\r\\npublic class UserServiceImpl implements UserService {\\r\\n    @Override\\r\\n    public void addUser() {\\r\\n        System.out.println(\\\"添加用户\\\");\\r\\n    }\\r\\n\\r\\n    @Override\\r\\n    public void deleteUser() {\\r\\n        System.out.println(\\\"删除用户\\\");\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n### 3. 代理处理器\\r\\n\\r\\n```java\\r\\nimport java.lang.reflect.InvocationHandler;\\r\\nimport java.lang.reflect.Method;\\r\\n\\r\\npublic class MyInvocationHandler implements InvocationHandler {\\r\\n    private Object target;\\r\\n\\r\\n    public MyInvocationHandler(Object target) {\\r\\n        this.target = target;\\r\\n    }\\r\\n\\r\\n    @Override\\r\\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\\r\\n        System.out.println(\\\"【前置增强】方法执行前：\\\" + method.getName());\\r\\n        Object result = method.invoke(target, args);\\r\\n        System.out.println(\\\"【后置增强】方法执行后：\\\" + method.getName());\\r\\n        return result;\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n### 4. 测试类\\r\\n\\r\\n```java\\r\\nimport java.lang.reflect.Proxy;\\r\\n\\r\\npublic class TestProxy {\\r\\n    public static void main(String[] args) {\\r\\n        UserService userService = new UserServiceImpl();\\r\\n        MyInvocationHandler handler = new MyInvocationHandler(userService);\\r\\n        UserService proxy = (UserService) Proxy.newProxyInstance(\\r\\n            userService.getClass().getClassLoader(),\\r\\n            userService.getClass().getInterfaces(),\\r\\n            handler\\r\\n        );\\r\\n        proxy.addUser();\\r\\n        proxy.deleteUser();\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## 🧠 10、总结\\r\\n\\r\\n| 项目 | 内容 |\\r\\n|------|------|\\r\\n| 动态代理 | 运行时生成代理类，用于增强方法 |\\r\\n| 核心类 | `Proxy`, `InvocationHandler` |\\r\\n| 必须条件 | 被代理类必须实现接口 |\\r\\n| 使用场景 | 日志、权限、事务、AOP |\\r\\n| 优点 | 解耦、灵活、易于扩展 |\\r\\n| 缺点 | 只能代理接口方法，调试困难 |\";"],"names":[],"sourceRoot":""}