{"version":3,"file":"js/52007.401008f9.js","mappings":"qHAAA,mqY","sources":["webpack://myblog/./src/assets/md/javascript/content/011-对象与原型.md"],"sourcesContent":["export default \"## **对象与原型**\\r\\n\\r\\n### **1. 对象的创建方式**\\r\\n\\r\\n在 JavaScript 中，可以通过多种方式创建对象。以下是三种常见的方法：\\r\\n\\r\\n#### **1.1 字面量**\\r\\n\\r\\n字面量是最简单、最常用的方式，适合快速创建对象。\\r\\n\\r\\n**语法**：\\r\\n\\r\\n```javascript\\r\\nconst obj = {\\r\\n    key1: value1,\\r\\n    key2: value2,\\r\\n    method() {\\r\\n        console.log(\\\"This is a method.\\\");\\r\\n    }\\r\\n};\\r\\n```\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nconst person = {\\r\\n    name: \\\"Alice\\\",\\r\\n    age: 25,\\r\\n    greet() {\\r\\n        console.log(`Hello, my name is ${this.name}.`);\\r\\n    }\\r\\n};\\r\\n\\r\\nconsole.log(person.name); // 输出：Alice\\r\\nperson.greet(); // 输出：Hello, my name is Alice.\\r\\n```\\r\\n\\r\\n**特点**：\\r\\n\\r\\n- 简洁直观，适合定义简单的对象。\\r\\n- 不支持动态生成属性名或复杂逻辑。\\r\\n\\r\\n#### **1.2 构造函数**\\r\\n\\r\\n构造函数是一种通过 `new` 关键字创建对象的方式，适合批量生成具有相同结构的对象。\\r\\n\\r\\n**语法**：\\r\\n\\r\\n```javascript\\r\\nfunction ConstructorName(param1, param2) {\\r\\n    this.property1 = param1;\\r\\n    this.property2 = param2;\\r\\n    this.method = function() {\\r\\n        console.log(\\\"This is a method.\\\");\\r\\n    };\\r\\n}\\r\\n\\r\\nconst obj = new ConstructorName(value1, value2);\\r\\n```\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nfunction Person(name, age) {\\r\\n    this.name = name;\\r\\n    this.age = age;\\r\\n    this.greet = function() {\\r\\n        console.log(`Hello, my name is ${this.name}.`);\\r\\n    };\\r\\n}\\r\\n\\r\\nconst alice = new Person(\\\"Alice\\\", 25);\\r\\nconsole.log(alice.name); // 输出：Alice\\r\\nalice.greet(); // 输出：Hello, my name is Alice.\\r\\n```\\r\\n\\r\\n**特点**：\\r\\n\\r\\n- 支持动态生成对象。\\r\\n- 每个实例都会复制一份方法，可能导致内存浪费（可通过原型链优化）。\\r\\n\\r\\n#### **1.3`Object.create()`**\\r\\n\\r\\n`Object.create()` 是一种基于原型创建对象的方式，适用于需要显式指定原型链的场景。\\r\\n\\r\\n**语法**：\\r\\n\\r\\n```javascript\\r\\nconst obj = Object.create(原型对象);\\r\\nobj.key = value;\\r\\n```\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nconst prototypeObj = {\\r\\n    greet() {\\r\\n        console.log(`Hello, my name is ${this.name}.`);\\r\\n    }\\r\\n};\\r\\n\\r\\nconst person = Object.create(prototypeObj);\\r\\nperson.name = \\\"Alice\\\";\\r\\nperson.age = 25;\\r\\n\\r\\nconsole.log(person.name); // 输出：Alice\\r\\nperson.greet(); // 输出：Hello, my name is Alice.\\r\\n```\\r\\n\\r\\n**特点**：\\r\\n\\r\\n- 明确指定对象的原型。\\r\\n- 不会自动执行构造函数逻辑，适合轻量级对象创建。\\r\\n\\r\\n---\\r\\n\\r\\n### **2. 属性操作**\\r\\n\\r\\nJavaScript 提供了丰富的 API 来操作对象的属性，包括增删改查以及获取键值对。\\r\\n\\r\\n#### **2.1 增加属性**\\r\\n\\r\\n直接通过点运算符或方括号为对象添加新属性。\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nconst obj = {};\\r\\nobj.name = \\\"Alice\\\"; // 使用点运算符\\r\\nobj[\\\"age\\\"] = 25;    // 使用方括号\\r\\n\\r\\nconsole.log(obj); // 输出：{ name: 'Alice', age: 25 }\\r\\n```\\r\\n\\r\\n#### **2.2 删除属性**\\r\\n\\r\\n使用 `delete` 关键字删除对象的属性。\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nconst obj = { name: \\\"Alice\\\", age: 25 };\\r\\ndelete obj.age;\\r\\n\\r\\nconsole.log(obj); // 输出：{ name: 'Alice' }\\r\\n```\\r\\n\\r\\n#### **2.3 修改属性**\\r\\n\\r\\n通过重新赋值修改现有属性。\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nconst obj = { name: \\\"Alice\\\" };\\r\\nobj.name = \\\"Bob\\\";\\r\\n\\r\\nconsole.log(obj); // 输出：{ name: 'Bob' }\\r\\n```\\r\\n\\r\\n#### **2.4 查询属性**\\r\\n\\r\\n通过点运算符或方括号访问属性值。\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nconst obj = { name: \\\"Alice\\\", age: 25 };\\r\\n\\r\\nconsole.log(obj.name);   // 输出：Alice\\r\\nconsole.log(obj[\\\"age\\\"]); // 输出：25\\r\\n```\\r\\n\\r\\n#### **2.5 获取键值对**\\r\\n\\r\\n使用 `Object.keys()`、`Object.values()` 和 `Object.entries()` 获取对象的键、值或键值对。\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nconst obj = { name: \\\"Alice\\\", age: 25 };\\r\\n\\r\\nconsole.log(Object.keys(obj));   // 输出：['name', 'age']\\r\\nconsole.log(Object.values(obj)); // 输出：['Alice', 25]\\r\\nconsole.log(Object.entries(obj)); // 输出：[['name', 'Alice'], ['age', 25]]\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### **3. 原型链与继承**\\r\\n\\r\\nJavaScript 的继承机制基于原型链。每个对象都有一个隐式的 `[[Prototype]]` 属性，指向其原型对象。当访问某个属性时，如果当前对象没有该属性，则会沿着原型链向上查找。\\r\\n\\r\\n#### **3.1 原型链的概念**\\r\\n\\r\\n- **`__proto__`**：每个对象都有一个 `__proto__` 属性，指向其原型对象。\\r\\n- **`prototype`**：构造函数有一个 `prototype` 属性，指向其所有实例共享的原型对象。\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nfunction Person(name) {\\r\\n    this.name = name;\\r\\n}\\r\\n\\r\\nPerson.prototype.greet = function() {\\r\\n    console.log(`Hello, my name is ${this.name}.`);\\r\\n};\\r\\n\\r\\nconst alice = new Person(\\\"Alice\\\");\\r\\nalice.greet(); // 输出：Hello, my name is Alice.\\r\\n\\r\\nconsole.log(alice.__proto__ === Person.prototype); // 输出：true\\r\\n```\\r\\n\\r\\n#### **3.2 继承的实现**\\r\\n\\r\\n通过原型链可以实现继承。\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nfunction Parent(name) {\\r\\n    this.name = name;\\r\\n}\\r\\n\\r\\nParent.prototype.greet = function() {\\r\\n    console.log(`Hello, my name is ${this.name}.`);\\r\\n};\\r\\n\\r\\nfunction Child(name, age) {\\r\\n    Parent.call(this, name); // 调用父类构造函数\\r\\n    this.age = age;\\r\\n}\\r\\n\\r\\nChild.prototype = Object.create(Parent.prototype); // 设置子类原型\\r\\nChild.prototype.constructor = Child;\\r\\n\\r\\nChild.prototype.introduce = function() {\\r\\n    console.log(`I am ${this.name}, and I am ${this.age} years old.`);\\r\\n};\\r\\n\\r\\nconst child = new Child(\\\"Alice\\\", 10);\\r\\nchild.greet();      // 输出：Hello, my name is Alice.\\r\\nchild.introduce();  // 输出：I am Alice, and I am 10 years old.\\r\\n```\\r\\n\\r\\n#### **3.3 `Object.create()` 实现继承**\\r\\n\\r\\n也可以使用 `Object.create()` 实现继承。\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nconst parent = {\\r\\n    greet() {\\r\\n        console.log(`Hello, my name is ${this.name}.`);\\r\\n    }\\r\\n};\\r\\n\\r\\nconst child = Object.create(parent);\\r\\nchild.name = \\\"Alice\\\";\\r\\nchild.greet(); // 输出：Hello, my name is Alice.\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### **4. `this` 关键字及其绑定规则**\\r\\n\\r\\n`this` 是 JavaScript 中的一个特殊关键字，表示当前执行上下文中的对象。它的值取决于调用方式，遵循以下绑定规则：\\r\\n\\r\\n#### **4.1 默认绑定**\\r\\n\\r\\n当函数作为普通函数调用时，`this` 指向全局对象（浏览器中为 `window`，严格模式下为 `undefined`）。\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nfunction showThis() {\\r\\n    console.log(this);\\r\\n}\\r\\n\\r\\nshowThis(); // 非严格模式下输出：window；严格模式下输出：undefined\\r\\n```\\r\\n\\r\\n#### **4.2 隐式绑定**\\r\\n\\r\\n当函数作为对象的方法调用时，`this` 指向调用该方法的对象。\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nconst obj = {\\r\\n    name: \\\"Alice\\\",\\r\\n    greet() {\\r\\n        console.log(`Hello, my name is ${this.name}.`);\\r\\n    }\\r\\n};\\r\\n\\r\\nobj.greet(); // 输出：Hello, my name is Alice.\\r\\n```\\r\\n\\r\\n#### **4.3 显式绑定**\\r\\n\\r\\n通过 `call`、`apply` 或 `bind` 手动指定 `this` 的值。\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nfunction greet() {\\r\\n    console.log(`Hello, my name is ${this.name}.`);\\r\\n}\\r\\n\\r\\nconst obj = { name: \\\"Alice\\\" };\\r\\n\\r\\ngreet.call(obj); // 输出：Hello, my name is Alice.\\r\\ngreet.apply(obj); // 输出：Hello, my name is Alice.\\r\\n\\r\\nconst boundGreet = greet.bind(obj);\\r\\nboundGreet(); // 输出：Hello, my name is Alice.\\r\\n```\\r\\n\\r\\n#### **4.4 箭头函数的 `this`**\\r\\n\\r\\n箭头函数没有自己的 `this`，而是继承自外层作用域的 `this`。\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nconst obj = {\\r\\n    name: \\\"Alice\\\",\\r\\n    greet: () => {\\r\\n        console.log(`Hello, my name is ${this.name}.`);\\r\\n    }\\r\\n};\\r\\n\\r\\nobj.greet(); // 输出：Hello, my name is undefined.\\r\\n```\\r\\n\\r\\n### **Class特性**\\r\\n\\r\\n`class` 是 ES6 引入的一种更简洁、更直观的方式来定义构造函数和实现继承。它本质上仍然是基于原型链的机制，但提供了更清晰的语法结构。\\r\\n\\r\\n#### **1. 定义类**\\r\\n\\r\\n##### **基本语法**\\r\\n\\r\\n```javascript\\r\\nclass ClassName {\\r\\n    constructor(param1, param2) {\\r\\n        this.property1 = param1;\\r\\n        this.property2 = param2;\\r\\n    }\\r\\n\\r\\n    method() {\\r\\n        console.log(\\\"This is a method.\\\");\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n- **`constructor`**：\\r\\n  - 类的构造函数，用于初始化实例属性。\\r\\n  - 每个类只能有一个 `constructor` 方法。\\r\\n  - 如果没有显式定义 `constructor`，会默认提供一个空的构造函数。\\r\\n\\r\\n##### **示例**\\r\\n\\r\\n```javascript\\r\\nclass Person {\\r\\n    constructor(name, age) {\\r\\n        this.name = name;\\r\\n        this.age = age;\\r\\n    }\\r\\n\\r\\n    greet() {\\r\\n        console.log(`Hello, my name is ${this.name}.`);\\r\\n    }\\r\\n}\\r\\n\\r\\nconst alice = new Person(\\\"Alice\\\", 25);\\r\\nconsole.log(alice.name); // 输出：Alice\\r\\nalice.greet(); // 输出：Hello, my name is Alice.\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n#### **2. 继承**\\r\\n\\r\\n通过 `extends` 关键字可以实现类的继承，子类可以继承父类的属性和方法，并且可以通过 `super` 调用父类的构造函数或方法。\\r\\n\\r\\n##### **基本语法**\\r\\n\\r\\n```javascript\\r\\nclass Parent {\\r\\n    constructor(...args) {\\r\\n        // 父类的初始化逻辑\\r\\n    }\\r\\n\\r\\n    parentMethod() {\\r\\n        console.log(\\\"Parent method.\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\nclass Child extends Parent {\\r\\n    constructor(...args) {\\r\\n        super(...args); // 调用父类的构造函数\\r\\n        // 子类的初始化逻辑\\r\\n    }\\r\\n\\r\\n    childMethod() {\\r\\n        console.log(\\\"Child method.\\\");\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n##### **示例**\\r\\n\\r\\n```javascript\\r\\nclass Animal {\\r\\n    constructor(name) {\\r\\n        this.name = name;\\r\\n    }\\r\\n\\r\\n    speak() {\\r\\n        console.log(`${this.name} makes a noise.`);\\r\\n    }\\r\\n}\\r\\n\\r\\nclass Dog extends Animal {\\r\\n    constructor(name, breed) {\\r\\n        super(name); // 调用父类的构造函数\\r\\n        this.breed = breed;\\r\\n    }\\r\\n\\r\\n    speak() {\\r\\n        console.log(`${this.name} barks.`);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n        console.log(`${this.name} is a ${this.breed}.`);\\r\\n    }\\r\\n}\\r\\n\\r\\nconst dog = new Dog(\\\"Rex\\\", \\\"German Shepherd\\\");\\r\\ndog.speak();    // 输出：Rex barks.\\r\\ndog.describe(); // 输出：Rex is a German Shepherd.\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n#### **3. 静态方法与属性**\\r\\n\\r\\n静态方法和属性是直接属于类本身的，而不是实例的。它们通过 `static` 关键字定义。\\r\\n\\r\\n##### **静态方法**\\r\\n\\r\\n- **定义**：\\r\\n\\r\\n  ```javascript\\r\\n  class MyClass {\\r\\n      static staticMethod() {\\r\\n          console.log(\\\"This is a static method.\\\");\\r\\n      }\\r\\n  }\\r\\n  ```\\r\\n\\r\\n- **调用**：\\r\\n\\r\\n  ```javascript\\r\\n  MyClass.staticMethod(); // 输出：This is a static method.\\r\\n  ```\\r\\n\\r\\n##### **静态属性**\\r\\n\\r\\n- **定义**（ES2022 引入）：\\r\\n\\r\\n  ```javascript\\r\\n  class MyClass {\\r\\n      static staticProperty = \\\"I am static.\\\";\\r\\n  }\\r\\n  ```\\r\\n\\r\\n- **访问**：\\r\\n\\r\\n  ```javascript\\r\\n  console.log(MyClass.staticProperty); // 输出：I am static.\\r\\n  ```\\r\\n\\r\\n##### **示例**\\r\\n\\r\\n```javascript\\r\\nclass MathUtils {\\r\\n    static add(a, b) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    static PI = 3.14159;\\r\\n}\\r\\n\\r\\nconsole.log(MathUtils.add(2, 3)); // 输出：5\\r\\nconsole.log(MathUtils.PI);       // 输出：3.14159\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n#### **4. 私有字段与方法**\\r\\n\\r\\nES2022 引入了私有字段和方法，使用 `#` 前缀来定义。私有成员只能在类内部访问，外部无法直接访问。\\r\\n\\r\\n##### **私有字段**\\r\\n\\r\\n```javascript\\r\\nclass Counter {\\r\\n    #count = 0; // 私有字段\\r\\n\\r\\n    increment() {\\r\\n        this.#count++;\\r\\n    }\\r\\n\\r\\n    getCount() {\\r\\n        return this.#count;\\r\\n    }\\r\\n}\\r\\n\\r\\nconst counter = new Counter();\\r\\ncounter.increment();\\r\\nconsole.log(counter.getCount()); // 输出：1\\r\\nconsole.log(counter.#count);     // 报错：Private field '#count' must be declared in an enclosing class\\r\\n```\\r\\n\\r\\n##### **私有方法**\\r\\n\\r\\n```javascript\\r\\nclass Secret {\\r\\n    #privateMethod() {\\r\\n        console.log(\\\"This is a private method.\\\");\\r\\n    }\\r\\n\\r\\n    publicMethod() {\\r\\n        this.#privateMethod();\\r\\n    }\\r\\n}\\r\\n\\r\\nconst secret = new Secret();\\r\\nsecret.publicMethod(); // 输出：This is a private method.\\r\\nsecret.#privateMethod(); // 报错：Private field '#privateMethod' must be declared in an enclosing class\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n#### **5. Getter 和 Setter**\\r\\n\\r\\n`getter` 和 `setter` 是用于定义对象属性的访问器方法，允许在访问或修改属性时执行自定义逻辑。\\r\\n\\r\\n##### **基本语法**\\r\\n\\r\\n```javascript\\r\\nclass MyClass {\\r\\n    constructor(value) {\\r\\n        this._value = value;\\r\\n    }\\r\\n\\r\\n    get value() {\\r\\n        return this._value;\\r\\n    }\\r\\n\\r\\n    set value(newValue) {\\r\\n        if (newValue > 0) {\\r\\n            this._value = newValue;\\r\\n        } else {\\r\\n            console.error(\\\"Value must be positive.\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n##### **示例**\\r\\n\\r\\n```javascript\\r\\nclass Rectangle {\\r\\n    constructor(width, height) {\\r\\n        this._width = width;\\r\\n        this._height = height;\\r\\n    }\\r\\n\\r\\n    get area() {\\r\\n        return this._width * this._height;\\r\\n    }\\r\\n\\r\\n    set width(newWidth) {\\r\\n        if (newWidth > 0) {\\r\\n            this._width = newWidth;\\r\\n        } else {\\r\\n            console.error(\\\"Width must be positive.\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nconst rect = new Rectangle(5, 10);\\r\\nconsole.log(rect.area); // 输出：50\\r\\n\\r\\nrect.width = 8;\\r\\nconsole.log(rect.area); // 输出：80\\r\\n\\r\\nrect.width = -3; // 输出：Width must be positive.\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n#### **6. 类与原型的关系**\\r\\n\\r\\n尽管 `class` 提供了更简洁的语法，但它本质上仍然是基于原型的机制。以下是一些关键点：\\r\\n\\r\\n1. **原型链**：\\r\\n   - 类的方法会被添加到原型对象中。\\r\\n   - 实例通过原型链访问这些方法。\\r\\n\\r\\n     ```javascript\\r\\n     class MyClass {\\r\\n         method() {}\\r\\n     }\\r\\n\\r\\n     const obj = new MyClass();\\r\\n     console.log(obj.__proto__ === MyClass.prototype); // 输出：true\\r\\n     ```\\r\\n\\r\\n2. **继承的本质**：\\r\\n   - 子类的原型对象指向父类的原型对象。\\r\\n\\r\\n     ```javascript\\r\\n     class Parent {}\\r\\n     class Child extends Parent {}\\r\\n\\r\\n     console.log(Child.prototype.__proto__ === Parent.prototype); // 输出：true\\r\\n     ```\\r\\n\\r\\n---\\r\\n\\r\\n---\";"],"names":[],"sourceRoot":""}