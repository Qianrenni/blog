"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[3654],{83654:function(n,r,o){o.r(r),r["default"]='## **5.2 装饰器模式**\r\n\r\n### **定义与特点**\r\n\r\n装饰器模式允许动态地给对象添加行为，而无需修改原始类的代码。它通过创建一个包装对象（装饰器）来增强目标对象的功能。\r\n\r\n### **动态扩展对象功能**\r\n\r\n- 装饰器模式的核心是“组合优于继承”。\r\n\r\n### **示例：Java IO 流中的装饰器模式**\r\n\r\n```python\r\n# 基础组件\r\nclass Component:\r\n    def operation(self):\r\n        pass\r\n\r\nclass ConcreteComponent(Component):\r\n    def operation(self):\r\n        return "ConcreteComponent"\r\n\r\n# 装饰器基类\r\nclass Decorator(Component):\r\n    def __init__(self, component):\r\n        self.component = component\r\n\r\n    def operation(self):\r\n        return self.component.operation()\r\n\r\n# 具体装饰器\r\nclass ConcreteDecoratorA(Decorator):\r\n    def operation(self):\r\n        return f"ConcreteDecoratorA({self.component.operation()})"\r\n\r\nclass ConcreteDecoratorB(Decorator):\r\n    def operation(self):\r\n        return f"ConcreteDecoratorB({self.component.operation()})"\r\n\r\n# 使用示例\r\ncomponent = ConcreteComponent()\r\ndecorator_a = ConcreteDecoratorA(component)\r\ndecorator_b = ConcreteDecoratorB(decorator_a)\r\nprint(decorator_b.operation())\r\n# 输出: ConcreteDecoratorB(ConcreteDecoratorA(ConcreteComponent))\r\n```\r\n\r\n---'}}]);
//# sourceMappingURL=3654.c8e70710.js.map