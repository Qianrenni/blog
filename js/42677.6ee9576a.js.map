{"version":3,"file":"js/42677.6ee9576a.js","mappings":"qHAAA,gigB","sources":["webpack://myblog/./src/assets/md/algorithm/content/006-4数据结构对应算法.md"],"sourcesContent":["export default \"## **4.数据结构对应算法**\\r\\n\\r\\n### **栈**\\r\\n\\r\\n#### **表达式求值**\\r\\n\\r\\n```python\\r\\ndef evaluate_expression(expression):\\r\\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\\r\\n    expression = expression.replace(' ', '')\\r\\n    values = []\\r\\n    ops = []\\r\\n    i = 0\\r\\n    n=len(expression)\\r\\n    while i < n:\\r\\n        # 处理负号（一元运算符）\\r\\n        if expression[i] == '-' and (i == 0 or expression[i - 1] == '(' or expression[i - 1] in precedence):\\r\\n            # 这是一个负号而不是减号\\r\\n            num_str = '-'\\r\\n            i += 1\\r\\n            # 收集数字部分\\r\\n            while i < n and (expression[i].isdigit() or expression[i] == '.'):\\r\\n                num_str += expression[i]\\r\\n                i += 1\\r\\n            values.append(float(num_str))\\r\\n            continue\\r\\n\\r\\n        # 处理数字（正数）\\r\\n        if expression[i].isdigit() or expression[i] == '.':\\r\\n            num_str = ''\\r\\n            while i < len(expression) and (expression[i].isdigit() or expression[i] == '.'):\\r\\n                num_str += expression[i]\\r\\n                i += 1\\r\\n            values.append(float(num_str))\\r\\n            continue\\r\\n\\r\\n        # 处理运算符和括号（与原逻辑相同）\\r\\n        if expression[i] == '(':\\r\\n            ops.append(expression[i])\\r\\n        elif expression[i] == ')':\\r\\n            while ops and ops[-1] != '(':\\r\\n                apply_operation(values, ops)\\r\\n            ops.pop()\\r\\n        else:\\r\\n            while (ops and ops[-1] != '(' and\\r\\n                   precedence.get(ops[-1], 0) >= precedence.get(expression[i], 0)):\\r\\n                apply_operation(values, ops)\\r\\n            ops.append(expression[i])\\r\\n        i += 1\\r\\n\\r\\n    while ops:\\r\\n        apply_operation(values, ops)\\r\\n\\r\\n    return values[-1] if values else 0\\r\\n\\r\\n\\r\\ndef apply_operation(values, ops):\\r\\n    if len(values) < 2 or not ops:\\r\\n        return\\r\\n\\r\\n    op = ops.pop()\\r\\n    b = values.pop()\\r\\n    a = values.pop()\\r\\n\\r\\n    if op == '+':\\r\\n        values.append(a + b)\\r\\n    elif op == '-':\\r\\n        values.append(a - b)\\r\\n    elif op == '*':\\r\\n        values.append(a * b)\\r\\n    elif op == '/':\\r\\n        values.append(a / b)\\r\\n    elif op == '^':\\r\\n        values.append(a ** b)\\r\\n\\r\\n```\\r\\n\\r\\n#### **单调栈**\\r\\n\\r\\n##### **下一个更大元素**\\r\\n\\r\\n>**问题描述**:\\r\\n给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。\\r\\n数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。\\r\\n\\r\\n```python\\r\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\r\\n        stack=[]\\r\\n        n=len(nums)\\r\\n        nums*=2\\r\\n        result=[-1]*n \\r\\n        for i in range(2*n):\\r\\n            while stack and nums[i]>nums[stack[-1]]:\\r\\n                index=stack.pop()\\r\\n                if index<n:\\r\\n                    result[index]=nums[i]\\r\\n            stack.append(i)\\r\\n        return result\\r\\n```\\r\\n\\r\\n### **链表**\\r\\n\\r\\n#### **反转链表**\\r\\n\\r\\n链表可以通过修改节点的指针来反转链表，时间复杂度为$O(n)$。\\r\\n\\r\\n```python\\r\\ndef reverse_list(head:ListNode)->ListNode:\\r\\n    pre, cur = None, head\\r\\n    while cur:\\r\\n        next = cur.next\\r\\n        cur.next = pre\\r\\n        pre, cur = cur, next\\r\\n    return pre\\r\\n```\\r\\n\\r\\n#### **判断链表是否成环**\\r\\n\\r\\n可以使用快慢指针的方法，如果链表存在环，快指针和慢指针一定会相遇，时间复杂度为$O(n)$。\\r\\n\\r\\n```python\\r\\ndef has_cycle(head: ListNode) -> bool:\\r\\n    fast, slow = head, head\\r\\n    while fast and fast.next:\\r\\n        fast, slow = fast.next.next, slow.next\\r\\n        if fast == slow:\\r\\n            return True\\r\\n    return False\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### **树**\\r\\n\\r\\n#### **二叉树的遍历**\\r\\n\\r\\n实现二叉树的前序、中序、后序和层序遍历。\\r\\n\\r\\n```python\\r\\ndef preorderTraversal(root: TreeNode) -> List[int]:\\r\\n    if not root: \\r\\n        return []\\r\\n    res = [root.val]\\r\\n    for node in root.children:\\r\\n        res+=preorderTraversal(node)\\r\\n    return res\\r\\ndef inorderTraversal(root: TreeNode) -> List[int]:\\r\\n    if not root: \\r\\n        return []\\r\\n    res=[]\\r\\n    res+=inorderTraversal(root.left)\\r\\n    res.append(root.val)\\r\\n    res+=inorderTraversal(root.right)\\r\\n    return res\\r\\ndef postorderTraversal(root: TreeNode) -> List[int]:\\r\\n    if not root: \\r\\n        return []\\r\\n    res=[]\\r\\n    res+=postorderTraversal(root.left)\\r\\n    res+=postorderTraversal(root.right)\\r\\n    res.append(root.val)\\r\\n    return res\\r\\ndef levelOrder(root: TreeNode) -> List[List[int]]:\\r\\n    if not root: \\r\\n        return []\\r\\n    res = []\\r\\n    queue = deque([root])\\r\\n    while queue:\\r\\n    level = []\\r\\n    for _ in range(len(queue)):\\r\\n        node = queue.popleft()\\r\\n        level.append(node.val)\\r\\n        for child in node.children:\\r\\n        queue.append(child)\\r\\n    res.append(level)\\r\\n    return res\\r\\n```\\r\\n\\r\\n#### **二叉搜索树的建立**\\r\\n  \\r\\n```python\\r\\nclass TreeNode:\\r\\ndef __init__(self, val=0, left=None, right=None):\\r\\n    self.val = val\\r\\n    self.left = left\\r\\n    self.right = right\\r\\n\\r\\ndef sorted_array_to_bst(nums):\\r\\n    \\\"\\\"\\\"\\r\\n    将一个排好序的数组转换为一棵高度平衡的二叉搜索树。\\r\\n    \\r\\n    参数:\\r\\n        nums: List[int] - 升序排列的数组\\r\\n    \\r\\n    返回:\\r\\n        TreeNode - 高度平衡的二叉搜索树的根节点\\r\\n    \\\"\\\"\\\"\\r\\n    def build_bst(left, right):\\r\\n        # 递归终止条件\\r\\n        if left > right:\\r\\n            return None\\r\\n        \\r\\n        # 选择中间元素作为根节点\\r\\n        mid = (left + right) // 2\\r\\n        root = TreeNode(nums[mid])\\r\\n        \\r\\n        # 递归构建左右子树\\r\\n        root.left = build_bst(left, mid - 1)\\r\\n        root.right = build_bst(mid + 1, right)\\r\\n        \\r\\n        return root\\r\\n```\\r\\n\\r\\n#### **二叉树的类实现(CRUD等操作)**\\r\\n\\r\\n```python\\r\\nclass TreeNode:\\r\\n    \\\"\\\"\\\"\\r\\n    定义二叉树的节点类。\\r\\n    每个节点包含三个属性：\\r\\n    - val: 节点的值\\r\\n    - left: 左子节点\\r\\n    - right: 右子节点\\r\\n    \\\"\\\"\\\"\\r\\n    def __init__(self, val=0, left=None, right=None):\\r\\n        self.val = val\\r\\n        self.left = left\\r\\n        self.right = right\\r\\n\\r\\n\\r\\nclass BinarySearchTree:\\r\\n    \\\"\\\"\\\"\\r\\n    定义二叉搜索树类。\\r\\n    提供插入、删除、修改、查找等操作。\\r\\n    \\\"\\\"\\\"\\r\\n    def __init__(self):\\r\\n        self.root = None  # 初始化根节点为空\\r\\n\\r\\n    def insert(self, val):\\r\\n        \\\"\\\"\\\"\\r\\n        向 BST 中插入一个值。\\r\\n        如果树为空，则创建新节点作为根节点。\\r\\n        否则根据值的大小递归地找到合适的位置插入新节点。\\r\\n        \\\"\\\"\\\"\\r\\n        self.root = self._insert(self.root, val)\\r\\n\\r\\n    def _insert(self, node, val):\\r\\n        if not node:  # 如果当前节点为空，创建新节点\\r\\n            return TreeNode(val)\\r\\n        \\r\\n        if val < node.val:  # 插入左子树\\r\\n            node.left = self._insert(node.left, val)\\r\\n        elif val > node.val:  # 插入右子树\\r\\n            node.right = self._insert(node.right, val)\\r\\n        # 如果 val == node.val，可以选择忽略（不允许重复值）\\r\\n        return node\\r\\n\\r\\n    def delete(self, val):\\r\\n        \\\"\\\"\\\"\\r\\n        从 BST 中删除一个值。\\r\\n        需要处理三种情况：\\r\\n        1. 被删除节点是叶子节点：直接移除该节点。\\r\\n        2. 被删除节点有一个子节点：用子节点替换被删除节点。\\r\\n        3. 被删除节点有两个子节点：\\r\\n        找到其前驱节点（左子树中的最大值）或后继节点（右子树中的最小值），\\r\\n        用前驱/后继的值替换被删除节点，并递归删除前驱/后继节点。\\r\\n        \\\"\\\"\\\"\\r\\n        self.root = self._delete(self.root, val)\\r\\n\\r\\n    def _delete(self, node, val):\\r\\n        if not node:  # 如果节点为空，直接返回\\r\\n            return None\\r\\n        \\r\\n        if val < node.val:  # 在左子树中删除\\r\\n            node.left = self._delete(node.left, val)\\r\\n        elif val > node.val:  # 在右子树中删除\\r\\n            node.right = self._delete(node.right, val)\\r\\n        else:  # 找到要删除的节点\\r\\n            # 情况 1 和 2：节点只有一个子节点或没有子节点\\r\\n            if not node.left:\\r\\n                return node.right\\r\\n            if not node.right:\\r\\n                return node.left\\r\\n            \\r\\n            # 情况 3：节点有两个子节点\\r\\n            # 找到右子树中的最小值（后继节点）\\r\\n            min_node = self._find_min(node.right)\\r\\n            node.val = min_node.val  # 替换当前节点的值\\r\\n            node.right = self._delete(node.right, min_node.val)  # 删除后继节点\\r\\n        \\r\\n        return node\\r\\n\\r\\n    def _find_min(self, node):\\r\\n        \\\"\\\"\\\"\\r\\n        找到子树中的最小值节点。\\r\\n        最小值节点位于左子树的最左侧。\\r\\n        \\\"\\\"\\\"\\r\\n        while node.left:\\r\\n            node = node.left\\r\\n        return node\\r\\n\\r\\n    def update(self, old_val, new_val):\\r\\n        \\\"\\\"\\\"\\r\\n        修改 BST 中的一个值。\\r\\n        修改操作可以看作是删除旧值并插入新值的组合。\\r\\n        \\\"\\\"\\\"\\r\\n        self.delete(old_val)  # 删除旧值\\r\\n        self.insert(new_val)  # 插入新值\\r\\n\\r\\n    def search(self, val):\\r\\n        \\\"\\\"\\\"\\r\\n        查找 BST 中是否存在某个值。\\r\\n        如果存在，返回对应的节点；否则返回 None。\\r\\n        \\\"\\\"\\\"\\r\\n        return self._search(self.root, val)\\r\\n\\r\\n    def _search(self, node, val):\\r\\n        if not node or node.val == val:  # 如果节点为空或找到目标值\\r\\n            return node\\r\\n        \\r\\n        if val < node.val:  # 在左子树中查找\\r\\n            return self._search(node.left, val)\\r\\n        else:  # 在右子树中查找\\r\\n            return self._search(node.right, val)\\r\\n\\r\\n    def inorder_traversal(self):\\r\\n        \\\"\\\"\\\"\\r\\n        中序遍历 BST。\\r\\n        中序遍历的结果是一个升序排列的列表。\\r\\n        \\\"\\\"\\\"\\r\\n        result = []\\r\\n        self._inorder_traversal(self.root, result)\\r\\n        return result\\r\\n\\r\\n    def _inorder_traversal(self, node, result):\\r\\n        if not node:\\r\\n            return\\r\\n        self._inorder_traversal(node.left, result)  # 遍历左子树\\r\\n        result.append(node.val)  # 访问当前节点\\r\\n        self._inorder_traversal(node.right, result)  # 遍历右子树\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### **图**\\r\\n\\r\\n#### **最短路径问题**\\r\\n\\r\\n在加权图中，计算从一个节点到其他所有节点的最短路径。\\r\\n\\r\\n- **Bellman-Ford** 用于计算单源最短路径，支持负权边，但不能处理负权环。时间复杂度为$O(nm)$。空间复杂度为$O(n)$。\\r\\n\\r\\n  ```python\\r\\n  def bellman_ford(n, edges, start):\\r\\n      # n: 节点数 (从 0 到 n-1)\\r\\n      # edges: 边列表 [(u, v, w), ...] 表示从 u 到 v 权重为 w\\r\\n      # start: 起点\\r\\n      INF = float('inf')\\r\\n      dist = [INF] * n\\r\\n      dist[start] = 0\\r\\n\\r\\n      # 松弛操作\\r\\n      for _ in range(n - 1):\\r\\n          for u, v, w in edges:\\r\\n              if dist[u] != INF and dist[u] + w < dist[v]:\\r\\n                  dist[v] = dist[u] + w\\r\\n\\r\\n      # 检查负权环\\r\\n      for u, v, w in edges:\\r\\n          if dist[u] != INF and dist[u] + w < dist[v]:\\r\\n              raise ValueError(\\\"Graph contains a negative-weight cycle\\\")\\r\\n\\r\\n      return dist\\r\\n  ```\\r\\n\\r\\n- **Dijkstra** 用于计算单源最短路径，只支持正权边，不能处理负权边和负权环。时间复杂度为$O((V+E)\\\\log V)$。空间复杂度为$O(V)$。\\r\\n\\r\\n  ```python\\r\\n  import heapq\\r\\n\\r\\n  def dijkstra(n, edges, start):\\r\\n      # n: 节点数 (从 0 到 n-1)\\r\\n      # edges: 邻接表 {u: [(v, w), ...]} 表示从 u 到 v 权重为 w\\r\\n      # start: 起点\\r\\n      INF = float('inf')\\r\\n      dist = [INF] * n\\r\\n      dist[start] = 0\\r\\n      pq = [(0, start)]  # (当前距离, 节点)\\r\\n\\r\\n      while pq:\\r\\n          current_dist, u = heapq.heappop(pq)\\r\\n          if current_dist > dist[u]:\\r\\n              continue\\r\\n          for v, w in edges.get(u, []):\\r\\n              if dist[u] + w < dist[v]:\\r\\n                  dist[v] = dist[u] + w\\r\\n                  heapq.heappush(pq, (dist[v], v))\\r\\n\\r\\n      return dist\\r\\n  ```\\r\\n\\r\\n- **Floyd-Warshall** 用于计算任意两节点的最短路径，支持正负权边，不能处理负权环。时间复杂度为$O(V^3)$。空间复杂度为$O(V^2)$。\\r\\n\\r\\n  ```python\\r\\n  def floyd_warshall(n, edges):\\r\\n      # n: 节点数 (从 0 到 n-1)\\r\\n      INF = float('inf')\\r\\n      dist = [[INF] * n for _ in range(n)]\\r\\n      for u, v, w in edges:\\r\\n          dist[u][v] = w\\r\\n      for k in range(n):\\r\\n          for i in range(n):\\r\\n              for j in range(n):\\r\\n                  dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\\r\\n      return dist\\r\\n  ```\\r\\n\\r\\n#### **最小生成树问题**\\r\\n\\r\\n在无向加权图中，找到一个包含所有节点的最小权重的生成树。\\r\\n\\r\\n- **Prim** 用于计算最小生成树，支持正负权边，不能处理负权环。时间复杂度$O(E\\\\log V)$,空间复杂度为$O(E)$\\r\\n\\r\\n  ```python\\r\\n  import heapq\\r\\n\\r\\n  def prim(n, edges):\\r\\n      # n: 节点数 (从 0 到 n-1)\\r\\n      # edges: 邻接表 {u: [(v, w), ...]} 表示从 u 到 v 权重为 w\\r\\n      INF = float('inf')\\r\\n      visited = [False] * n\\r\\n      mst_weight = 0\\r\\n      pq = [(0, 0)]  # (权重, 节点)\\r\\n\\r\\n      while pq:\\r\\n          weight, u = heapq.heappop(pq)\\r\\n          if visited[u]:\\r\\n              continue\\r\\n          visited[u] = True\\r\\n          mst_weight += weight\\r\\n          for v, w in edges.get(u, []):\\r\\n              if not visited[v]:\\r\\n                  heapq.heappush(pq, (w, v))\\r\\n\\r\\n      return mst_weight\\r\\n  ```\\r\\n  \\r\\n- **Kruskal** 用于计算最小生成树，支持正负权边，不能处理负权环。时间复杂度$O(E\\\\log E)$,空间复杂度为$O(E+V)$\\r\\n\\r\\n  ```python\\r\\n  class UnionFind:\\r\\n    def __init__(self, n):\\r\\n        self.parent = list(range(n))\\r\\n        self.rank = [0] * n\\r\\n\\r\\n    def find(self, x):\\r\\n        if self.parent[x] != x:\\r\\n            self.parent[x] = self.find(self.parent[x])\\r\\n        return self.parent[x]\\r\\n\\r\\n    def union(self, x, y):\\r\\n        root_x = self.find(x)\\r\\n        root_y = self.find(y)\\r\\n        if root_x != root_y:\\r\\n            if self.rank[root_x] > self.rank[root_y]:\\r\\n                self.parent[root_y] = root_x\\r\\n            elif self.rank[root_x] < self.rank[root_y]:\\r\\n                self.parent[root_x] = root_y\\r\\n            else:\\r\\n                self.parent[root_y] = root_x\\r\\n                self.rank[root_x] += 1\\r\\n            return True\\r\\n        return False\\r\\n\\r\\n  def kruskal(n, edges):\\r\\n      # n: 节点数 (从 0 到 n-1)\\r\\n      # edges: 边列表 [(u, v, w), ...] 表示从 u 到 v 权重为 w\\r\\n      edges.sort(key=lambda x: x[2])  # 按权重排序\\r\\n      uf = UnionFind(n)\\r\\n      mst_weight = 0\\r\\n      for u, v, w in edges:\\r\\n          if uf.union(u, v):\\r\\n              mst_weight += w\\r\\n      return mst_weight\\r\\n  ```\\r\\n\\r\\n#### **最长路径问题**\\r\\n\\r\\n在加权图中，计算从起点到终点的最长路径。\\r\\n  \\r\\n```python\\r\\ndef bellman_ford_longest_path(n, edges, start):\\r\\n\\\"\\\"\\\"\\r\\n使用 Bellman-Ford 算法求解最长路径。\\r\\n\\r\\n参数:\\r\\n    n: 节点数量 (从 0 到 n-1)。\\r\\n    edges: 边列表 [(u, v, w), ...] 表示从 u 到 v 权重为 w。\\r\\n    start: 起点。\\r\\n\\r\\n返回:\\r\\n    dist: 每个节点的最长路径距离。\\r\\n\\\"\\\"\\\"\\r\\nINF = float('inf')\\r\\ndist = [-INF] * n  # 初始化为负无穷\\r\\ndist[start] = 0\\r\\n\\r\\n# Bellman-Ford 核心逻辑\\r\\nfor _ in range(n - 1):  # 迭代 n-1 次\\r\\n    for u, v, w in edges:\\r\\n        if dist[u] != -INF and dist[u] - w > dist[v]:  # 注意这里是减号\\r\\n            dist[v] = dist[u] - w\\r\\n\\r\\n# 检查是否存在正权环\\r\\nfor u, v, w in edges:\\r\\n    if dist[u] != -INF and dist[u] - w > dist[v]:\\r\\n        raise ValueError(\\\"Graph contains a positive-weight cycle\\\")\\r\\n\\r\\n# 将结果取反，得到最长路径\\r\\nreturn [-d for d in dist]\\r\\n```\\r\\n\\r\\n#### **图中判环问题**\\r\\n\\r\\n在有向加权图中，判断是否存在环。时间复杂度为$O(V+E)$，空间复杂度为$O(V)$。\\r\\n\\r\\n```python\\r\\ndef has_cycle(graph):\\r\\n    \\\"\\\"\\\"\\r\\n    使用三色法检测有向图中是否存在环。\\r\\n\\r\\n    参数:\\r\\n        graph: 邻接表表示的图，类型为 dict 或 defaultdict(list)，例如 {0: [1, 2], 1: [2], 2: []}。\\r\\n\\r\\n    返回:\\r\\n        bool: 如果图中存在环返回 True，否则返回 False。\\r\\n    \\\"\\\"\\\"\\r\\n    WHITE, GRAY, BLACK = 0, 1, 2  # 定义三种颜色状态\\r\\n    color = [WHITE] * len(graph)  # 初始化所有节点为白色\\r\\n\\r\\n    def dfs(node):\\r\\n        if color[node] == GRAY:  # 如果遇到灰色节点，说明存在环\\r\\n            return True\\r\\n        if color[node] == BLACK:  # 如果是黑色节点，无需继续访问\\r\\n            return False\\r\\n        \\r\\n        color[node] = GRAY  # 标记当前节点为灰色\\r\\n        for neighbor in graph[node]:  # 遍历邻接节点\\r\\n            if dfs(neighbor):  # 如果发现环，直接返回 True\\r\\n                return True\\r\\n        color[node] = BLACK  # 标记当前节点为黑色\\r\\n        return False\\r\\n\\r\\n    # 遍历每个节点，检查是否有环\\r\\n    for node in range(len(graph)):\\r\\n        if color[node] == WHITE and dfs(node):\\r\\n            return True  # 存在环\\r\\n\\r\\n    return False  # 无环\\r\\n```\\r\\n\\r\\n#### **图中最大环问题**\\r\\n\\r\\n```python\\r\\nfrom collections import defaultdict\\r\\n\\r\\ndef find_largest_cycle(graph):\\r\\n    \\\"\\\"\\\"\\r\\n    使用三色标记法找到图中的最大环。\\r\\n\\r\\n    参数:\\r\\n        graph: 邻接表表示的图，类型为 dict 或 defaultdict(list)。\\r\\n    \\r\\n    返回:\\r\\n        list: 最大环的节点列表。如果没有环，返回空列表。\\r\\n    \\\"\\\"\\\"\\r\\n    WHITE, GRAY, BLACK = 0, 1, 2  # 定义三种颜色状态\\r\\n    color = [WHITE] * len(graph)  # 初始化所有节点为白色\\r\\n    max_cycle = []  # 记录最大环\\r\\n\\r\\n    def dfs(node, path):\\r\\n        nonlocal max_cycle\\r\\n        if color[node] == GRAY:  # 发现环\\r\\n            cycle_start = path.index(node)\\r\\n            cycle = path[cycle_start:]\\r\\n            if len(cycle) > len(max_cycle):  # 更新最大环\\r\\n                max_cycle = cycle\\r\\n            return\\r\\n        \\r\\n        if color[node] == BLACK:  # 已经处理过的节点，无需再访问\\r\\n            return\\r\\n        \\r\\n        color[node] = GRAY  # 标记为灰色\\r\\n        path.append(node)  # 将当前节点加入路径\\r\\n        for neighbor in graph[node]:\\r\\n            dfs(neighbor, path)  # 递归访问邻接节点\\r\\n        path.pop()  # 回溯，移除当前节点\\r\\n        color[node] = BLACK  # 标记为黑色\\r\\n\\r\\n    # 遍历每个节点，寻找最大环\\r\\n    for node in range(len(graph)):\\r\\n        if color[node] == WHITE:\\r\\n            dfs(node, [])\\r\\n    return max_cycle\\r\\n```\";"],"names":[],"sourceRoot":""}