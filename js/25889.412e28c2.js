"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[25889],{25889:function(n,r,s){s.r(r),r["default"]="## **9.4 窗口函数**\r\n\r\n**窗口函数**是一种强大的工具，用于在一组行上执行计算，同时保留每一行的独立性。窗口函数通过 `OVER` 子句定义计算范围。\r\n\r\n### **1. OVER 子句**\r\n\r\n`OVER` 子句用于指定窗口函数的分区和排序规则。\r\n\r\n**语法：**\r\n\r\n```sql\r\nfunction_name(column) OVER (PARTITION BY partition_column ORDER BY sort_column)\r\n```\r\n\r\n### **2. 常见窗口函数**\r\n\r\n- **ROW_NUMBER()**: 为每一行分配一个唯一的行号。\r\n- **RANK()**: 为每一行分配排名，相同值的行具有相同的排名，但排名可能不连续。\r\n- **DENSE_RANK()**: 类似于 `RANK()`，但排名是连续的。\r\n\r\n**示例：**\r\n假设有一个销售表 `sales`，我们想为每个销售员按销售额排名。\r\n\r\n```sql\r\nSELECT \r\n    salesperson_id,\r\n    sale_amount,\r\n    ROW_NUMBER() OVER (PARTITION BY salesperson_id ORDER BY sale_amount DESC) AS row_num,\r\n    RANK() OVER (PARTITION BY salesperson_id ORDER BY sale_amount DESC) AS rank_num,\r\n    DENSE_RANK() OVER (PARTITION BY salesperson_id ORDER BY sale_amount DESC) AS dense_rank_num\r\nFROM sales;\r\n```\r\n\r\n### **3. 窗口函数的优点**\r\n\r\n- **灵活分组**：支持复杂的分组和排序规则。\r\n- **保持行独立性**：与聚合函数不同，窗口函数不会合并行。\r\n- **高性能**：避免了多次查询的需求。\r\n\r\n---"}}]);
//# sourceMappingURL=25889.412e28c2.js.map