"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[98915],{98915:function(r,n,i){i.r(n),n["default"]='## **1.排序算法**\r\n\r\n### **基于比较**\r\n\r\n#### <p style="text-align: center">冒泡排序</p>\r\n\r\n冒泡排序通过重复地交换相邻的未排序元素，将较大的元素逐步“冒泡”到数组末尾。\r\n\r\n```python\r\n\r\ndef bubble_sort(arr: List[int]):\r\n    n = len(arr)\r\n    for i in range(n - 1):  # 外层循环控制遍历次数\r\n        flag = False  # 标记是否发生交换\r\n        for j in range(n - 1 - i):  # 内层循环比较相邻元素\r\n            if arr[j] > arr[j + 1]:  # 如果前一个元素大于后一个元素，则交换\r\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\r\n                flag = True  # 发生了交换\r\n        if not flag:  # 如果没有发生交换，说明已经有序，提前退出\r\n            break\r\n```\r\n\r\n---\r\n\r\n#### <p style="text-align: center">选择排序</p>\r\n\r\n选择排序每次从未排序部分中找到最小值，并将其放到已排序部分的末尾。\r\n\r\n```python\r\ndef selection_sort(arr: List[int]):\r\n    n = len(arr)\r\n    for i in range(n - 1):  # 外层循环控制已排序部分的末尾\r\n        min_index = i  # 假设当前索引为最小值索引\r\n        for j in range(i + 1, n):  # 内层循环寻找未排序部分的最小值\r\n            if arr[j] < arr[min_index]:\r\n                min_index = j\r\n        if min_index != i:  # 如果找到了更小的值，则交换\r\n            arr[i], arr[min_index] = arr[min_index], arr[i]\r\n```\r\n\r\n---\r\n\r\n#### <p style="text-align: center">快速排序</p>\r\n\r\n快速排序基于分治思想，通过选择一个基准值（pivot），将数组分为小于基准值和大于基准值的两部分，递归处理。\r\n\r\n```python\r\ndef quick_sort(arr: List[int]):\r\n    def _quick_sort_helper(low: int, high: int):\r\n        if low >= high:  # 递归终止条件\r\n            return\r\n        \r\n        # 选择最后一个元素作为基准值\r\n        pivot = arr[high]\r\n        left = low  # 左指针从 low 开始\r\n        \r\n        for i in range(low, high):\r\n            if arr[i] < pivot:  # 如果当前元素小于基准值\r\n                arr[left], arr[i] = arr[i], arr[left]  # 将其交换到左侧\r\n                left += 1  # 左指针右移\r\n        \r\n        # 将基准值放到正确位置\r\n        arr[left], arr[high] = arr[high], arr[left]\r\n        \r\n        # 递归处理左半部分和右半部分\r\n        _quick_sort_helper(low, left - 1)\r\n        _quick_sort_helper(left + 1, high)\r\n\r\n    _quick_sort_helper(0, len(arr) - 1)\r\n```\r\n\r\n---\r\n\r\n#### <p style="text-align: center">插入排序</p>\r\n\r\n插入排序通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\r\n\r\n```python\r\ndef insertion_sort(arr: List[int]):\r\n    n = len(arr)\r\n    for i in range(1, n):  # 从第二个元素开始，逐步插入到已排序部分\r\n        key = arr[i]  # 当前待插入的元素\r\n        j = i - 1\r\n        while j >= 0 and arr[j] > key:  # 在已排序部分中找到插入位置\r\n            arr[j + 1] = arr[j]\r\n            j -= 1\r\n        arr[j + 1] = key  # 插入到正确位置\r\n```\r\n\r\n---\r\n\r\n#### <p style="text-align: center">堆排序</p>\r\n\r\n堆排序利用堆这种数据结构设计的一种排序算法，堆是一个近似完全二叉树的结构。\r\n\r\n```python\r\ndef heap_sort(arr: List[int]):\r\n    def heapify(arr: List[int], n: int, i: int):\r\n        largest = i  # 初始化最大值为根节点\r\n        left = 2 * i + 1  # 左子节点\r\n        right = 2 * i + 2  # 右子节点\r\n        if left < n and arr[left] > arr[largest]:  # 如果左子节点大于根节点\r\n            largest = left\r\n        if right < n and arr[right] > arr[largest]:  # 如果右子节点大于当前最大值\r\n            largest = right\r\n        if largest != i:  # 如果最大值不是根节点，交换并递归调整\r\n            arr[i], arr[largest] = arr[largest], arr[i]\r\n            heapify(arr, n, largest)\r\n\r\n    n = len(arr)\r\n    # 构建最大堆\r\n    for i in range(n // 2 - 1, -1, -1):\r\n        heapify(arr, n, i)\r\n    # 逐个提取元素\r\n    for i in range(n - 1, 0, -1):\r\n        arr[0], arr[i] = arr[i], arr[0]  # 将最大值放到末尾\r\n        heapify(arr, i, 0)  # 调整剩余部分为最大堆\r\n```\r\n\r\n---\r\n\r\n#### <p style="text-align: center">归并排序</p>\r\n\r\n归并排序采用分治法，将数组分成两部分分别排序，然后合并两个有序数组。\r\n\r\n```python\r\ndef merge_sort(arr: List[int]):\r\n    def _merge(left: List[int], right: List[int]) -> List[int]:\r\n        result = []\r\n        i = j = 0\r\n        while i < len(left) and j < len(right):  # 合并两个有序数组\r\n            if left[i] <= right[j]:\r\n                result.append(left[i])\r\n                i += 1\r\n            else:\r\n                result.append(right[j])\r\n                j += 1\r\n        result.extend(left[i:])  # 添加剩余元素\r\n        result.extend(right[j:])\r\n        return result\r\n\r\n    if len(arr) <= 1:  # 递归终止条件\r\n        return arr\r\n    mid = len(arr) // 2\r\n    left_half = merge_sort(arr[:mid])  # 递归排序左半部分\r\n    right_half = merge_sort(arr[mid:])  # 递归排序右半部分\r\n    return _merge(left_half, right_half)  # 合并两个有序部分\r\n```\r\n\r\n---\r\n\r\n### **不基于比较**\r\n\r\n#### <p style="text-align: center">计数排序</p>\r\n\r\n```python\r\ndef counting_sort(arr: List[int]) -> List[int]:\r\n    if not arr:\r\n        return arr  # 如果数组为空，直接返回\r\n    \r\n    # 找到数组中的最大值和最小值\r\n    max_val = max(arr)\r\n    min_val = min(arr)\r\n    \r\n    # 创建计数数组，长度为 max_val - min_val + 1\r\n    count = [0] * (max_val - min_val + 1)\r\n    \r\n    # 统计每个元素出现的次数\r\n    for num in arr:\r\n        count[num - min_val] += 1\r\n    \r\n    # 根据计数数组重新填充原数组\r\n    index = 0\r\n    for i, cnt in enumerate(count):\r\n        while cnt > 0:\r\n            arr[index] = i + min_val\r\n            index += 1\r\n            cnt -= 1\r\n    \r\n    return arr\r\n```\r\n\r\n#### <p style="text-align: center">基数排序</p>\r\n\r\n```python\r\ndef radix_sort(arr: List[int]) -> List[int]:\r\n    if not arr:\r\n        return arr  # 如果数组为空，直接返回\r\n    \r\n    # 获取数组中的最大值，确定最大位数\r\n    max_num = max(arr)\r\n    max_digits = len(str(abs(max_num)))  # 最大数字的位数\r\n    \r\n    # 辅助函数：按某一位进行计数排序\r\n    def counting_sort_by_digit(arr: List[int], digit: int) -> List[int]:\r\n        buckets = [[] for _ in range(10)]  # 创建 10 个桶\r\n        \r\n        # 将元素分配到桶中\r\n        for num in arr:\r\n            bucket_index = (num // (10 ** digit)) % 10\r\n            buckets[bucket_index].append(num)\r\n        \r\n        # 将桶中的元素按顺序合并回原数组\r\n        index = 0\r\n        for bucket in buckets:\r\n            for num in bucket:\r\n                arr[index] = num\r\n                index += 1\r\n        \r\n        return arr\r\n    \r\n    # 对每一位进行排序\r\n    for digit in range(max_digits):\r\n        arr = counting_sort_by_digit(arr, digit)\r\n    \r\n    return arr\r\n```\r\n\r\n### **排序算法时间与空间复杂度对比**\r\n\r\n**参数说明**\r\n\r\n1. **$n$**：数组长度。\r\n2. **$k$**：数据范围（如计数排序中的最大值）。\r\n3. **$d$**：数字的最大位数（如基数排序中需要处理的位数）。\r\n\r\n| 排序算法         | 最好时间复杂度       | 平均时间复杂度       | 最坏时间复杂度       | 空间复杂度       | 稳定性   |\r\n|------------------|---------------------|---------------------|---------------------|-----------------|----------|\r\n| **冒泡排序**     | $O(n)$             | $O(n^2)$           | $O(n^2)$           | $O(1)$          | 稳定     |\r\n| **选择排序**     | $O(n^2)$           | $O(n^2)$           | $O(n^2)$           | $O(1)$          | 不稳定   |\r\n| **插入排序**     | $O(n)$             | $O(n^2)$           | $O(n^2)$           | $O(1)$          | 稳定     |\r\n| **快速排序**     | $O(n \\log n)$      | $O(n \\log n)$      | $O(n^2)$           | $O(\\log n)$     | 不稳定   |\r\n| **归并排序**     | $O(n \\log n)$      | $O(n \\log n)$      | $O(n \\log n)$      | $O(n)$          | 稳定     |\r\n| **堆排序**       | $O(n \\log n)$      | $O(n \\log n)$      | $O(n \\log n)$      | $O(1)$          | 不稳定   |\r\n| **计数排序**     | $O(n + k)$         | $O(n + k)$         | $O(n + k)$         | $O(k)$          | 稳定     |\r\n| **基数排序**     | $O(d \\cdot (n + k))$ | $O(d \\cdot (n + k))$ | $O(d \\cdot (n + k))$ | $O(n + k)$    | 稳定     |'}}]);
//# sourceMappingURL=98915.9dae48cf.js.map