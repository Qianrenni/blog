"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[5417],{15417:function(n,r,a){a.r(r),r["default"]='## **一、Java 8 及以后的新特性**\r\n\r\n### **1. Lambda 表达式**\r\n\r\nLambda 表达式是 Java 8 中最重要的特性之一，它简化了匿名类的使用，使代码更加简洁和易读。Lambda 表达式用于实现函数式接口（只有一个抽象方法的接口）。\r\n\r\n#### **语法：**\r\n\r\n```java\r\n(parameters) -> expression\r\n```\r\n\r\n#### **示例：**\r\n\r\n```java\r\n// 使用匿名类实现 Runnable 接口\r\nRunnable r1 = new Runnable() {\r\n    @Override\r\n    public void run() {\r\n        System.out.println("Hello, World!");\r\n    }\r\n};\r\n\r\n// 使用 Lambda 表达式实现\r\nRunnable r2 = () -> System.out.println("Hello, World!");\r\n\r\n// 调用\r\nr1.run(); // 输出: Hello, World!\r\nr2.run(); // 输出: Hello, World!\r\n```\r\n\r\n#### **优势：**\r\n\r\n- 减少样板代码。\r\n- 提高代码可读性。\r\n- 支持函数式编程风格。\r\n\r\n---\r\n\r\n### **2. 函数式接口（`@FunctionalInterface`）**\r\n\r\n函数式接口是指仅包含一个抽象方法的接口。可以使用 `@FunctionalInterface` 注解来标记这样的接口。Lambda 表达式只能用于实现函数式接口。\r\n\r\n#### **示例：**\r\n\r\n```java\r\n@FunctionalInterface\r\ninterface MyFunction {\r\n    int apply(int a, int b);\r\n}\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        // 使用 Lambda 表达式实现函数式接口\r\n        MyFunction add = (a, b) -> a + b;\r\n        System.out.println(add.apply(3, 5)); // 输出: 8\r\n    }\r\n}\r\n```\r\n\r\n#### **常见函数式接口：**\r\n\r\n- `java.util.function.Function<T, R>`：将输入 T 转换为输出 R。\r\n- `java.util.function.Consumer<T>`：对输入 T 执行操作，无返回值。\r\n- `java.util.function.Predicate<T>`：判断条件是否满足，返回布尔值。\r\n- `java.util.function.Supplier<T>`：提供一个 T 类型的结果。\r\n\r\n---\r\n\r\n### **3. Stream API**\r\n\r\nStream API 是 Java 8 引入的一个强大的工具，用于处理集合数据。它可以进行过滤、映射、归约等操作，并支持链式调用。\r\n\r\n#### **核心概念：**\r\n\r\n- **流（Stream）**：表示一系列元素的序列，支持聚合操作。\r\n- **中间操作**：如 `filter`、`map`、`sorted`，返回新的流。\r\n- **终端操作**：如 `forEach`、`collect`、`reduce`，触发实际计算并结束流。\r\n\r\n#### **示例：**\r\n\r\n```java\r\nList<String> names = Arrays.asList("Alice", "Bob", "Charlie");\r\n\r\n// 过滤名字长度大于 3 的元素，并转换为大写\r\nList<String> result = names.stream()\r\n        .filter(name -> name.length() > 3)\r\n        .map(String::toUpperCase)\r\n        .collect(Collectors.toList());\r\n\r\nSystem.out.println(result); // 输出: [ALICE, CHARLIE]\r\n```\r\n\r\n#### **优势：**\r\n\r\n- 提供声明式编程风格。\r\n- 支持并行流（`parallelStream`），提高性能。\r\n- 简化集合操作。\r\n\r\n---\r\n\r\n### **4. 默认方法与静态方法在接口中的使用**\r\n\r\nJava 8 允许在接口中定义默认方法和静态方法，避免修改现有实现类时破坏代码。\r\n\r\n#### **默认方法：**\r\n\r\n```java\r\ninterface MyInterface {\r\n    default void sayHello() {\r\n        System.out.println("Hello from default method!");\r\n    }\r\n}\r\n\r\nclass MyClass implements MyInterface {}\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        MyClass obj = new MyClass();\r\n        obj.sayHello(); // 输出: Hello from default method!\r\n    }\r\n}\r\n```\r\n\r\n#### **静态方法：**\r\n\r\n```java\r\ninterface MyInterface {\r\n    static void sayHi() {\r\n        System.out.println("Hi from static method!");\r\n    }\r\n}\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        MyInterface.sayHi(); // 输出: Hi from static method!\r\n    }\r\n}\r\n```\r\n\r\n#### **用途：**\r\n\r\n- 向后兼容：在不破坏现有实现的情况下扩展接口功能。\r\n- 提供通用方法实现。\r\n\r\n---\r\n\r\n### **5. Optional 类的使用**\r\n\r\n`Optional` 是一个容器类，用于避免空指针异常（`NullPointerException`）。它表示一个值可能存在或不存在。\r\n\r\n#### **常用方法：**\r\n\r\n- `Optional.of(T value)`：创建非空的 Optional。\r\n- `Optional.empty()`：创建空的 Optional。\r\n- `isPresent()`：检查是否有值。\r\n- `orElse(T other)`：如果为空，则返回指定值。\r\n- `ifPresent(Consumer<? super T> consumer)`：如果存在值，则执行操作。\r\n\r\n#### **示例：**\r\n\r\n```java\r\nOptional<String> optional = Optional.of("Hello");\r\noptional.ifPresent(System.out::println); // 输出: Hello\r\n\r\nOptional<String> empty = Optional.empty();\r\nSystem.out.println(empty.orElse("Default Value")); // 输出: Default Value\r\n```\r\n\r\n#### **优势：**\r\n\r\n- 明确表达可能为空的场景。\r\n- 减少空指针异常的风险。\r\n\r\n---'}}]);
//# sourceMappingURL=5417.80ad9e32.js.map