{"version":3,"file":"js/9081.4b9e87fb.js","mappings":"oHAAA,q8L","sources":["webpack://myblog/./src/assets/md/javascript/content/007-函数.md"],"sourcesContent":["export default \"## **函数**\\r\\n\\r\\n### **1. 函数声明：`function name() {}`**\\r\\n\\r\\n函数声明是定义函数的传统方式，使用 `function` 关键字定义一个具名函数。\\r\\n\\r\\n#### **基本语法**\\r\\n\\r\\n```javascript\\r\\nfunction 函数名(参数1, 参数2, ...) {\\r\\n    // 函数体\\r\\n}\\r\\n```\\r\\n\\r\\n#### **示例**\\r\\n\\r\\n```javascript\\r\\nfunction greet(name) {\\r\\n    console.log(`Hello, ${name}!`);\\r\\n}\\r\\n\\r\\ngreet(\\\"Alice\\\"); // 输出：Hello, Alice!\\r\\n```\\r\\n\\r\\n#### **特点**\\r\\n\\r\\n1. **提升（Hoisting）**：\\r\\n   - 函数声明会被提升到其所在作用域的顶部，因此可以在声明之前调用。\\r\\n\\r\\n     ```javascript\\r\\n     greet(\\\"Bob\\\"); // 输出：Hello, Bob!\\r\\n\\r\\n     function greet(name) {\\r\\n         console.log(`Hello, ${name}!`);\\r\\n     }\\r\\n     ```\\r\\n\\r\\n2. **命名清晰**：\\r\\n   - 函数声明具有名称，便于调试和阅读。\\r\\n\\r\\n3. **适合全局或长期存在的函数**：\\r\\n   - 如果需要在多个地方调用某个函数，推荐使用函数声明。\\r\\n\\r\\n---\\r\\n\\r\\n### **2. 函数表达式：`const fn = function() {}`**\\r\\n\\r\\n函数表达式是将函数赋值给变量的方式，通常被称为匿名函数（没有名字的函数）。\\r\\n\\r\\n#### **基本语法**\\r\\n\\r\\n```javascript\\r\\nconst 变量名 = function(参数1, 参数2, ...) {\\r\\n    // 函数体\\r\\n};\\r\\n```\\r\\n\\r\\n#### **示例**\\r\\n\\r\\n```javascript\\r\\nconst greet = function(name) {\\r\\n    console.log(`Hello, ${name}!`);\\r\\n};\\r\\n\\r\\ngreet(\\\"Charlie\\\"); // 输出：Hello, Charlie!\\r\\n```\\r\\n\\r\\n#### **特点**\\r\\n\\r\\n1. **无提升**：\\r\\n   - 函数表达式不会被提升，必须在定义之后才能调用。\\r\\n\\r\\n     ```javascript\\r\\n     greet(\\\"David\\\"); // 报错：Cannot access 'greet' before initialization\\r\\n\\r\\n     const greet = function(name) {\\r\\n         console.log(`Hello, ${name}!`);\\r\\n     };\\r\\n     ```\\r\\n\\r\\n2. **灵活性高**：\\r\\n   - 可以动态创建函数，适用于需要根据条件生成不同函数的场景。\\r\\n\\r\\n3. **常用于回调函数**：\\r\\n   - 函数表达式适合作为参数传递给其他函数。\\r\\n\\r\\n---\\r\\n\\r\\n### **3. 箭头函数：`() => {}`**\\r\\n\\r\\n箭头函数是 ES6 引入的简洁语法，用于定义匿名函数。它的语法更简洁，并且有独特的 `this` 绑定规则。\\r\\n\\r\\n#### **基本语法**\\r\\n\\r\\n```javascript\\r\\nconst 函数名 = (参数1, 参数2, ...) => {\\r\\n    // 函数体\\r\\n};\\r\\n```\\r\\n\\r\\n#### **示例**\\r\\n\\r\\n```javascript\\r\\nconst greet = (name) => {\\r\\n    console.log(`Hello, ${name}!`);\\r\\n};\\r\\n\\r\\ngreet(\\\"Eve\\\"); // 输出：Hello, Eve!\\r\\n```\\r\\n\\r\\n#### **简化写法**\\r\\n\\r\\n1. **单个参数时省略括号**：\\r\\n\\r\\n   ```javascript\\r\\n   const square = x => x * x;\\r\\n   console.log(square(5)); // 输出：25\\r\\n   ```\\r\\n\\r\\n2. **无需大括号和 `return` 的单行函数**：\\r\\n\\r\\n   ```javascript\\r\\n   const add = (a, b) => a + b;\\r\\n   console.log(add(2, 3)); // 输出：5\\r\\n   ```\\r\\n\\r\\n#### **特点**\\r\\n\\r\\n1. **`this` 绑定**：\\r\\n   - 箭头函数没有自己的 `this`，而是继承自外层作用域。\\r\\n\\r\\n     ```javascript\\r\\n     const obj = {\\r\\n         value: 42,\\r\\n         regularFunction: function() {\\r\\n             console.log(this.value); // 输出：42\\r\\n         },\\r\\n         arrowFunction: () => {\\r\\n             console.log(this.value); // 输出：undefined（箭头函数的 this 指向定义时的上下文）\\r\\n         }\\r\\n     };\\r\\n\\r\\n     obj.regularFunction(); // 输出：42\\r\\n     obj.arrowFunction();   // 输出：undefined\\r\\n     ```\\r\\n\\r\\n   - 适合处理不需要绑定 `this` 的场景，如事件处理器或回调函数。\\r\\n\\r\\n2. **不能用作构造函数**：\\r\\n   - 箭头函数不能使用 `new` 关键字调用。\\r\\n\\r\\n     ```javascript\\r\\n     const Fn = () => {};\\r\\n     new Fn(); // 报错：Fn is not a constructor\\r\\n     ```\\r\\n\\r\\n3. **没有 `arguments` 对象**：\\r\\n   - 箭头函数中无法直接使用 `arguments`，但可以通过剩余参数（`...args`）替代。\\r\\n\\r\\n     ```javascript\\r\\n     const fn = (...args) => {\\r\\n         console.log(args);\\r\\n     };\\r\\n     fn(1, 2, 3); // 输出：[1, 2, 3]\\r\\n     ```\\r\\n\\r\\n---\\r\\n\\r\\n### **4. 参数处理**\\r\\n\\r\\nJavaScript 提供了多种灵活的方式来处理函数参数。\\r\\n\\r\\n#### **默认参数**\\r\\n\\r\\n- 允许为参数指定默认值，当调用函数时未传递参数或传递 `undefined` 时，使用默认值。\\r\\n\\r\\n  ```javascript\\r\\n  function greet(name = \\\"Guest\\\") {\\r\\n      console.log(`Hello, ${name}!`);\\r\\n  }\\r\\n\\r\\n  greet();          // 输出：Hello, Guest!\\r\\n  greet(\\\"Alice\\\");   // 输出：Hello, Alice!\\r\\n  greet(undefined); // 输出：Hello, Guest!\\r\\n  ```\\r\\n\\r\\n#### **剩余参数（`...args`）**\\r\\n\\r\\n- 使用剩余参数可以接收不定数量的参数，并将其存储为数组。\\r\\n\\r\\n  ```javascript\\r\\n  function sum(...numbers) {\\r\\n      return numbers.reduce((acc, num) => acc + num, 0);\\r\\n  }\\r\\n\\r\\n  console.log(sum(1, 2, 3));       // 输出：6\\r\\n  console.log(sum(10, 20, 30, 40)); // 输出：100\\r\\n  ```\\r\\n\\r\\n#### **解构参数**\\r\\n\\r\\n- 可以直接在函数参数中解构对象或数组。\\r\\n\\r\\n  ```javascript\\r\\n  function printUser({ name, age }) {\\r\\n      console.log(`Name: ${name}, Age: ${age}`);\\r\\n  }\\r\\n\\r\\n  const user = { name: \\\"Alice\\\", age: 25 };\\r\\n  printUser(user); // 输出：Name: Alice, Age: 25\\r\\n  ```\\r\\n\\r\\n---\\r\\n\\r\\n### **5. 返回值：`return`**\\r\\n\\r\\n函数可以通过 `return` 语句返回值。如果函数没有显式返回值，则默认返回 `undefined`。\\r\\n\\r\\n#### **示例**\\r\\n\\r\\n```javascript\\r\\nfunction multiply(a, b) {\\r\\n    return a * b;\\r\\n}\\r\\n\\r\\nconsole.log(multiply(3, 4)); // 输出：12\\r\\n```\\r\\n\\r\\n#### **注意事项**\\r\\n\\r\\n1. **提前返回**：\\r\\n   - 使用 `return` 可以提前结束函数执行，避免不必要的代码运行。\\r\\n\\r\\n     ```javascript\\r\\n     function checkNumber(num) {\\r\\n         if (num < 0) {\\r\\n             return \\\"Negative\\\";\\r\\n         }\\r\\n         return \\\"Non-negative\\\";\\r\\n     }\\r\\n\\r\\n     console.log(checkNumber(-5));  // 输出：Negative\\r\\n     console.log(checkNumber(10));  // 输出：Non-negative\\r\\n     ```\\r\\n\\r\\n2. **隐式返回**：\\r\\n   - 箭头函数支持隐式返回，适合简单逻辑。\\r\\n\\r\\n     ```javascript\\r\\n     const double = x => x * 2;\\r\\n     console.log(double(5)); // 输出：10\\r\\n     ```\\r\\n\\r\\n---\\r\\n\\r\\n### **6. 高阶函数：回调函数、闭包等概念**\\r\\n\\r\\n#### **高阶函数**\\r\\n\\r\\n高阶函数是指接受函数作为参数或将函数作为返回值的函数。\\r\\n\\r\\n1. **回调函数**：\\r\\n   - 将函数作为参数传递给另一个函数。\\r\\n\\r\\n     ```javascript\\r\\n     function calculate(a, b, operation) {\\r\\n         return operation(a, b);\\r\\n     }\\r\\n\\r\\n     const add = (x, y) => x + y;\\r\\n     const subtract = (x, y) => x - y;\\r\\n\\r\\n     console.log(calculate(10, 5, add));      // 输出：15\\r\\n     console.log(calculate(10, 5, subtract)); // 输出：5\\r\\n     ```\\r\\n\\r\\n2. **返回函数**：\\r\\n   - 函数可以返回另一个函数。\\r\\n\\r\\n     ```javascript\\r\\n     function createMultiplier(factor) {\\r\\n         return function(value) {\\r\\n             return value * factor;\\r\\n         };\\r\\n     }\\r\\n\\r\\n     const double = createMultiplier(2);\\r\\n     console.log(double(5)); // 输出：10\\r\\n     ```\\r\\n\\r\\n#### **闭包**\\r\\n\\r\\n闭包是指函数能够访问其外部作用域中的变量，即使外部函数已经执行完毕。\\r\\n\\r\\n**示例**：\\r\\n\\r\\n```javascript\\r\\nfunction outerFunction() {\\r\\n    let count = 0;\\r\\n    return function innerFunction() {\\r\\n        count++;\\r\\n        return count;\\r\\n    };\\r\\n}\\r\\n\\r\\nconst counter = outerFunction();\\r\\nconsole.log(counter()); // 输出：1\\r\\nconsole.log(counter()); // 输出：2\\r\\n```\";"],"names":[],"sourceRoot":""}