{"version":3,"file":"js/511.d8b24225.js","mappings":"mHAAA,22D","sources":["webpack://myblog/./src/assets/md/algorithm/content/015-7分支限界.md"],"sourcesContent":["export default \"## **7.分支限界**\\r\\n\\r\\n分支限界（Branch and Bound）是一种用于解决优化问题的算法，它通过在搜索树中剪枝来提高搜索效率。它通过在搜索过程中对搜索空间进行限制，从而减少搜索的分支数量，提高搜索效率。\\r\\n\\r\\n### **旅行商问题**\\r\\n\\r\\n```python\\r\\n\\r\\nimport heapq\\r\\ndef tsp_branch_and_bound(adjacency_matrix):\\r\\n    n = len(adjacency_matrix)\\r\\n    pq = []  # 优先队列\\r\\n    best_cost = math.inf  # 最优解的初始值为无穷大\\r\\n    best_path = None\\r\\n    # 初始化根节点\\r\\n    root_path = [0]  # 从城市0开始\\r\\n    root_cost = 0\\r\\n    root_bound = 0  # 初始下界设为0\\r\\n    root_set=set([i for i in range(1,n)])\\r\\n    heapq.heappush(pq, (root_bound, root_cost, root_path,root_set))\\r\\n    while pq:\\r\\n        bound, cost, path,s = heapq.heappop(pq)\\r\\n        # 如果当前节点的下界大于等于已知最优解，则剪枝\\r\\n        if bound >= best_cost:\\r\\n            continue\\r\\n        # 扩展当前节点\\r\\n        last_city = path[-1]\\r\\n        for next_city in s:\\r\\n            new_path = path + [next_city]\\r\\n            new_cost = cost + adjacency_matrix[last_city][next_city]\\r\\n            new_set=copy.deepcopy(s)\\r\\n            new_set.remove(next_city)\\r\\n            # 计算新节点的下界\\r\\n            new_bound = new_cost\\r\\n            if len(new_path) == n - 1:\\r\\n                end = new_set.pop()\\r\\n                new_cost += adjacency_matrix[new_path[-1]][end]+adjacency_matrix[end][new_path[0]]\\r\\n                new_path.append(end)[new_path[0]]\\r\\n                if new_cost < best_cost:\\r\\n                    best_cost = new_cost\\r\\n                    best_path = new_path + [new_path[0]]\\r\\n            else:\\r\\n                for i in new_set:\\r\\n                    # 找到未访问城市的最小出边\\r\\n                    min_edge = min([adjacency_matrix[i][j] for j in new_set if j != i])\\r\\n                    new_bound += min_edge\\r\\n                # 将新节点加入优先队列\\r\\n                if new_bound < best_cost:\\r\\n                    heapq.heappush(pq, (new_bound, new_cost, new_path,new_set))\\r\\n    return best_path, best_cost\\r\\n```\";"],"names":[],"sourceRoot":""}