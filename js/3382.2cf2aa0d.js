"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[3382],{43382:function(n,r,a){a.r(r),r["default"]='# **二、面向对象编程（OOP）**\r\n\r\n以下是关于 **面向对象编程（OOP）** 各部分内容的详细介绍，涵盖了 Java 中的核心概念和实现方法。\r\n\r\n---\r\n\r\n## **1. 类与对象**\r\n\r\n### **1.1 类的定义与实例化**\r\n\r\n- **类的定义**：\r\n  - 类是面向对象编程的基本单元，用于描述具有相同属性和行为的对象。\r\n  - 定义格式：\r\n\r\n    ```java\r\n    public class ClassName {\r\n        // 成员变量\r\n        private String name;\r\n        private int age;\r\n\r\n        // 构造方法\r\n        public ClassName(String name, int age) {\r\n            this.name = name;\r\n            this.age = age;\r\n        }\r\n\r\n        // 成员方法\r\n        public void display() {\r\n            System.out.println("Name: " + name + ", Age: " + age);\r\n        }\r\n    }\r\n    ```\r\n\r\n- **实例化**：\r\n  - 创建类的对象称为实例化，使用 `new` 关键字完成。\r\n\r\n    ```java\r\n    ClassName obj = new ClassName("Alice", 25);\r\n    obj.display(); // 输出：Name: Alice, Age: 25\r\n    ```\r\n\r\n### **1.2 构造方法与重载**\r\n\r\n- **构造方法**：\r\n  - 构造方法用于初始化对象，方法名与类名相同，没有返回值。\r\n  - 如果未定义构造方法，编译器会提供一个默认的无参构造方法。\r\n\r\n    ```java\r\n    public class Person {\r\n        private String name;\r\n\r\n        // 无参构造方法\r\n        public Person() {}\r\n\r\n        // 带参构造方法\r\n        public Person(String name) {\r\n            this.name = name;\r\n        }\r\n    }\r\n    ```\r\n\r\n- **构造方法重载**：\r\n  - 可以定义多个构造方法，参数列表不同。\r\n\r\n    ```java\r\n    public class Person {\r\n        private String name;\r\n        private int age;\r\n\r\n        public Person() {}\r\n        public Person(String name) { this.name = name; }\r\n        public Person(String name, int age) {\r\n            this.name = name;\r\n            this.age = age;\r\n        }\r\n    }\r\n    ```\r\n\r\n### **1.3 成员变量与局部变量的区别**\r\n\r\n| 特性               | 成员变量                         | 局部变量                        |\r\n|--------------------|----------------------------------|---------------------------------|\r\n| **作用范围**       | 整个类                          | 方法或代码块中                 |\r\n| **存储位置**       | 堆内存                          | 栈内存                         |\r\n| **生命周期**       | 随对象创建而存在，随对象销毁而消失 | 随方法调用而存在，随方法结束而消失 |\r\n| **默认值**         | 有默认值（如 `int` 默认为 0）   | 必须显式初始化，否则无法使用   |\r\n\r\n---\r\n\r\n## **2. 封装**\r\n\r\n### **2.1 访问修饰符**\r\n\r\nJava 提供了四种访问修饰符，用于控制类、成员变量和方法的访问权限：\r\n\r\n- `private`：仅在当前类内可访问。\r\n- `protected`：在同一包内或子类中可访问。\r\n- `public`：任何地方都可访问。\r\n- **默认**（无修饰符）：同一包内可访问。\r\n\r\n示例：\r\n\r\n```java\r\npublic class Person {\r\n    private String name; // 私有变量\r\n\r\n    public String getName() { // Getter 方法\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) { // Setter 方法\r\n        this.name = name;\r\n    }\r\n}\r\n```\r\n\r\n### **2.2 Getter 和 Setter 方法**\r\n\r\n- **Getter 方法**：用于获取私有成员变量的值。\r\n- **Setter 方法**：用于设置私有成员变量的值。\r\n- 封装的好处：\r\n  - 保护数据，避免直接修改。\r\n  - 提供统一的访问接口。\r\n\r\n---\r\n\r\n## **3. 继承**\r\n\r\n### **3.1 继承的概念与实现**\r\n\r\n- **继承**是一种机制，允许一个类（子类）继承另一个类（父类）的属性和方法。\r\n- 使用 `extends` 关键字实现继承。\r\n- 示例：\r\n\r\n    ```java\r\n    public class Animal {\r\n        protected String name;\r\n\r\n        public void eat() {\r\n            System.out.println(name + " is eating.");\r\n        }\r\n    }\r\n\r\n    public class Dog extends Animal {\r\n        public void bark() {\r\n            System.out.println(name + " is barking.");\r\n        }\r\n    }\r\n    ```\r\n\r\n### **3.2 方法重写（@Override）**\r\n\r\n- 子类可以重写父类的方法，以实现不同的行为。\r\n- 使用 `@Override` 注解标记重写的方法。\r\n\r\n    ```java\r\n    public class Dog extends Animal {\r\n        @Override\r\n        public void eat() {\r\n            System.out.println(name + " is eating bones.");\r\n        }\r\n    }\r\n    ```\r\n\r\n### **3.3 super 关键字的使用**\r\n\r\n- `super` 用于引用父类的成员（变量、方法或构造方法）。\r\n- 示例：\r\n\r\n    ```java\r\n    public class Dog extends Animal {\r\n        public Dog(String name) {\r\n            super(); // 调用父类构造方法\r\n            this.name = name;\r\n        }\r\n\r\n        @Override\r\n        public void eat() {\r\n            super.eat(); // 调用父类方法\r\n            System.out.println(name + " is eating bones.");\r\n        }\r\n    }\r\n    ```\r\n\r\n---\r\n\r\n## **4. 多态**\r\n\r\n### **4.1 编译时多态（方法重载）**\r\n\r\n- 方法重载是指在同一个类中定义多个同名方法，但参数列表不同。\r\n- 示例：\r\n\r\n    ```java\r\n    public class Calculator {\r\n        public int add(int a, int b) {\r\n            return a + b;\r\n        }\r\n\r\n        public double add(double a, double b) {\r\n            return a + b;\r\n        }\r\n    }\r\n    ```\r\n\r\n### **4.2 运行时多态（方法重写）**\r\n\r\n- 运行时多态通过继承和方法重写实现。\r\n- 父类引用指向子类对象时，调用的方法由实际对象决定。\r\n\r\n    ```java\r\n    Animal animal = new Dog("Tom");\r\n    animal.eat(); // 输出：Tom is eating bones.\r\n    ```\r\n\r\n### **4.3 向上转型与向下转型**\r\n\r\n- **向上转型**：将子类对象赋值给父类引用（自动完成）。\r\n\r\n    ```java\r\n    Animal animal = new Dog("Tom"); // 向上转型\r\n    ```\r\n\r\n- **向下转型**：将父类引用强制转换为子类类型（需确保实际对象类型匹配）。\r\n\r\n    ```java\r\n    Dog dog = (Dog) animal; // 向下转型\r\n    ```\r\n\r\n---\r\n\r\n## **5. 抽象类与接口**\r\n\r\n### **5.1 抽象类的定义与使用**\r\n\r\n- 抽象类使用 `abstract` 关键字定义，不能实例化。\r\n- 包含抽象方法（无实现）和普通方法（有实现）。\r\n\r\n    ```java\r\n    public abstract class Shape {\r\n        public abstract void draw(); // 抽象方法\r\n\r\n        public void print() { // 普通方法\r\n            System.out.println("This is a shape.");\r\n        }\r\n    }\r\n    ```\r\n\r\n### **5.2 接口的定义与实现**\r\n\r\n- 接口使用 `interface` 关键字定义，包含抽象方法和默认方法。\r\n- 类通过 `implements` 实现接口。\r\n\r\n    ```java\r\n    public interface Drawable {\r\n        void draw(); // 抽象方法\r\n    }\r\n\r\n    public class Circle implements Drawable {\r\n        @Override\r\n        public void draw() {\r\n            System.out.println("Drawing a circle.");\r\n        }\r\n    }\r\n    ```\r\n\r\n### **5.3 抽象类与接口的区别**\r\n\r\n| 特性               | 抽象类                           | 接口                           |\r\n|--------------------|----------------------------------|--------------------------------|\r\n| **关键字**         | `abstract`                      | `interface`                   |\r\n| **成员变量**       | 可以有普通变量                  | 只能有常量（`final`）         |\r\n| **方法**           | 可以有普通方法和抽象方法         | 默认只有抽象方法（Java 8+ 支持默认方法） |\r\n| **继承方式**       | 单继承（只能继承一个抽象类）     | 多继承（可以实现多个接口）    |\r\n\r\n---\r\n\r\n## **6. 内部类**\r\n\r\n### **6.1 静态内部类**\r\n\r\n- 静态内部类属于外部类本身，不依赖外部类实例。\r\n\r\n    ```java\r\n    public class OuterClass {\r\n        static class StaticInnerClass {\r\n            public void display() {\r\n                System.out.println("Static Inner Class");\r\n            }\r\n        }\r\n    }\r\n    ```\r\n\r\n### **6.2 成员内部类**\r\n\r\n- 成员内部类属于外部类的实例，必须通过外部类实例访问。\r\n\r\n    ```java\r\n    public class OuterClass {\r\n        class MemberInnerClass {\r\n            public void display() {\r\n                System.out.println("Member Inner Class");\r\n            }\r\n        }\r\n    }\r\n    ```\r\n\r\n### **6.3 局部内部类**\r\n\r\n- 局部内部类定义在方法或代码块中，仅在该范围内有效。\r\n\r\n    ```java\r\n    public class OuterClass {\r\n        public void method() {\r\n            class LocalInnerClass {\r\n                public void display() {\r\n                    System.out.println("Local Inner Class");\r\n                }\r\n            }\r\n        }\r\n    }\r\n    ```\r\n\r\n### **6.4 匿名内部类**\r\n\r\n- 匿名内部类是没有名字的类，通常用于简化代码。\r\n\r\n    ```java\r\n    Runnable r = new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            System.out.println("Anonymous Inner Class");\r\n        }\r\n    };\r\n    ```\r\n\r\n---\r\n\r\n## **7. 枚举**\r\n\r\n### **7.1 枚举类型的定义与使用**\r\n\r\n- 枚举使用 `enum` 关键字定义，表示一组固定的常量。\r\n\r\n    ```java\r\n    public enum Day {\r\n        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\r\n    }\r\n    ```\r\n\r\n### **7.2 枚举与 `switch` 的结合**\r\n\r\n- 枚举可以与 `switch` 结合使用，增强代码的可读性。\r\n\r\n    ```java\r\n    public void printDay(Day day) {\r\n        switch (day) {\r\n            case MONDAY:\r\n                System.out.println("Start of the week");\r\n                break;\r\n            case FRIDAY:\r\n                System.out.println("End of the week");\r\n                break;\r\n            default:\r\n                System.out.println("Other day");\r\n        }\r\n    }\r\n    ```\r\n\r\n---'}}]);
//# sourceMappingURL=3382.2cf2aa0d.js.map