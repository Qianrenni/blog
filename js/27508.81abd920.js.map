{"version":3,"file":"js/27508.81abd920.js","mappings":"qHAAA,0xE","sources":["webpack://myblog/./src/assets/md/c-plus/content/029-2 多线程与并发.md"],"sourcesContent":["export default \"## **2. 多线程与并发**\\r\\n\\r\\nC++11 引入了 `<thread>` 头文件，支持多线程编程。以下是多线程与并发的核心概念。\\r\\n\\r\\n### **2.1 线程的创建与管理（`std::thread`）**\\r\\n- **创建线程**：\\r\\n  使用 `std::thread` 创建线程，并传递一个可调用对象（如函数或 Lambda 表达式）。\\r\\n  ```cpp\\r\\n  #include <iostream>\\r\\n  #include <thread>\\r\\n  using namespace std;\\r\\n\\r\\n  void threadFunction(int id) {\\r\\n      cout << \\\"Thread ID: \\\" << id << endl;\\r\\n  }\\r\\n\\r\\n  int main() {\\r\\n      thread t1(threadFunction, 1); // 创建线程\\r\\n      thread t2(threadFunction, 2);\\r\\n\\r\\n      t1.join(); // 等待线程 t1 完成\\r\\n      t2.join(); // 等待线程 t2 完成\\r\\n      return 0;\\r\\n  }\\r\\n  ```\\r\\n\\r\\n### **2.2 同步机制（`std::mutex`, `std::lock_guard`）**\\r\\n- **`std::mutex`**：\\r\\n  互斥锁用于保护共享资源，避免多个线程同时访问。\\r\\n  ```cpp\\r\\n  #include <iostream>\\r\\n  #include <thread>\\r\\n  #include <mutex>\\r\\n  using namespace std;\\r\\n\\r\\n  mutex mtx;\\r\\n\\r\\n  void increment(int& counter) {\\r\\n      lock_guard<mutex> lock(mtx); // 自动加锁和解锁\\r\\n      ++counter;\\r\\n  }\\r\\n\\r\\n  int main() {\\r\\n      int counter = 0;\\r\\n      thread t1(increment, ref(counter));\\r\\n      thread t2(increment, ref(counter));\\r\\n\\r\\n      t1.join();\\r\\n      t2.join();\\r\\n\\r\\n      cout << \\\"Counter: \\\" << counter << endl; // 输出：2\\r\\n      return 0;\\r\\n  }\\r\\n  ```\\r\\n\\r\\n### **2.3 条件变量与异步任务**\\r\\n- **条件变量**：\\r\\n  使用 `std::condition_variable` 实现线程间的同步。\\r\\n  ```cpp\\r\\n  #include <iostream>\\r\\n  #include <thread>\\r\\n  #include <mutex>\\r\\n  #include <condition_variable>\\r\\n  using namespace std;\\r\\n\\r\\n  mutex mtx;\\r\\n  condition_variable cv;\\r\\n  bool ready = false;\\r\\n\\r\\n  void worker() {\\r\\n      unique_lock<mutex> lock(mtx);\\r\\n      cv.wait(lock, [] { return ready; }); // 等待条件满足\\r\\n      cout << \\\"Worker thread is running\\\" << endl;\\r\\n  }\\r\\n\\r\\n  int main() {\\r\\n      thread t(worker);\\r\\n\\r\\n      {\\r\\n          lock_guard<mutex> lock(mtx);\\r\\n          ready = true;\\r\\n      }\\r\\n      cv.notify_one(); // 唤醒等待的线程\\r\\n\\r\\n      t.join();\\r\\n      return 0;\\r\\n  }\\r\\n  ```\\r\\n\\r\\n- **异步任务**：\\r\\n  使用 `std::async` 执行异步任务并获取结果。\\r\\n  ```cpp\\r\\n  #include <iostream>\\r\\n  #include <future>\\r\\n  using namespace std;\\r\\n\\r\\n  int compute() {\\r\\n      return 42;\\r\\n  }\\r\\n\\r\\n  int main() {\\r\\n      future<int> result = async(compute); // 异步执行 compute\\r\\n      cout << \\\"Result: \\\" << result.get() << endl; // 获取结果\\r\\n      return 0;\\r\\n  }\\r\\n  ```\\r\\n\\r\\n---\";"],"names":[],"sourceRoot":""}