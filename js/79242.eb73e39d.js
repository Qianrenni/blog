"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[79242],{79242:function(r,n,e){e.r(n),n["default"]='# **三、异常处理**\r\n\r\n## **1. 异常体系**\r\n\r\n### **1.1 异常分类**\r\n\r\nJava 中的异常分为两大类：`Checked Exception` 和 `Unchecked Exception`。\r\n\r\n#### **1.1.1 Checked Exception（受检异常）**\r\n\r\n- **定义**：\r\n  - 必须在编译时显式处理的异常。\r\n  - 如果方法可能抛出受检异常，则必须通过 `try-catch` 或 `throws` 声明进行处理。\r\n- **特点**：\r\n  - 继承自 `Exception` 类，但不包括 `RuntimeException` 及其子类。\r\n  - 通常表示可恢复的错误或外部资源问题（如文件读取失败、网络连接中断等）。\r\n- **常见类型**：\r\n  - `IOException`\r\n  - `SQLException`\r\n  - `FileNotFoundException`\r\n\r\n#### **1.1.2 Unchecked Exception（非受检异常）**\r\n\r\n- **定义**：\r\n  - 不需要在编译时显式处理的异常。\r\n  - 包括运行时异常（`RuntimeException`）和错误（`Error`）。\r\n- **特点**：\r\n  - 运行时异常通常由程序逻辑错误引起，难以预测。\r\n  - 错误（`Error`）是严重的系统级问题，一般无法恢复。\r\n- **常见类型**：\r\n  - **运行时异常**：\r\n    - `NullPointerException`：尝试访问空对象的方法或属性。\r\n    - `ArrayIndexOutOfBoundsException`：数组索引越界。\r\n    - `ArithmeticException`：除以零等算术错误。\r\n  - **错误**：\r\n    - `OutOfMemoryError`：内存不足。\r\n    - `StackOverflowError`：栈溢出。\r\n\r\n#### **1.1.3 异常层次结构**\r\n\r\n```plaintext\r\nThrowable\r\n├── Error (严重错误，不可恢复)\r\n│   ├── OutOfMemoryError\r\n│   ├── StackOverflowError\r\n├── Exception (可恢复的异常)\r\n│   ├── RuntimeException (非受检异常)\r\n│   │   ├── NullPointerException\r\n│   │   ├── ArrayIndexOutOfBoundsException\r\n│   │   ├── ArithmeticException\r\n│   ├── IOException (受检异常)\r\n│   │   ├── FileNotFoundException\r\n│   │   ├── SocketException\r\n```\r\n\r\n---\r\n\r\n## **2. 异常处理机制**\r\n\r\n### **2.1 try-catch-finally**\r\n\r\n- **作用**：\r\n  - 捕获并处理异常，防止程序崩溃。\r\n- **语法**：\r\n\r\n  ```java\r\n  try {\r\n      // 可能抛出异常的代码\r\n  } catch (ExceptionType e) {\r\n      // 处理异常\r\n  } finally {\r\n      // 无论是否发生异常都会执行的代码\r\n  }\r\n  ```\r\n\r\n- **特点**：\r\n  - `try` 块用于包裹可能抛出异常的代码。\r\n  - `catch` 块用于捕获并处理特定类型的异常。\r\n  - `finally` 块用于释放资源（如关闭文件流、数据库连接等），即使发生异常也会执行。\r\n\r\n#### **示例**\r\n\r\n```java\r\npublic class ExceptionHandlingExample {\r\n    public static void main(String[] args) {\r\n        try {\r\n            int result = 10 / 0; // 抛出 ArithmeticException\r\n        } catch (ArithmeticException e) {\r\n            System.out.println("Caught exception: " + e.getMessage());\r\n        } finally {\r\n            System.out.println("Finally block executed.");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n输出：\r\n\r\n```\r\nCaught exception: / by zero\r\nFinally block executed.\r\n```\r\n\r\n---\r\n\r\n### **2.2 throw 和 throws**\r\n\r\n#### **2.2.1 throw**\r\n\r\n- **作用**：\r\n  - 用于手动抛出异常。\r\n- **语法**：\r\n\r\n  ```java\r\n  throw new ExceptionType("Message");\r\n  ```\r\n\r\n- **示例**：\r\n\r\n  ```java\r\n  public void validateAge(int age) {\r\n      if (age < 18) {\r\n          throw new IllegalArgumentException("Age must be at least 18.");\r\n      }\r\n  }\r\n  ```\r\n\r\n#### **2.2.2 throws**\r\n\r\n- **作用**：\r\n  - 声明方法可能抛出的异常，将异常处理的责任交给调用者。\r\n- **语法**：\r\n\r\n  ```java\r\n  public void readFile() throws IOException {\r\n      FileReader file = new FileReader("test.txt");\r\n      // 文件操作\r\n  }\r\n  ```\r\n\r\n- **示例**：\r\n\r\n  ```java\r\n  public void processFile() throws IOException {\r\n      readFile();\r\n  }\r\n\r\n  public void readFile() throws IOException {\r\n      FileReader file = new FileReader("test.txt");\r\n      // 文件操作\r\n  }\r\n  ```\r\n\r\n---\r\n\r\n### **2.3 自定义异常**\r\n\r\n- **定义**：\r\n  - 创建自己的异常类，继承自 `Exception` 或 `RuntimeException`。\r\n- **语法**：\r\n\r\n  ```java\r\n  public class CustomException extends Exception {\r\n      public CustomException(String message) {\r\n          super(message);\r\n      }\r\n  }\r\n  ```\r\n\r\n- **示例**：\r\n\r\n  ```java\r\n  public class CustomExceptionExample {\r\n      public static void main(String[] args) {\r\n          try {\r\n              validateAge(15);\r\n          } catch (CustomException e) {\r\n              System.out.println(e.getMessage());\r\n          }\r\n      }\r\n\r\n      public static void validateAge(int age) throws CustomException {\r\n          if (age < 18) {\r\n              throw new CustomException("Age must be at least 18.");\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n---\r\n\r\n## **3. 异常的最佳实践**\r\n\r\n### **3.1 不要吞掉异常**\r\n\r\n- **问题**：\r\n  - 捕获异常后不做任何处理（即“吞掉”异常），会导致问题被隐藏，难以排查。\r\n- **错误示例**：\r\n\r\n  ```java\r\n  try {\r\n      int result = 10 / 0;\r\n  } catch (ArithmeticException e) {\r\n      // 啥也不做，吞掉异常\r\n  }\r\n  ```\r\n\r\n- **正确做法**：\r\n  - 至少记录异常信息或采取补救措施。\r\n  - 示例：\r\n\r\n    ```java\r\n    try {\r\n        int result = 10 / 0;\r\n    } catch (ArithmeticException e) {\r\n        System.err.println("An error occurred: " + e.getMessage());\r\n    }\r\n    ```\r\n\r\n---\r\n\r\n### **3.2 使用日志记录异常信息**\r\n\r\n- **推荐工具**：\r\n  - 使用专业的日志框架（如 Log4j、SLF4J）记录异常信息。\r\n- **优点**：\r\n  - 提供详细的上下文信息，便于问题定位。\r\n  - 避免直接将异常信息打印到控制台。\r\n- **示例**：\r\n\r\n  ```java\r\n  import org.slf4j.Logger;\r\n  import org.slf4j.LoggerFactory;\r\n\r\n  public class LoggingExample {\r\n      private static final Logger logger = LoggerFactory.getLogger(LoggingExample.class);\r\n\r\n      public static void main(String[] args) {\r\n          try {\r\n              int result = 10 / 0;\r\n          } catch (ArithmeticException e) {\r\n              logger.error("An arithmetic error occurred.", e);\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n---\r\n\r\n### **3.3 其他最佳实践**\r\n\r\n1. **避免滥用异常**：\r\n   - 异常应该用于处理异常情况，而不是作为流程控制的手段。\r\n2. **区分受检异常和非受检异常**：\r\n   - 对于可以预见并恢复的错误，使用受检异常。\r\n   - 对于不可预见或无法恢复的错误，使用非受检异常。\r\n3. **保持异常链**：\r\n   - 在重新抛出异常时，保留原始异常信息。\r\n   - 示例：\r\n\r\n     ```java\r\n     try {\r\n         someMethod();\r\n     } catch (Exception e) {\r\n         throw new CustomException("Wrapped exception", e);\r\n     }\r\n     ```\r\n\r\n---'}}]);
//# sourceMappingURL=79242.eb73e39d.js.map