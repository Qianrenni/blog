{"version":3,"file":"js/81473.692c51f8.js","mappings":"qHAAA,g/L","sources":["webpack://myblog/./src/assets/md/javascript/content/030-进阶问题.md"],"sourcesContent":["export default \"## **进阶问题**\\r\\n\\r\\n### **1. 闭包的应用场景**\\r\\n\\r\\n**闭包**是指一个函数能够访问其外部作用域中的变量，即使外部函数已经执行完毕。闭包在 JavaScript 中有以下常见应用场景：\\r\\n\\r\\n#### **1.1 数据封装与私有变量**\\r\\n\\r\\n- **用途**：通过闭包创建私有变量，避免全局污染。\\r\\n- **示例**：\\r\\n\\r\\n  ```javascript\\r\\n  function createCounter() {\\r\\n      let count = 0; // 私有变量\\r\\n      return {\\r\\n          increment: function () {\\r\\n              count++;\\r\\n              return count;\\r\\n          },\\r\\n          decrement: function () {\\r\\n              count--;\\r\\n              return count;\\r\\n          }\\r\\n      };\\r\\n  }\\r\\n\\r\\n  const counter = createCounter();\\r\\n  console.log(counter.increment()); // 输出：1\\r\\n  console.log(counter.increment()); // 输出：2\\r\\n  console.log(counter.decrement()); // 输出：1\\r\\n  ```\\r\\n\\r\\n#### **1.2 函数工厂**\\r\\n\\r\\n- **用途**：通过闭包生成具有特定功能的函数。\\r\\n- **示例**：\\r\\n\\r\\n  ```javascript\\r\\n  function createMultiplier(factor) {\\r\\n      return function (value) {\\r\\n          return value * factor;\\r\\n      };\\r\\n  }\\r\\n\\r\\n  const double = createMultiplier(2);\\r\\n  const triple = createMultiplier(3);\\r\\n\\r\\n  console.log(double(5)); // 输出：10\\r\\n  console.log(triple(5)); // 输出：15\\r\\n  ```\\r\\n\\r\\n#### **1.3 模块化开发**\\r\\n\\r\\n- **用途**：通过闭包实现模块模式，封装私有方法和变量。\\r\\n- **示例**：\\r\\n\\r\\n  ```javascript\\r\\n  const Module = (function () {\\r\\n      let privateVar = \\\"I am private\\\";\\r\\n\\r\\n      function privateMethod() {\\r\\n          console.log(privateVar);\\r\\n      }\\r\\n\\r\\n      return {\\r\\n          publicMethod: function () {\\r\\n              privateMethod();\\r\\n          }\\r\\n      };\\r\\n  })();\\r\\n\\r\\n  Module.publicMethod(); // 输出：I am private\\r\\n  console.log(Module.privateVar); // 报错：undefined\\r\\n  ```\\r\\n\\r\\n#### **1.4 缓存机制**\\r\\n\\r\\n- **用途**：通过闭包实现简单的缓存功能。\\r\\n- **示例**：\\r\\n\\r\\n  ```javascript\\r\\n  function createCache() {\\r\\n      const cache = {};\\r\\n      return function (key, value) {\\r\\n          if (value !== undefined) {\\r\\n              cache[key] = value; // 缓存值\\r\\n          }\\r\\n          return cache[key]; // 获取值\\r\\n      };\\r\\n  }\\r\\n\\r\\n  const cache = createCache();\\r\\n  cache(\\\"name\\\", \\\"Alice\\\");\\r\\n  console.log(cache(\\\"name\\\")); // 输出：Alice\\r\\n  ```\\r\\n\\r\\n#### **1.5 防抖与节流**\\r\\n\\r\\n- **用途**：通过闭包控制函数的调用频率。\\r\\n- **防抖示例**：\\r\\n\\r\\n  ```javascript\\r\\n  function debounce(fn, delay) {\\r\\n      let timer;\\r\\n      return function (...args) {\\r\\n          clearTimeout(timer);\\r\\n          timer = setTimeout(() => fn.apply(this, args), delay);\\r\\n      };\\r\\n  }\\r\\n\\r\\n  const log = debounce(() => console.log(\\\"Logged!\\\"), 1000);\\r\\n  window.addEventListener(\\\"resize\\\", log);\\r\\n  ```\\r\\n\\r\\n---\\r\\n\\r\\n### **2. 手写一个深拷贝函数**\\r\\n\\r\\n深拷贝是将对象的所有层级都复制一份，而不是简单地复制引用。\\r\\n\\r\\n#### **基本思路**\\r\\n\\r\\n1. 判断输入是否为对象或数组。\\r\\n2. 递归复制每个属性。\\r\\n3. 处理循环引用（可选）。\\r\\n\\r\\n#### **实现代码**\\r\\n\\r\\n```javascript\\r\\nfunction deepClone(obj, cache = new WeakMap()) {\\r\\n    if (obj === null || typeof obj !== \\\"object\\\") {\\r\\n        return obj; // 基本类型直接返回\\r\\n    }\\r\\n\\r\\n    if (cache.has(obj)) {\\r\\n        return cache.get(obj); // 解决循环引用\\r\\n    }\\r\\n\\r\\n    const copy = Array.isArray(obj) ? [] : {}; // 判断是数组还是对象\\r\\n    cache.set(obj, copy); // 缓存当前对象\\r\\n\\r\\n    for (const key in obj) {\\r\\n        if (obj.hasOwnProperty(key)) {\\r\\n            copy[key] = deepClone(obj[key], cache); // 递归深拷贝\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return copy;\\r\\n}\\r\\n\\r\\n// 示例\\r\\nconst original = { a: 1, b: { c: 2 } };\\r\\noriginal.b.d = original; // 循环引用\\r\\n\\r\\nconst cloned = deepClone(original);\\r\\nconsole.log(cloned.b.c); // 输出：2\\r\\nconsole.log(cloned.b.d === cloned); // 输出：true（解决了循环引用）\\r\\n```\\r\\n\\r\\n#### **关键点**\\r\\n\\r\\n1. **判断类型**：\\r\\n   - 使用 `typeof` 和 `Array.isArray` 区分对象和数组。\\r\\n2. **递归处理**：\\r\\n   - 对嵌套的对象或数组进行递归复制。\\r\\n3. **解决循环引用**：\\r\\n   - 使用 `WeakMap` 缓存已复制的对象。\\r\\n\\r\\n---\\r\\n\\r\\n### **3. 实现 `Promise.all` 和 `Promise.race`**\\r\\n\\r\\n#### **3.1 实现 `Promise.all`**\\r\\n\\r\\n- **定义**：接受一个 Promise 数组，当所有 Promise 都成功时返回结果数组；如果有一个失败，则立即返回失败原因。\\r\\n- **实现代码**：\\r\\n\\r\\n  ```javascript\\r\\n  function myPromiseAll(promises) {\\r\\n      return new Promise((resolve, reject) => {\\r\\n          const results = [];\\r\\n          let completedCount = 0;\\r\\n\\r\\n          promises.forEach((promise, index) => {\\r\\n              Promise.resolve(promise)\\r\\n                  .then(value => {\\r\\n                      results[index] = value;\\r\\n                      completedCount++;\\r\\n\\r\\n                      if (completedCount === promises.length) {\\r\\n                          resolve(results);\\r\\n                      }\\r\\n                  })\\r\\n                  .catch(reject);\\r\\n          });\\r\\n\\r\\n          if (promises.length === 0) {\\r\\n              resolve(results); // 空数组直接返回空结果\\r\\n          }\\r\\n      });\\r\\n  }\\r\\n\\r\\n  // 示例\\r\\n  const p1 = Promise.resolve(1);\\r\\n  const p2 = new Promise(resolve => setTimeout(() => resolve(2), 1000));\\r\\n  const p3 = Promise.resolve(3);\\r\\n\\r\\n  myPromiseAll([p1, p2, p3]).then(results => {\\r\\n      console.log(results); // 输出：[1, 2, 3]\\r\\n  }).catch(error => {\\r\\n      console.error(error);\\r\\n  });\\r\\n  ```\\r\\n\\r\\n#### **3.2 实现 `Promise.race`**\\r\\n\\r\\n- **定义**：接受一个 Promise 数组，返回第一个完成（无论是成功还是失败）的 Promise 结果。\\r\\n- **实现代码**：\\r\\n\\r\\n  ```javascript\\r\\n  function myPromiseRace(promises) {\\r\\n      return new Promise((resolve, reject) => {\\r\\n          promises.forEach(promise => {\\r\\n              Promise.resolve(promise)\\r\\n                  .then(resolve)\\r\\n                  .catch(reject);\\r\\n          });\\r\\n      });\\r\\n  }\\r\\n\\r\\n  // 示例\\r\\n  const p1 = new Promise(resolve => setTimeout(() => resolve(\\\"A\\\"), 1000));\\r\\n  const p2 = new Promise(resolve => setTimeout(() => resolve(\\\"B\\\"), 500));\\r\\n  const p3 = Promise.reject(\\\"Error\\\");\\r\\n\\r\\n  myPromiseRace([p1, p2, p3])\\r\\n      .then(result => {\\r\\n          console.log(result); // 输出：B（因为 p2 最快完成）\\r\\n      })\\r\\n      .catch(error => {\\r\\n          console.error(error); // 如果 p3 先完成，则输出：Error\\r\\n      });\\r\\n  ```\\r\\n\\r\\n#### **关键点**\\r\\n\\r\\n1. **`Promise.all`**：\\r\\n   - 需要等待所有 Promise 完成。\\r\\n   - 处理空数组的情况。\\r\\n2. **`Promise.race`**：\\r\\n   - 返回第一个完成的 Promise。\\r\\n   - 不需要等待其他 Promise。\\r\\n\\r\\n---\\r\\n\\r\\n<!-- 1. **算法与数据结构**\\r\\n   - 排序算法：冒泡排序、快速排序\\r\\n   - 常见数据结构：栈、队列、链表 -->\";"],"names":[],"sourceRoot":""}