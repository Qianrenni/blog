"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[2423],{62423:function(r,n,e){e.r(n),n["default"]='## **7. 动态代理**\r\n\r\n动态代理是反射的一个重要应用场景，它允许我们为接口动态生成代理对象，并在调用方法时插入额外的逻辑。\r\n\r\n### **7.1 定义接口和实现类**\r\n\r\n```java\r\npublic interface Greeting {\r\n    void sayHello(String name);\r\n}\r\n\r\npublic class GreetingImpl implements Greeting {\r\n    @Override\r\n    public void sayHello(String name) {\r\n        System.out.println("Hello, " + name);\r\n    }\r\n}\r\n```\r\n\r\n### **7.2 创建动态代理**\r\n\r\n```java\r\nimport java.lang.reflect.InvocationHandler;\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Proxy;\r\n\r\npublic class ProxyExample {\r\n    public static void main(String[] args) {\r\n        Greeting greeting = new GreetingImpl();\r\n\r\n        Greeting proxy = (Greeting) Proxy.newProxyInstance(\r\n            greeting.getClass().getClassLoader(),\r\n            greeting.getClass().getInterfaces(),\r\n            new InvocationHandler() {\r\n                @Override\r\n                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n                    System.out.println("Before method call");\r\n                    Object result = method.invoke(greeting, args);\r\n                    System.out.println("After method call");\r\n                    return result;\r\n                }\r\n            }\r\n        );\r\n\r\n        proxy.sayHello("Alice");\r\n    }\r\n}\r\n```\r\n\r\n输出结果：\r\n\r\n```\r\nBefore method call\r\nHello, Alice\r\nAfter method call\r\n```\r\n\r\n---'}}]);
//# sourceMappingURL=2423.f39029a9.js.map