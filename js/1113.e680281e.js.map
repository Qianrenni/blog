{"version":3,"file":"js/1113.e680281e.js","mappings":"oHAAA,2hC","sources":["webpack://myblog/./src/assets/md/java/content/031-2 线程同步.md"],"sourcesContent":["export default \"## **2. 线程同步**\\r\\n\\r\\n### **2.1 `synchronized` 关键字**\\r\\n\\r\\n`synchronized` 是Java提供的内置锁机制，用于保证多线程环境下的数据一致性。\\r\\n\\r\\n#### **2.1.1 方法级同步**\\r\\n\\r\\n```java\\r\\npublic synchronized void method() {\\r\\n    // 同步代码块\\r\\n}\\r\\n```\\r\\n\\r\\n#### **2.1.2 块级同步**\\r\\n\\r\\n```java\\r\\npublic void method() {\\r\\n    synchronized (this) {\\r\\n        // 同步代码块\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n#### **2.1.3 锁的对象**\\r\\n\\r\\n- `synchronized` 可以作用于实例方法、静态方法或指定对象。\\r\\n- 静态方法的锁是类对象（`Class` 对象）。\\r\\n\\r\\n---\\r\\n\\r\\n### **2.2 死锁的概念与避免**\\r\\n\\r\\n- **死锁定义**：多个线程相互持有对方所需的资源，导致彼此永久阻塞。\\r\\n- **死锁条件**（必要条件）：\\r\\n  1. **互斥**：资源只能被一个线程占用。\\r\\n  2. **占有且等待**：线程持有资源的同时等待其他资源。\\r\\n  3. **不可剥夺**：资源不能被强行抢占。\\r\\n  4. **循环等待**：存在一个线程等待环路。\\r\\n\\r\\n- **避免死锁的方法**：\\r\\n  - 按顺序获取锁。\\r\\n  - 使用定时锁（`tryLock`）。\\r\\n  - 减少锁的粒度。\\r\\n\\r\\n---\\r\\n\\r\\n### **2.3 `volatile` 关键字**\\r\\n\\r\\n- **作用**：确保变量的可见性，即每次读取时都从主内存加载最新值。\\r\\n- **适用场景**：适用于简单的标志位变量。\\r\\n- **注意**：`volatile` 不保证原子性，不能替代锁。\\r\\n\\r\\n```java\\r\\nprivate volatile boolean flag = true;\\r\\n\\r\\npublic void stop() {\\r\\n    flag = false;\\r\\n}\\r\\n```\\r\\n\\r\\n---\";"],"names":[],"sourceRoot":""}