"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[111],{50111:function(n,r,e){e.r(r),r["default"]='## **2. 动态规划（DP）**\r\n\r\n### **背包问题**\r\n\r\n1. **0-1背包**  \r\n\r\n```python\r\ndef knapsack_01(W, weights, values):\r\n  n = len(weights)\r\n  dp = [0] * (W + 1)\r\n  for i in range(n):\r\n      for j in range(W, weights[i] - 1, -1):\r\n          dp[j] = max(dp[j], dp[j - weights[i]] + values[i])\r\n  return dp[W]\r\n```\r\n\r\n2. **完全背包**\r\n\r\n```python\r\ndef knapsack_unbounded(W, weights, values):\r\n  n = len(weights)\r\n  dp = [0] * (W + 1)\r\n  for i in range(n):\r\n      for j in range(weights[i], W + 1):\r\n          dp[j] = max(dp[j], dp[j - weights[i]] + values[i])\r\n  return dp[W]\r\n```\r\n\r\n3. **分组背包**\r\n\r\n```python\r\ndef knapsack_grouped(W, groups):\r\n  dp = [0] * (W + 1)\r\n  for group in groups:\r\n      for j in range(W, -1, -1):  # 内层逆序\r\n          for weight, value in group:\r\n              if j >= weight:\r\n                  dp[j] = max(dp[j], dp[j - weight] + value)\r\n  return dp[W]\r\n```\r\n\r\n4. **多重背包(二进制优化)**\r\n\r\n```python\r\ndef knapsack_multiple(W, weights, values, counts):\r\n    n = len(weights)\r\n    new_weights, new_values = [], []\r\n    \r\n    # 二进制优化拆分\r\n    for i in range(n):\r\n        count = counts[i]\r\n        k = 1\r\n        while k <= count:\r\n            new_weights.append(weights[i] * k)\r\n            new_values.append(values[i] * k)\r\n            count -= k\r\n            k *= 2\r\n        if count > 0:\r\n            new_weights.append(weights[i] * count)\r\n            new_values.append(values[i] * count)\r\n    \r\n    # 转化为01背包问题求解\r\n    dp = [0] * (W + 1)\r\n    for i in range(len(new_weights)):\r\n        for j in range(W, new_weights[i] - 1, -1):\r\n            dp[j] = max(dp[j], dp[j - new_weights[i]] + new_values[i])\r\n    return dp[W]\r\n```\r\n\r\n 5. **对比**\r\n\r\n| 背包类型      | 物品选择规则                     | 遍历顺序       | 时间复杂度           | 空间复杂度     | 应用场景                           |\r\n|---------------|----------------------------------|----------------|----------------------|----------------|------------------------------------|\r\n| **01背包**    | 每种物品最多选一次               | 内层逆序       | $O(n \\cdot W)$      | $O(W)$         | 基础背包问题，物品不可重复选择     |\r\n| **无限背包**  | 每种物品可选多次                 | 内层正序       | $O(n \\cdot W)$      | $O(W)$         | 物品数量无限制，允许重复选择       |\r\n| **分组背包**  | 每组最多选一个物品               | 内层逆序       | $O(\\text{组数} \\cdot W)$ | $O(W)$         | 组内互斥，每组最多选一个           |\r\n| **多重背包**  | 每种物品有固定数量限制           | 内层逆序（优化前：$O(k \\cdot W)$，优化后：$O(\\log k \\cdot W)$） | $O(\\sum \\log k_i \\cdot W)$ | $O(W)$         | 物品数量有限，二进制优化提高效率   |\r\n\r\n---\r\n\r\n### **最短编辑距离**\r\n\r\n```python\r\ndef min_edit_distance(A, B):\r\n    m, n = len(A), len(B)\r\n    # 初始化 dp 数组\r\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\r\n    \r\n    # 边界条件\r\n    for i in range(1, m + 1):\r\n        dp[i][0] = i  # 删除 A 中的所有字符\r\n    for j in range(1, n + 1):\r\n        dp[0][j] = j  # 插入 B 中的所有字符\r\n    \r\n    # 填充 dp 表\r\n    for i in range(1, m + 1):\r\n        for j in range(1, n + 1):\r\n            if A[i - 1] == B[j - 1]:\r\n                dp[i][j] = dp[i - 1][j - 1]\r\n            else:\r\n                dp[i][j] = min(dp[i - 1][j] + 1,   # 删除\r\n                               dp[i][j - 1] + 1,   # 插入\r\n                               dp[i - 1][j - 1] + 1)  # 替换\r\n    return dp[m][n]\r\n```\r\n\r\n### **最长公共子序列**\r\n\r\n```python\r\ndef longest_common_subsequence(A, B):\r\n    m, n = len(A), len(B)\r\n    # 初始化 dp 数组\r\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\r\n    \r\n    # 填充 dp 表\r\n    for i in range(1, m + 1):\r\n        for j in range(1, n + 1):\r\n            if A[i - 1] == B[j - 1]:\r\n                dp[i][j] = dp[i - 1][j - 1] + 1\r\n            else:\r\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\r\n    \r\n    # 返回结果\r\n    return dp[m][n]\r\n```\r\n\r\n### **最长递增子序列**\r\n\r\n```python\r\ndef length_of_LIS(nums):\r\n    if not nums:\r\n        return 0\r\n    \r\n    n = len(nums)\r\n    dp = [1] * n  # 初始化每个位置的 LIS 长度为 1\r\n    \r\n    for i in range(1, n):\r\n        for j in range(i):\r\n            if nums[i] > nums[j]:\r\n                dp[i] = max(dp[i], dp[j] + 1)\r\n    \r\n    return max(dp)\r\n\r\n#优化版\r\ndef length_of_LIS(nums):\r\n    if not nums:\r\n        return 0\r\n    n=len(nums)\r\n    dp=[1]*n\r\n    lis=[]\r\n    for i in range(1,n):\r\n      index=bisect.bisect_left(lis,nums[i])\r\n      dp[i]=index+1\r\n      if index==len(lis):\r\n          lis.append(nums[i])\r\n      else:\r\n          lis[index]=nums[i]\r\n    return len(lis),dp\r\n```\r\n\r\n### **最长回文子串**\r\n\r\n```python\r\ndef longest_palindromic_substring_dp(s):\r\n    n = len(s)\r\n    dp = [[False] * n for _ in range(n)]\r\n    longest = ""\r\n    \r\n    # 填充 dp 表\r\n    for length in range(1, n + 1):  # 子串长度从 1 到 n\r\n        for i in range(n - length + 1):\r\n            j = i + length - 1\r\n            if length == 1:\r\n                dp[i][j] = True  # 单个字符是回文\r\n            elif length == 2:\r\n                dp[i][j] = (s[i] == s[j])  # 两个字符相等时是回文\r\n            else:\r\n                dp[i][j] = (s[i] == s[j] and dp[i + 1][j - 1])\r\n            \r\n            # 更新最长回文子串\r\n            if dp[i][j] and length > len(longest):\r\n                longest = s[i:j+1]\r\n    \r\n    return longest\r\n```\r\n\r\n### **数位DP**\r\n\r\n>给定范围 [L, R]，求出其中所有数字的数字和（即每个数字的各位数字之和）的总和。\r\n\r\n```python\r\ndef sum_of_digit_sums(n):\r\n    s = str(n)\r\n    length = len(s)\r\n    # 定义记忆化表 dp[pos][sum][tight]\r\n    dp = [[[None] * 2 for _ in range(100)] for __ in range(length)]\r\n\r\n    def dfs(pos, current_sum, tight):\r\n        if pos == length:\r\n            return current_sum  # 返回当前的数字和\r\n        if dp[pos][current_sum][tight] is not None:  # 如果已经计算过，直接返回结果\r\n            return dp[pos][current_sum][tight]\r\n\r\n        limit = int(s[pos]) if tight else 9\r\n        total = 0\r\n        for digit in range(0, limit + 1):\r\n            new_tight = tight and (digit == limit)\r\n            total += dfs(pos + 1, current_sum + digit, new_tight)\r\n\r\n        dp[pos][current_sum][tight] = total  # 记录结果\r\n        return total\r\n\r\n    return dfs(0, 0, True)\r\n\r\n```'}}]);
//# sourceMappingURL=111.ed5c052d.js.map