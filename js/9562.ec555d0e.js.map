{"version":3,"file":"js/9562.ec555d0e.js","mappings":"mHAAA,2xD","sources":["webpack://myblog/./src/assets/md/java/content/032-3 高级并发工具.md"],"sourcesContent":["export default \"## **3. 高级并发工具**\\r\\n\\r\\n### **3.1 `Lock` 接口与 `ReentrantLock`**\\r\\n\\r\\n`Lock` 提供比 `synchronized` 更灵活的锁机制。\\r\\n\\r\\n```java\\r\\nimport java.util.concurrent.locks.Lock;\\r\\nimport java.util.concurrent.locks.ReentrantLock;\\r\\n\\r\\npublic class Main {\\r\\n    private final Lock lock = new ReentrantLock();\\r\\n\\r\\n    public void method() {\\r\\n        lock.lock();\\r\\n        try {\\r\\n            // 临界区代码\\r\\n        } finally {\\r\\n            lock.unlock();\\r\\n        }\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n- **优点**：\\r\\n  - 支持公平锁和非公平锁。\\r\\n  - 提供可中断锁（`lockInterruptibly`）。\\r\\n  - 支持尝试获取锁（`tryLock`）。\\r\\n\\r\\n---\\r\\n\\r\\n### **3.2 并发集合**\\r\\n\\r\\nJava提供了多种线程安全的集合类。\\r\\n\\r\\n- **`ConcurrentHashMap`**：分段锁机制，支持高并发读写。\\r\\n- **`CopyOnWriteArrayList`**：写时复制，适合读多写少的场景。\\r\\n\\r\\n```java\\r\\nimport java.util.concurrent.ConcurrentHashMap;\\r\\n\\r\\nConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\\r\\nmap.put(\\\"key\\\", 1);\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### **3.3 线程池**\\r\\n\\r\\n线程池的核心类是 `ThreadPoolExecutor`，它允许开发者自定义线程池。\\r\\n\\r\\n```java\\r\\nimport java.util.concurrent.*;\\r\\n\\r\\npublic class Main {\\r\\n    public static void main(String[] args) {\\r\\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(\\r\\n            2, // 核心线程数\\r\\n            4, // 最大线程数\\r\\n            10, // 空闲线程存活时间\\r\\n            TimeUnit.SECONDS,\\r\\n            new LinkedBlockingQueue<>()\\r\\n        );\\r\\n        executor.submit(() -> System.out.println(\\\"Task executed\\\"));\\r\\n        executor.shutdown();\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### **3.4 原子类**\\r\\n\\r\\n原子类提供无锁的线程安全操作。\\r\\n\\r\\n- **常用原子类**：\\r\\n  - `AtomicInteger`\\r\\n  - `AtomicBoolean`\\r\\n  - `AtomicReference`\\r\\n\\r\\n```java\\r\\nimport java.util.concurrent.atomic.AtomicInteger;\\r\\n\\r\\nAtomicInteger counter = new AtomicInteger(0);\\r\\ncounter.incrementAndGet(); // 原子操作\\r\\n```\\r\\n\\r\\n---\";"],"names":[],"sourceRoot":""}