{"version":3,"file":"js/797.32df3c03.js","mappings":"mHAAA,u4J","sources":["webpack://myblog/./src/assets/md/python/content/021-网络编程.md"],"sourcesContent":["export default \"## **网络编程**\\r\\n\\r\\n### **1、核心模块与库**\\r\\n\\r\\nPython提供了多个模块和库来支持网络编程，以下是几个常用的模块：\\r\\n\\r\\n#### **1.1 `socket` 模块**\\r\\n\\r\\n`socket` 是Python中最基础的网络编程模块，用于创建和管理网络连接。它支持TCP和UDP协议。\\r\\n\\r\\n##### **创建TCP服务器**\\r\\n\\r\\n以下是一个简单的TCP服务器示例：\\r\\n\\r\\n```python\\r\\nimport socket\\r\\n\\r\\n# 创建一个socket对象\\r\\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\\r\\n\\r\\n# 绑定IP地址和端口\\r\\nserver_socket.bind(('127.0.0.1', 8080))\\r\\n\\r\\n# 开始监听\\r\\nserver_socket.listen(5)\\r\\nprint(\\\"服务器已启动，等待客户端连接...\\\")\\r\\n\\r\\nwhile True:\\r\\n    # 接受客户端连接\\r\\n    client_socket, addr = server_socket.accept()\\r\\n    print(f\\\"客户端已连接，地址：{addr}\\\")\\r\\n\\r\\n    # 接收数据\\r\\n    data = client_socket.recv(1024)\\r\\n    print(f\\\"收到数据：{data.decode()}\\\")\\r\\n\\r\\n    # 发送响应\\r\\n    client_socket.send(\\\"Hello from server!\\\".encode())\\r\\n\\r\\n    # 关闭连接\\r\\n    client_socket.close()\\r\\n```\\r\\n\\r\\n##### **创建TCP客户端**\\r\\n\\r\\n以下是一个对应的TCP客户端示例：\\r\\n\\r\\n```python\\r\\nimport socket\\r\\n\\r\\n# 创建一个socket对象\\r\\nclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\\r\\n\\r\\n# 连接到服务器\\r\\nclient_socket.connect(('127.0.0.1', 8080))\\r\\n\\r\\n# 发送数据\\r\\nclient_socket.send(\\\"Hello from client!\\\".encode())\\r\\n\\r\\n# 接收响应\\r\\nresponse = client_socket.recv(1024)\\r\\nprint(f\\\"服务器响应：{response.decode()}\\\")\\r\\n\\r\\n# 关闭连接\\r\\nclient_socket.close()\\r\\n```\\r\\n\\r\\n#### **1.2 `selectors` 模块**\\r\\n\\r\\n当需要处理大量并发连接时，可以使用 `selectors` 模块实现高效的I/O多路复用。例如：\\r\\n\\r\\n```python\\r\\nimport selectors\\r\\nimport socket\\r\\n\\r\\nsel = selectors.DefaultSelector()\\r\\n\\r\\ndef accept(sock, mask):\\r\\n    conn, addr = sock.accept()\\r\\n    print(f\\\"客户端已连接，地址：{addr}\\\")\\r\\n    conn.setblocking(False)\\r\\n    sel.register(conn, selectors.EVENT_READ, read)\\r\\n\\r\\ndef read(conn, mask):\\r\\n    data = conn.recv(1024)\\r\\n    if data:\\r\\n        print(f\\\"收到数据：{data.decode()}\\\")\\r\\n        conn.send(data)  # 回显数据\\r\\n    else:\\r\\n        print(\\\"关闭连接\\\")\\r\\n        sel.unregister(conn)\\r\\n        conn.close()\\r\\n\\r\\nsock = socket.socket()\\r\\nsock.bind(('127.0.0.1', 8080))\\r\\nsock.listen(100)\\r\\nsock.setblocking(False)\\r\\nsel.register(sock, selectors.EVENT_READ, accept)\\r\\n\\r\\nwhile True:\\r\\n    events = sel.select()\\r\\n    for key, mask in events:\\r\\n        callback = key.data\\r\\n        callback(key.fileobj, mask)\\r\\n```\\r\\n\\r\\n#### **1.3 `asyncio` 模块**\\r\\n\\r\\n`asyncio` 是Python中用于编写异步代码的核心库，特别适合处理大量并发连接。它基于事件循环机制，能够高效地管理I/O操作。\\r\\n\\r\\n示例：使用 `asyncio` 编写一个简单的TCP服务器：\\r\\n\\r\\n```python\\r\\nimport asyncio\\r\\n\\r\\nasync def handle_client(reader, writer):\\r\\n    data = await reader.read(100)\\r\\n    message = data.decode()\\r\\n    addr = writer.get_extra_info('peername')\\r\\n    print(f\\\"收到数据：{message}，来自：{addr}\\\")\\r\\n    writer.write(data)\\r\\n    await writer.drain()\\r\\n    writer.close()\\r\\n\\r\\nasync def main():\\r\\n    server = await asyncio.start_server(handle_client, '127.0.0.1', 8080)\\r\\n    async with server:\\r\\n        await server.serve_forever()\\r\\n\\r\\nasyncio.run(main())\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### **2、高级主题**\\r\\n\\r\\n#### **2.1 HTTP编程**\\r\\n\\r\\nPython中的 `http.server` 和 `requests` 模块可以用来处理HTTP请求。\\r\\n\\r\\n##### **用 `http.server` 创建简单HTTP服务器**\\r\\n\\r\\n```python\\r\\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\\r\\n\\r\\nclass SimpleHTTPRequestHandler(BaseHTTPRequestHandler):\\r\\n    def do_GET(self):\\r\\n        self.send_response(200)\\r\\n        self.end_headers()\\r\\n        self.wfile.write(b\\\"Hello, world!\\\")\\r\\n\\r\\nhttpd = HTTPServer(('127.0.0.1', 8080), SimpleHTTPRequestHandler)\\r\\nhttpd.serve_forever()\\r\\n```\\r\\n\\r\\n##### **使用 `requests` 发送HTTP请求**\\r\\n\\r\\n```python\\r\\nimport requests\\r\\n\\r\\nresponse = requests.get('https://www.example.com')\\r\\nprint(response.status_code)\\r\\nprint(response.text)\\r\\n```\\r\\n\\r\\n#### **2.2 WebSocket**\\r\\n\\r\\nWebSocket是一种全双工通信协议，适合实时通信场景。可以使用 `websockets` 库实现WebSocket服务器和客户端。\\r\\n\\r\\n##### **WebSocket服务器示例**\\r\\n\\r\\n```python\\r\\nimport asyncio\\r\\nimport websockets\\r\\n\\r\\nasync def echo(websocket, path):\\r\\n    async for message in websocket:\\r\\n        print(f\\\"收到消息：{message}\\\")\\r\\n        await websocket.send(f\\\"Echo: {message}\\\")\\r\\n\\r\\nstart_server = websockets.serve(echo, \\\"127.0.0.1\\\", 8080)\\r\\n\\r\\nasyncio.get_event_loop().run_until_complete(start_server)\\r\\nasyncio.get_event_loop().run_forever()\\r\\n```\\r\\n\\r\\n##### **WebSocket客户端示例**\\r\\n\\r\\n```python\\r\\nimport asyncio\\r\\nimport websockets\\r\\n\\r\\nasync def hello():\\r\\n    uri = \\\"ws://127.0.0.1:8080\\\"\\r\\n    async with websockets.connect(uri) as websocket:\\r\\n        await websocket.send(\\\"Hello, server!\\\")\\r\\n        response = await websocket.recv()\\r\\n        print(f\\\"收到响应：{response}\\\")\\r\\n\\r\\nasyncio.get_event_loop().run_until_complete(hello())\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### **3、常见问题与解决方案**\\r\\n\\r\\n#### **3.1 如何处理高并发？**\\r\\n\\r\\n- 使用多线程或多进程模型（`threading` 或 `multiprocessing`）。\\r\\n- 使用异步编程（`asyncio`）。\\r\\n- 使用事件驱动框架（如 `Twisted` 或 `Tornado`）。\\r\\n\\r\\n#### **3.2 如何确保安全性？**\\r\\n\\r\\n- 使用SSL/TLS加密通信（`ssl` 模块）。\\r\\n- 验证客户端身份（如OAuth、JWT）。\\r\\n- 对敏感数据进行加密存储。\\r\\n\\r\\n#### **3.3 如何调试网络程序？**\\r\\n\\r\\n- 使用日志记录（`logging` 模块）。\\r\\n- 使用抓包工具（如Wireshark）分析网络流量。\\r\\n- 使用单元测试验证逻辑正确性。\\r\\n\\r\\n---\";"],"names":[],"sourceRoot":""}