{"version":3,"file":"js/722.2cd07084.js","mappings":"iHAAA,k+G","sources":["webpack://myblog/./src/assets/md/algorithm/content/012-4 回溯法.md"],"sourcesContent":["export default \"## **4. 回溯法**\\r\\n\\r\\n- **框架**：  \\r\\n\\r\\n  ```python\\r\\n  def backtrack(path, choices):\\r\\n      if 满足条件:\\r\\n          记录结果\\r\\n          return\\r\\n      for 选择 in 选择列表:\\r\\n          做选择\\r\\n          backtrack(path, choices)\\r\\n          撤销选择\\r\\n  ```\\r\\n\\r\\n### **全排列**\\r\\n\\r\\n```python\\r\\ndef permute(nums):\\r\\n    def backtrack(path, choices):\\r\\n        # 如果选择列表为空，说明找到一个排列\\r\\n        if not choices:\\r\\n            result.append(path[:])  # 记录结果\\r\\n            return\\r\\n\\r\\n        for i in range(len(choices)):\\r\\n            # 做选择\\r\\n            num = choices[i]\\r\\n            path.append(num)\\r\\n            # 递归\\r\\n            backtrack(path, choices[:i] + choices[i+1:])\\r\\n            # 撤销选择\\r\\n            path.pop()\\r\\n\\r\\n    result = []\\r\\n    backtrack([], nums)\\r\\n    return result\\r\\n```\\r\\n\\r\\n### **N皇后**\\r\\n\\r\\n> **问题描述**: 在 N×N 的棋盘上放置 N 个皇后，使得它们互不攻击（即任意两个皇后不在同一行、列或对角线上）。返回所有可能的解决方案。\\r\\n\\r\\n```python\\r\\ndef solve_n_queens(n):\\r\\n    def is_valid(row, col):\\r\\n        # 检查列冲突\\r\\n        if col in cols:\\r\\n            return False\\r\\n        # 检查主对角线冲突 (row - col 相同)\\r\\n        if row - col in diag1:\\r\\n            return False\\r\\n        # 检查副对角线冲突 (row + col 相同)\\r\\n        if row + col in diag2:\\r\\n            return False\\r\\n        return True\\r\\n\\r\\n    def backtrack(row):\\r\\n        # 如果已经放置了 N 个皇后，记录当前解\\r\\n        if row == n:\\r\\n            result.append([\\\"\\\".join(row) for row in board])\\r\\n            return\\r\\n\\r\\n        for col in range(n):\\r\\n            if is_valid(row, col):\\r\\n                # 做选择\\r\\n                board[row][col] = \\\"Q\\\"\\r\\n                cols.add(col)\\r\\n                diag1.add(row - col)\\r\\n                diag2.add(row + col)\\r\\n                # 递归\\r\\n                backtrack(row + 1)\\r\\n                # 撤销选择\\r\\n                board[row][col] = \\\".\\\"\\r\\n                cols.remove(col)\\r\\n                diag1.remove(row - col)\\r\\n                diag2.remove(row + col)\\r\\n\\r\\n    # 初始化棋盘\\r\\n    board = [[\\\".\\\"] * n for _ in range(n)]\\r\\n    cols = set()  # 列集合\\r\\n    diag1 = set()  # 主对角线集合\\r\\n    diag2 = set()  # 副对角线集合\\r\\n    result = []\\r\\n    backtrack(0)\\r\\n    return result\\r\\n```\\r\\n\\r\\n### **数独求解**\\r\\n>\\r\\n> **约束条件：**\\r\\n每一行必须包含数字 1 到 9，且不能重复。\\r\\n每一列必须包含数字 1 到 9，且不能重复。\\r\\n每个小宫格（3×3 区块）必须包含数字 1 到 9，且不能重复。\\r\\n\\r\\n```python\\r\\ndef solve_sudoku(board):\\r\\n    def is_valid(row, col, num):\\r\\n        # 检查行和列是否有冲突\\r\\n        for i in range(9):\\r\\n            if board[row][i] == num or board[i][col] == num:\\r\\n                return False\\r\\n        # 检查 3x3 小方格是否有冲突\\r\\n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\\r\\n        for i in range(start_row, start_row + 3):\\r\\n            for j in range(start_col, start_col + 3):\\r\\n                if board[i][j] == num:\\r\\n                    return False\\r\\n        return True\\r\\n\\r\\n    def backtrack():\\r\\n        for row in range(9):\\r\\n            for col in range(9):\\r\\n                if board[row][col] == \\\".\\\":\\r\\n                    for num in \\\"123456789\\\":\\r\\n                        if is_valid(row, col, num):\\r\\n                            # 做选择\\r\\n                            board[row][col] = num\\r\\n                            # 递归\\r\\n                            if backtrack():\\r\\n                                return True\\r\\n                            # 撤销选择\\r\\n                            board[row][col] = \\\".\\\"\\r\\n                    return False  # 如果尝试所有数字都失败，返回 False\\r\\n        return True  # 如果所有格子都填满，返回 True\\r\\n\\r\\n    backtrack()\\r\\n\\r\\n```\\r\\n\\r\\n---\";"],"names":[],"sourceRoot":""}