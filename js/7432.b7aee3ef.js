"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[7432],{97432:function(n,r,e){e.r(r),r["default"]='# **4. 创建型模式详解**\r\n\r\n创建型模式主要用于处理对象的创建过程，旨在封装实例化逻辑，使系统独立于如何创建、组合和表示这些对象。\\\r\n\r\n## **4.1 单例模式**\r\n\r\n- **定义与特点**：单例模式确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。其特点是只能有一个实例存在，且必须自行创建该实例。\r\n  \r\n- **实现方式**：\r\n  - **懒汉式**：在第一次被引用时才初始化实例，节省资源但需要考虑线程安全问题。\r\n  \r\n  ```python\r\n  class SingletonLazy:\r\n    _instance = None\r\n\r\n    def __new__(cls, *args, **kwargs):\r\n        if not cls._instance:\r\n            cls._instance = super(SingletonLazy, cls).__new__(cls)\r\n        return cls._instance\r\n\r\n  # 使用示例\r\n  obj1 = SingletonLazy()\r\n  obj2 = SingletonLazy()\r\n  print(obj1 is obj2)  # 输出: True\r\n\r\n  ```\r\n\r\n  - **饿汉式**：类加载时就创建实例，简单高效但可能浪费资源。\r\n\r\n  ```python\r\n  class SingletonEager:\r\n    class _Singleton:\r\n        def __init__(self):\r\n            pass\r\n\r\n    instance = _Singleton()\r\n\r\n  # 使用示例\r\n  obj1 = SingletonEager.instance\r\n  obj2 = SingletonEager.instance\r\n  print(obj1 is obj2)  # 输出: True\r\n\r\n  ```\r\n\r\n  - **双重检查锁定**：结合懒汉式的延迟加载与同步代码块，减少性能开销同时保证线程安全。\r\n  \r\n  ```python\r\n  import threading\r\n\r\n  class SingletonDoubleChecked:\r\n      _instance = None\r\n      _lock = threading.Lock()\r\n\r\n      def __new__(cls, *args, **kwargs):\r\n          if not cls._instance:\r\n              with cls._lock:\r\n                  if not cls._instance:\r\n                      cls._instance = super(SingletonDoubleChecked, cls).__new__(cls)\r\n          return cls._instance\r\n\r\n  # 使用示例\r\n  obj1 = SingletonDoubleChecked()\r\n  obj2 = SingletonDoubleChecked()\r\n  print(obj1 is obj2)  # 输出: True\r\n  ```\r\n\r\n- **应用场景与优缺点**：适用于需要频繁使用的单一资源场景，如数据库连接池等。优点是减少了内存开销并提高了性能；缺点是不支持有参数的构造函数，且难以进行单元测试。\r\n\r\n## **4.2 工厂方法模式**\r\n\r\n- **定义与特点**：工厂方法模式定义了一个用于创建对象的接口，但由子类决定要实例化的类是哪一个。这样，工厂方法使一个类的实例化推迟到其子类。\r\n  \r\n- **工厂方法与简单工厂的区别**：简单工厂将所有产品对象的创建逻辑集中在一个工厂类中，而工厂方法则是每个产品都有对应的工厂子类负责创建。\r\n  \r\n- **应用场景与示例**：适合用于需要灵活扩展的产品体系，例如不同操作系统的GUI组件创建。示例可以是一个跨平台的应用程序，根据不同的操作系统使用相应的窗口或按钮控件。\r\n\r\n```python\r\nfrom abc import ABC, abstractmethod\r\n\r\n# 定义产品接口\r\nclass Product(ABC):\r\n    @abstractmethod\r\n    def operation(self):\r\n        pass\r\n\r\n# 具体产品A\r\nclass ConcreteProductA(Product):\r\n    def operation(self):\r\n        return "ConcreteProductA"\r\n\r\n# 具体产品B\r\nclass ConcreteProductB(Product):\r\n    def operation(self):\r\n        return "ConcreteProductB"\r\n\r\n# 定义工厂接口\r\nclass Creator(ABC):\r\n    @abstractmethod\r\n    def factory_method(self):\r\n        pass\r\n\r\n    def some_operation(self):\r\n        product = self.factory_method()\r\n        return f"Creator: {product.operation()}"\r\n\r\n# 具体工厂A\r\nclass ConcreteCreatorA(Creator):\r\n    def factory_method(self):\r\n        return ConcreteProductA()\r\n\r\n# 具体工厂B\r\nclass ConcreteCreatorB(Creator):\r\n    def factory_method(self):\r\n        return ConcreteProductB()\r\n\r\n# 使用示例\r\ncreator_a = ConcreteCreatorA()\r\nprint(creator_a.some_operation())  # 输出: Creator: ConcreteProductA\r\n\r\ncreator_b = ConcreteCreatorB()\r\nprint(creator_b.some_operation())  # 输出: Creator: ConcreteProductB\r\n\r\n```\r\n\r\n## **4.3 抽象工厂模式**\r\n\r\n- **定义与特点**：抽象工厂模式提供了一系列相关或依赖对象的接口，而无需指定它们具体的类。它是一种更高层次的抽象，允许创建一系列相关的对象，而不必关心这些对象的具体类是什么。\r\n  \r\n- **工厂方法与抽象工厂的区别**：工厂方法模式关注的是单个产品的创建，而抽象工厂模式则关注一系列相关产品族的创建。\r\n  \r\n- **示例：跨平台UI组件的实现**：比如为Windows和MacOS设计一套统一的UI组件库，用户界面可以在两个平台上看起来几乎相同，但内部使用了各自平台特定的实现。\r\n\r\n```python\r\nfrom abc import ABC, abstractmethod\r\n\r\n# 定义抽象产品族\r\nclass Button(ABC):\r\n    @abstractmethod\r\n    def paint(self):\r\n        pass\r\n\r\nclass Checkbox(ABC):\r\n    @abstractmethod\r\n    def paint(self):\r\n        pass\r\n\r\n# Windows 产品族\r\nclass WindowsButton(Button):\r\n    def paint(self):\r\n        return "Render a button in Windows style."\r\n\r\nclass WindowsCheckbox(Checkbox):\r\n    def paint(self):\r\n        return "Render a checkbox in Windows style."\r\n\r\n# MacOS 产品族\r\nclass MacOSButton(Button):\r\n    def paint(self):\r\n        return "Render a button in MacOS style."\r\n\r\nclass MacOSCheckbox(Checkbox):\r\n    def paint(self):\r\n        return "Render a checkbox in MacOS style."\r\n\r\n# 抽象工厂接口\r\nclass GUIFactory(ABC):\r\n    @abstractmethod\r\n    def create_button(self) -> Button:\r\n        pass\r\n\r\n    @abstractmethod\r\n    def create_checkbox(self) -> Checkbox:\r\n        pass\r\n\r\n# 具体工厂：Windows 工厂\r\nclass WindowsFactory(GUIFactory):\r\n    def create_button(self) -> Button:\r\n        return WindowsButton()\r\n\r\n    def create_checkbox(self) -> Checkbox:\r\n        return WindowsCheckbox()\r\n\r\n# 具体工厂：MacOS 工厂\r\nclass MacOSFactory(GUIFactory):\r\n    def create_button(self) -> Button:\r\n        return MacOSButton()\r\n\r\n    def create_checkbox(self) -> Checkbox:\r\n        return MacOSCheckbox()\r\n\r\n# 使用示例\r\ndef client_code(factory: GUIFactory):\r\n    button = factory.create_button()\r\n    checkbox = factory.create_checkbox()\r\n    print(button.paint())\r\n    print(checkbox.paint())\r\n\r\nclient_code(WindowsFactory())\r\n# 输出:\r\n# Render a button in Windows style.\r\n# Render a checkbox in Windows style.\r\n\r\nclient_code(MacOSFactory())\r\n# 输出:\r\n# Render a button in MacOS style.\r\n# Render a checkbox in MacOS style.\r\n\r\n```\r\n\r\n## **4.4 建造者模式**\r\n\r\n- **定义与特点**：建造者模式将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。它通常用于构建复杂的对象。\r\n  \r\n- **构建复杂对象的步骤**：首先定义一个公共接口描述步骤，然后通过具体建造者实现这些步骤，最后通过指挥者类调用这些步骤构建最终的对象。\r\n  \r\n- **示例：构建复杂的配置对象**：比如构建一个复杂的SQL查询语句对象，其中包含多个条件和排序规则等属性。\r\n\r\n```python\r\nclass SQLQueryBuilder:\r\n    def __init__(self):\r\n        self.query = {}\r\n\r\n    def select(self, columns):\r\n        self.query["SELECT"] = columns\r\n        return self\r\n\r\n    def from_table(self, table):\r\n        self.query["FROM"] = table\r\n        return self\r\n\r\n    def where(self, condition):\r\n        self.query["WHERE"] = condition\r\n        return self\r\n\r\n    def build(self):\r\n        query_parts = []\r\n        for key, value in self.query.items():\r\n            query_parts.append(f"{key} {value}")\r\n        return " ".join(query_parts)\r\n\r\n# 使用示例\r\nbuilder = SQLQueryBuilder()\r\nquery = builder.select("name, age").from_table("users").where("age > 18").build()\r\nprint(query)\r\n# 输出: SELECT name, age FROM users WHERE age > 18\r\n```\r\n\r\n## **4.5 原型模式**\r\n\r\n- **定义与特点**：原型模式是指当创建给定类的实例很复杂或成本高昂时，先创建一个实例，然后通过复制这个实例来创建新的实例。这可以通过浅拷贝或深拷贝实现。\r\n  \r\n- **浅拷贝与深拷贝**：浅拷贝复制对象的基本数据类型成员，但共享引用类型的成员；深拷贝则会递归地复制整个对象图，包括引用类型的成员。\r\n  \r\n- **应用场景与示例**：常用于避免创建复杂对象的高成本操作，如游戏中的角色克隆。示例可以是在图形编辑软件中复制一个复杂的形状对象，而不是重新创建一个新的。\r\n\r\n```python\r\n\r\nimport copy\r\n\r\nclass Prototype:\r\n    def __init__(self, name):\r\n        self.name = name\r\n        self.components = ["Component1", "Component2"]\r\n\r\n    def clone(self, deep=False):\r\n        if deep:\r\n            return copy.deepcopy(self)\r\n        else:\r\n            return copy.copy(self)\r\n\r\n# 使用示例\r\noriginal = Prototype("Original")\r\nshallow_copy = original.clone()\r\ndeep_copy = original.clone(deep=True)\r\n\r\nprint(original.components is shallow_copy.components)  # 输出: True (浅拷贝共享引用)\r\nprint(original.components is deep_copy.components)     # 输出: False (深拷贝独立副本)\r\n```\r\n\r\n---'}}]);
//# sourceMappingURL=7432.b7aee3ef.js.map