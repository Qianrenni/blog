{"version":3,"file":"js/7102.9516dc4d.js","mappings":"oHAAA,imO","sources":["webpack://myblog/./src/assets/md/java/content/011-十一Java 数据安全.md"],"sourcesContent":["export default \"# **十一、Java 数据安全**\\r\\n\\r\\n数据安全是软件开发中的核心问题之一，尤其是在涉及敏感信息（如用户密码、支付信息）的场景中。Java 提供了多种机制和工具来保护数据的安全性。本节将从以下几个方面详细讲解 Java 数据安全的核心内容：\\r\\n\\r\\n---\\r\\n\\r\\n## **1. 数据加密**\\r\\n\\r\\n加密是保护数据安全的重要手段，通过将明文数据转换为密文，确保只有拥有正确密钥的人才能解密并读取数据。\\r\\n\\r\\n### **1.1 对称加密**\\r\\n\\r\\n对称加密使用同一个密钥进行加密和解密，适合快速加密大量数据。常见的对称加密算法包括 AES 和 DES。\\r\\n\\r\\n#### **AES 加密示例**\\r\\n\\r\\n```java\\r\\nimport javax.crypto.Cipher;\\r\\nimport javax.crypto.KeyGenerator;\\r\\nimport javax.crypto.SecretKey;\\r\\n\\r\\npublic class AESExample {\\r\\n    public static void main(String[] args) throws Exception {\\r\\n        // 生成密钥\\r\\n        KeyGenerator keyGen = KeyGenerator.getInstance(\\\"AES\\\");\\r\\n        keyGen.init(128); // 密钥长度\\r\\n        SecretKey secretKey = keyGen.generateKey();\\r\\n\\r\\n        // 加密\\r\\n        Cipher cipher = Cipher.getInstance(\\\"AES\\\");\\r\\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\\r\\n        byte[] encryptedData = cipher.doFinal(\\\"Sensitive Data\\\".getBytes());\\r\\n        System.out.println(\\\"Encrypted: \\\" + new String(encryptedData));\\r\\n\\r\\n        // 解密\\r\\n        cipher.init(Cipher.DECRYPT_MODE, secretKey);\\r\\n        byte[] decryptedData = cipher.doFinal(encryptedData);\\r\\n        System.out.println(\\\"Decrypted: \\\" + new String(decryptedData));\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n### **1.2 非对称加密**\\r\\n\\r\\n非对称加密使用一对密钥（公钥和私钥），其中一个用于加密，另一个用于解密。常见的非对称加密算法包括 RSA。\\r\\n\\r\\n#### **RSA 加密示例**\\r\\n\\r\\n```java\\r\\nimport java.security.*;\\r\\nimport javax.crypto.Cipher;\\r\\n\\r\\npublic class RSAExample {\\r\\n    public static void main(String[] args) throws Exception {\\r\\n        // 生成密钥对\\r\\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\\\"RSA\\\");\\r\\n        keyGen.initialize(2048);\\r\\n        KeyPair keyPair = keyGen.generateKeyPair();\\r\\n        PublicKey publicKey = keyPair.getPublic();\\r\\n        PrivateKey privateKey = keyPair.getPrivate();\\r\\n\\r\\n        // 加密\\r\\n        Cipher cipher = Cipher.getInstance(\\\"RSA\\\");\\r\\n        cipher.init(Cipher.ENCRYPT_MODE, publicKey);\\r\\n        byte[] encryptedData = cipher.doFinal(\\\"Sensitive Data\\\".getBytes());\\r\\n        System.out.println(\\\"Encrypted: \\\" + new String(encryptedData));\\r\\n\\r\\n        // 解密\\r\\n        cipher.init(Cipher.DECRYPT_MODE, privateKey);\\r\\n        byte[] decryptedData = cipher.doFinal(encryptedData);\\r\\n        System.out.println(\\\"Decrypted: \\\" + new String(decryptedData));\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **2. 数据完整性**\\r\\n\\r\\n数据完整性确保数据在传输或存储过程中未被篡改。常用的方法是使用哈希函数和数字签名。\\r\\n\\r\\n### **2.1 哈希函数**\\r\\n\\r\\n哈希函数将任意长度的数据映射为固定长度的值，且不可逆。常见的哈希算法包括 MD5 和 SHA 系列。\\r\\n\\r\\n#### **SHA-256 示例**\\r\\n\\r\\n```java\\r\\nimport java.security.MessageDigest;\\r\\n\\r\\npublic class HashExample {\\r\\n    public static void main(String[] args) throws Exception {\\r\\n        String data = \\\"Sensitive Data\\\";\\r\\n        MessageDigest digest = MessageDigest.getInstance(\\\"SHA-256\\\");\\r\\n        byte[] hash = digest.digest(data.getBytes());\\r\\n        System.out.println(\\\"Hash: \\\" + bytesToHex(hash));\\r\\n    }\\r\\n\\r\\n    private static String bytesToHex(byte[] hash) {\\r\\n        StringBuilder hexString = new StringBuilder();\\r\\n        for (byte b : hash) {\\r\\n            String hex = Integer.toHexString(0xff & b);\\r\\n            if (hex.length() == 1) hexString.append('0');\\r\\n            hexString.append(hex);\\r\\n        }\\r\\n        return hexString.toString();\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n### **2.2 数字签名**\\r\\n\\r\\n数字签名结合了哈希函数和非对称加密，用于验证数据的来源和完整性。\\r\\n\\r\\n#### **数字签名示例**\\r\\n\\r\\n```java\\r\\nimport java.security.*;\\r\\nimport java.util.Base64;\\r\\n\\r\\npublic class SignatureExample {\\r\\n    public static void main(String[] args) throws Exception {\\r\\n        // 生成密钥对\\r\\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\\\"RSA\\\");\\r\\n        keyGen.initialize(2048);\\r\\n        KeyPair keyPair = keyGen.generateKeyPair();\\r\\n        PrivateKey privateKey = keyPair.getPrivate();\\r\\n        PublicKey publicKey = keyPair.getPublic();\\r\\n\\r\\n        // 签名\\r\\n        Signature signature = Signature.getInstance(\\\"SHA256withRSA\\\");\\r\\n        signature.initSign(privateKey);\\r\\n        signature.update(\\\"Sensitive Data\\\".getBytes());\\r\\n        byte[] digitalSignature = signature.sign();\\r\\n        System.out.println(\\\"Signature: \\\" + Base64.getEncoder().encodeToString(digitalSignature));\\r\\n\\r\\n        // 验证签名\\r\\n        signature.initVerify(publicKey);\\r\\n        signature.update(\\\"Sensitive Data\\\".getBytes());\\r\\n        boolean isVerified = signature.verify(digitalSignature);\\r\\n        System.out.println(\\\"Verified: \\\" + isVerified);\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **3. 数据存储安全**\\r\\n\\r\\n在存储敏感数据时，必须采取措施防止数据泄露。\\r\\n\\r\\n### **3.1 密码存储**\\r\\n\\r\\n密码不应以明文形式存储，而应使用加盐哈希的方式存储。\\r\\n\\r\\n#### **加盐哈希示例**\\r\\n\\r\\n```java\\r\\nimport java.security.MessageDigest;\\r\\nimport java.security.SecureRandom;\\r\\n\\r\\npublic class PasswordStorageExample {\\r\\n    public static void main(String[] args) throws Exception {\\r\\n        String password = \\\"userPassword\\\";\\r\\n\\r\\n        // 生成随机盐\\r\\n        SecureRandom random = new SecureRandom();\\r\\n        byte[] salt = new byte[16];\\r\\n        random.nextBytes(salt);\\r\\n\\r\\n        // 加盐哈希\\r\\n        MessageDigest digest = MessageDigest.getInstance(\\\"SHA-256\\\");\\r\\n        digest.update(salt);\\r\\n        byte[] hash = digest.digest(password.getBytes());\\r\\n\\r\\n        System.out.println(\\\"Salt: \\\" + bytesToHex(salt));\\r\\n        System.out.println(\\\"Hashed Password: \\\" + bytesToHex(hash));\\r\\n    }\\r\\n\\r\\n    private static String bytesToHex(byte[] bytes) {\\r\\n        StringBuilder hexString = new StringBuilder();\\r\\n        for (byte b : bytes) {\\r\\n            String hex = Integer.toHexString(0xff & b);\\r\\n            if (hex.length() == 1) hexString.append('0');\\r\\n            hexString.append(hex);\\r\\n        }\\r\\n        return hexString.toString();\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n### **3.2 数据库加密**\\r\\n\\r\\n敏感数据在存储到数据库之前可以加密，例如使用 JPA 的 `@Convert` 注解实现字段级加密。\\r\\n\\r\\n---\\r\\n\\r\\n## **4. 数据传输安全**\\r\\n\\r\\n在网络传输中，必须确保数据不被窃听或篡改。SSL/TLS 是最常见的解决方案。\\r\\n\\r\\n### **4.1 使用 HTTPS**\\r\\n\\r\\nHTTPS 是基于 SSL/TLS 的安全协议，用于保护客户端与服务器之间的通信。\\r\\n\\r\\n#### **启用 HTTPS 示例**\\r\\n\\r\\n1. 在服务器端配置 SSL 证书。\\r\\n2. 客户端使用 `HttpsURLConnection` 进行安全连接：\\r\\n\\r\\n```java\\r\\nimport javax.net.ssl.HttpsURLConnection;\\r\\nimport java.io.BufferedReader;\\r\\nimport java.io.InputStreamReader;\\r\\nimport java.net.URL;\\r\\n\\r\\npublic class HttpsExample {\\r\\n    public static void main(String[] args) throws Exception {\\r\\n        URL url = new URL(\\\"https://example.com\\\");\\r\\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\\r\\n        connection.setRequestMethod(\\\"GET\\\");\\r\\n\\r\\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\\r\\n        String line;\\r\\n        while ((line = reader.readLine()) != null) {\\r\\n            System.out.println(line);\\r\\n        }\\r\\n        reader.close();\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **5. 安全编码实践**\\r\\n\\r\\n除了上述技术手段，还需要遵循安全编码的最佳实践：\\r\\n\\r\\n- **输入验证**：防止 SQL 注入、XSS 攻击等。\\r\\n- **最小权限原则**：程序只请求必要的权限。\\r\\n- **日志管理**：避免记录敏感信息。\\r\\n- **依赖更新**：定期更新第三方库以修复已知漏洞。\\r\\n\\r\\n---\\r\\n\\r\\n## **总结**\\r\\n\\r\\n- **数据加密** 是保护数据安全的核心，包括对称加密（AES）、非对称加密（RSA）和哈希函数（SHA）。\\r\\n- **数据完整性** 通过哈希函数和数字签名确保数据未被篡改。\\r\\n- **数据存储安全** 需要使用加盐哈希存储密码，并考虑数据库加密。\\r\\n- **数据传输安全** 通常依赖于 HTTPS 和 SSL/TLS。\\r\\n- **安全编码实践** 是防范攻击的基础。\\r\\n\\r\\n---\";"],"names":[],"sourceRoot":""}