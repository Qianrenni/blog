"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[36533],{36533:function(r,n,e){e.r(n),n["default"]='## **3. 使用 Windows API**\r\n\r\nWindows 提供了自己的线程管理 API，适用于 Windows 系统。\r\n\r\n### **3.1 创建线程**\r\n\r\n- 使用 `CreateThread` 函数创建线程。\r\n- **语法**：\r\n\r\n  ```c\r\n  HANDLE CreateThread(\r\n      LPSECURITY_ATTRIBUTES lpThreadAttributes,\r\n      SIZE_T dwStackSize,\r\n      LPTHREAD_START_ROUTINE lpStartAddress,\r\n      LPVOID lpParameter,\r\n      DWORD dwCreationFlags,\r\n      LPDWORD lpThreadId\r\n  );\r\n  ```\r\n\r\n  - `lpStartAddress`：线程启动时调用的函数。\r\n  - `lpParameter`：传递给线程函数的参数。\r\n\r\n- **示例**：\r\n\r\n  ```c\r\n  #include <stdio.h>\r\n  #include <windows.h>\r\n\r\n  DWORD WINAPI printMessage(LPVOID message) {\r\n      printf("Thread: %s\\n", (char *)message);\r\n      return 0;\r\n  }\r\n\r\n  int main() {\r\n      HANDLE thread;\r\n      char *msg = "Hello from thread!";\r\n      \r\n      thread = CreateThread(NULL, 0, printMessage, (LPVOID)msg, 0, NULL);\r\n      if (thread == NULL) {\r\n          fprintf(stderr, "Failed to create thread.\\n");\r\n          return -1;\r\n      }\r\n\r\n      // 等待线程结束\r\n      WaitForSingleObject(thread, INFINITE);\r\n\r\n      printf("Main thread finished.\\n");\r\n      CloseHandle(thread);\r\n      return 0;\r\n  }\r\n  ```\r\n\r\n---\r\n\r\n### **3.2 等待线程结束**\r\n\r\n- 使用 `WaitForSingleObject` 等待线程完成。\r\n- **语法**：\r\n\r\n  ```c\r\n  DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);\r\n  ```\r\n\r\n  - `hHandle`：线程句柄。\r\n  - `dwMilliseconds`：等待时间（`INFINITE` 表示无限等待）。\r\n\r\n- **示例**：\r\n\r\n  ```c\r\n  WaitForSingleObject(thread, INFINITE);\r\n  ```\r\n\r\n---\r\n\r\n### **3.3 关闭线程句柄**\r\n\r\n- 使用 `CloseHandle` 关闭线程句柄。\r\n- **语法**：\r\n\r\n  ```c\r\n  BOOL CloseHandle(HANDLE hObject);\r\n  ```\r\n\r\n- **示例**：\r\n\r\n  ```c\r\n  CloseHandle(thread);\r\n  ```\r\n\r\n---'}}]);
//# sourceMappingURL=36533.70238094.js.map