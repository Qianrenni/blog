"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[466],{30466:function(n,r,e){e.r(r),r["default"]='# **六、多线程与并发**\r\n\r\n在现代软件开发中，多线程和并发编程是提高程序性能的重要手段。通过合理利用多线程技术，可以充分利用多核CPU的优势，提升程序的响应速度和吞吐量。以下是对多线程与并发相关知识点的详细讲解。\r\n\r\n---\r\n\r\n## **1. 线程基础**\r\n\r\n### **1.1 线程的概念与生命周期**\r\n\r\n- **线程的概念**：  \r\n  线程是操作系统能够独立调度的基本单位，是进程中的一个执行路径。一个进程可以包含多个线程，所有线程共享进程的内存空间（如堆、方法区等），但每个线程有自己的栈。\r\n  \r\n- **线程的生命周期**：  \r\n  Java线程有以下几种状态：\r\n  1. **新建 (New)**：线程对象被创建，但尚未启动。\r\n  2. **就绪 (Runnable)**：线程已启动，等待CPU调度执行。\r\n  3. **运行 (Running)**：线程正在CPU上执行。\r\n  4. **阻塞 (Blocked)**：线程因等待资源（如I/O操作、锁）而暂停。\r\n  5. **等待 (Waiting)**：线程进入无限期等待，直到其他线程显式唤醒（如调用`wait()`）。\r\n  6. **超时等待 (Timed Waiting)**：线程进入有限期等待（如调用`sleep()`或带超时参数的`wait()`）。\r\n  7. **终止 (Terminated)**：线程执行完毕或因异常退出。\r\n\r\n---\r\n\r\n### **1.2 创建线程的方式**\r\n\r\nJava中有多种方式创建线程：\r\n\r\n#### **1.2.1 继承 `Thread` 类**\r\n\r\n```java\r\nclass MyThread extends Thread {\r\n    @Override\r\n    public void run() {\r\n        System.out.println("Thread is running");\r\n    }\r\n}\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        MyThread thread = new MyThread();\r\n        thread.start(); // 启动线程\r\n    }\r\n}\r\n```\r\n\r\n- **优点**：简单直观。\r\n- **缺点**：由于Java不支持多继承，如果类已经继承了其他类，则无法使用该方式。\r\n\r\n---\r\n\r\n#### **1.2.2 实现 `Runnable` 接口**\r\n\r\n```java\r\nclass MyRunnable implements Runnable {\r\n    @Override\r\n    public void run() {\r\n        System.out.println("Runnable is running");\r\n    }\r\n}\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        Thread thread = new Thread(new MyRunnable());\r\n        thread.start();\r\n    }\r\n}\r\n```\r\n\r\n- **优点**：避免单继承限制，更灵活。\r\n- **缺点**：需要额外创建`Thread`对象。\r\n\r\n---\r\n\r\n#### **1.2.3 使用线程池**\r\n\r\n线程池是一种管理线程的高级方式，通过复用线程减少频繁创建和销毁线程的开销。\r\n\r\n```java\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.Executors;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        ExecutorService executor = Executors.newFixedThreadPool(2); // 创建固定大小的线程池\r\n        for (int i = 0; i < 5; i++) {\r\n            executor.submit(() -> System.out.println("Task executed by " + Thread.currentThread().getName()));\r\n        }\r\n        executor.shutdown(); // 关闭线程池\r\n    }\r\n}\r\n```\r\n\r\n- **优点**：高效、可控性强。\r\n- **常见实现**：\r\n  - `Executors.newFixedThreadPool(int nThreads)`：创建固定大小的线程池。\r\n  - `Executors.newCachedThreadPool()`：根据需要动态调整线程数量。\r\n  - `Executors.newSingleThreadExecutor()`：单线程的线程池。\r\n\r\n---\r\n\r\n## **2. 线程同步**\r\n\r\n### **2.1 `synchronized` 关键字**\r\n\r\n`synchronized` 是Java提供的内置锁机制，用于保证多线程环境下的数据一致性。\r\n\r\n#### **2.1.1 方法级同步**\r\n\r\n```java\r\npublic synchronized void method() {\r\n    // 同步代码块\r\n}\r\n```\r\n\r\n#### **2.1.2 块级同步**\r\n\r\n```java\r\npublic void method() {\r\n    synchronized (this) {\r\n        // 同步代码块\r\n    }\r\n}\r\n```\r\n\r\n#### **2.1.3 锁的对象**\r\n\r\n- `synchronized` 可以作用于实例方法、静态方法或指定对象。\r\n- 静态方法的锁是类对象（`Class` 对象）。\r\n\r\n---\r\n\r\n### **2.2 死锁的概念与避免**\r\n\r\n- **死锁定义**：多个线程相互持有对方所需的资源，导致彼此永久阻塞。\r\n- **死锁条件**（必要条件）：\r\n  1. **互斥**：资源只能被一个线程占用。\r\n  2. **占有且等待**：线程持有资源的同时等待其他资源。\r\n  3. **不可剥夺**：资源不能被强行抢占。\r\n  4. **循环等待**：存在一个线程等待环路。\r\n\r\n- **避免死锁的方法**：\r\n  - 按顺序获取锁。\r\n  - 使用定时锁（`tryLock`）。\r\n  - 减少锁的粒度。\r\n\r\n---\r\n\r\n### **2.3 `volatile` 关键字**\r\n\r\n- **作用**：确保变量的可见性，即每次读取时都从主内存加载最新值。\r\n- **适用场景**：适用于简单的标志位变量。\r\n- **注意**：`volatile` 不保证原子性，不能替代锁。\r\n\r\n```java\r\nprivate volatile boolean flag = true;\r\n\r\npublic void stop() {\r\n    flag = false;\r\n}\r\n```\r\n\r\n---\r\n\r\n## **3. 高级并发工具**\r\n\r\n### **3.1 `Lock` 接口与 `ReentrantLock`**\r\n\r\n`Lock` 提供比 `synchronized` 更灵活的锁机制。\r\n\r\n```java\r\nimport java.util.concurrent.locks.Lock;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\n\r\npublic class Main {\r\n    private final Lock lock = new ReentrantLock();\r\n\r\n    public void method() {\r\n        lock.lock();\r\n        try {\r\n            // 临界区代码\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n- **优点**：\r\n  - 支持公平锁和非公平锁。\r\n  - 提供可中断锁（`lockInterruptibly`）。\r\n  - 支持尝试获取锁（`tryLock`）。\r\n\r\n---\r\n\r\n### **3.2 并发集合**\r\n\r\nJava提供了多种线程安全的集合类。\r\n\r\n- **`ConcurrentHashMap`**：分段锁机制，支持高并发读写。\r\n- **`CopyOnWriteArrayList`**：写时复制，适合读多写少的场景。\r\n\r\n```java\r\nimport java.util.concurrent.ConcurrentHashMap;\r\n\r\nConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\r\nmap.put("key", 1);\r\n```\r\n\r\n---\r\n\r\n### **3.3 线程池**\r\n\r\n线程池的核心类是 `ThreadPoolExecutor`，它允许开发者自定义线程池。\r\n\r\n```java\r\nimport java.util.concurrent.*;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(\r\n            2, // 核心线程数\r\n            4, // 最大线程数\r\n            10, // 空闲线程存活时间\r\n            TimeUnit.SECONDS,\r\n            new LinkedBlockingQueue<>()\r\n        );\r\n        executor.submit(() -> System.out.println("Task executed"));\r\n        executor.shutdown();\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### **3.4 原子类**\r\n\r\n原子类提供无锁的线程安全操作。\r\n\r\n- **常用原子类**：\r\n  - `AtomicInteger`\r\n  - `AtomicBoolean`\r\n  - `AtomicReference`\r\n\r\n```java\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\nAtomicInteger counter = new AtomicInteger(0);\r\ncounter.incrementAndGet(); // 原子操作\r\n```\r\n\r\n---\r\n\r\n## **4. 线程间通信**\r\n\r\n### **4.1 `wait()`, `notify()`, `notifyAll()`**\r\n\r\n这些方法用于线程间的协作，必须在同步块中使用。\r\n\r\n```java\r\nsynchronized (obj) {\r\n    while (conditionNotMet) {\r\n        obj.wait(); // 当前线程等待\r\n    }\r\n    // 执行逻辑\r\n    obj.notify(); // 唤醒一个等待线程\r\n    obj.notifyAll(); // 唤醒所有等待线程\r\n}\r\n```\r\n\r\n---\r\n\r\n### **4.2 生产者-消费者模式**\r\n\r\n生产者-消费者模式是一种经典的线程间通信模型。\r\n\r\n```java\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\n\r\npublic class ProducerConsumer {\r\n    private final Queue<Integer> queue = new LinkedList<>();\r\n    private final int CAPACITY = 5;\r\n    private final Object lock = new Object();\r\n\r\n    public void produce() throws InterruptedException {\r\n        int value = 0;\r\n        while (true) {\r\n            synchronized (lock) {\r\n                while (queue.size() == CAPACITY) {\r\n                    lock.wait();\r\n                }\r\n                queue.add(value++);\r\n                lock.notify();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void consume() throws InterruptedException {\r\n        while (true) {\r\n            synchronized (lock) {\r\n                while (queue.isEmpty()) {\r\n                    lock.wait();\r\n                }\r\n                int value = queue.poll();\r\n                System.out.println("Consumed: " + value);\r\n                lock.notify();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---'}}]);
//# sourceMappingURL=466.ba843e80.js.map