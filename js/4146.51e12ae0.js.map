{"version":3,"file":"js/4146.51e12ae0.js","mappings":"mHAAA,swP","sources":["webpack://myblog/./src/assets/md/software/content/005-5 结构型模式详解.md"],"sourcesContent":["export default \"# **5. 结构型模式详解**\\r\\n\\r\\n以下是结构型模式的详细介绍及代码示例，基于 Python 编程语言实现。\\r\\n\\r\\n---\\r\\n\\r\\n## **5.1 适配器模式**\\r\\n\\r\\n### **定义与特点**\\r\\n\\r\\n适配器模式将一个类的接口转换成客户端期望的另一个接口，使得原本不兼容的类可以一起工作。其核心思想是通过适配器类将现有类的接口转换为另一种接口。\\r\\n\\r\\n### **类适配器与对象适配器**\\r\\n\\r\\n- **类适配器**：通过继承实现适配。\\r\\n- **对象适配器**：通过组合实现适配。\\r\\n\\r\\n### **示例：兼容不同接口的类**\\r\\n\\r\\n```python\\r\\n# 目标接口\\r\\nclass Target:\\r\\n    def request(self):\\r\\n        return \\\"Target: The default target's behavior.\\\"\\r\\n\\r\\n# 被适配的类\\r\\nclass Adaptee:\\r\\n    def specific_request(self):\\r\\n        return \\\".eetpadA eht fo roivaheb laicepS\\\"\\r\\n\\r\\n# 对象适配器\\r\\nclass Adapter(Target):\\r\\n    def __init__(self, adaptee):\\r\\n        self.adaptee = adaptee\\r\\n\\r\\n    def request(self):\\r\\n        return f\\\"Adapter: (TRANSLATED) {self.adaptee.specific_request()[::-1]}\\\"\\r\\n\\r\\n# 使用示例\\r\\nadaptee = Adaptee()\\r\\nadapter = Adapter(adaptee)\\r\\nprint(adapter.request())\\r\\n# 输出: Adapter: (TRANSLATED) Specific behavior of the Adaptee.\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **5.2 装饰器模式**\\r\\n\\r\\n### **定义与特点**\\r\\n\\r\\n装饰器模式允许动态地给对象添加行为，而无需修改原始类的代码。它通过创建一个包装对象（装饰器）来增强目标对象的功能。\\r\\n\\r\\n### **动态扩展对象功能**\\r\\n\\r\\n- 装饰器模式的核心是“组合优于继承”。\\r\\n\\r\\n### **示例：Java IO 流中的装饰器模式**\\r\\n\\r\\n```python\\r\\n# 基础组件\\r\\nclass Component:\\r\\n    def operation(self):\\r\\n        pass\\r\\n\\r\\nclass ConcreteComponent(Component):\\r\\n    def operation(self):\\r\\n        return \\\"ConcreteComponent\\\"\\r\\n\\r\\n# 装饰器基类\\r\\nclass Decorator(Component):\\r\\n    def __init__(self, component):\\r\\n        self.component = component\\r\\n\\r\\n    def operation(self):\\r\\n        return self.component.operation()\\r\\n\\r\\n# 具体装饰器\\r\\nclass ConcreteDecoratorA(Decorator):\\r\\n    def operation(self):\\r\\n        return f\\\"ConcreteDecoratorA({self.component.operation()})\\\"\\r\\n\\r\\nclass ConcreteDecoratorB(Decorator):\\r\\n    def operation(self):\\r\\n        return f\\\"ConcreteDecoratorB({self.component.operation()})\\\"\\r\\n\\r\\n# 使用示例\\r\\ncomponent = ConcreteComponent()\\r\\ndecorator_a = ConcreteDecoratorA(component)\\r\\ndecorator_b = ConcreteDecoratorB(decorator_a)\\r\\nprint(decorator_b.operation())\\r\\n# 输出: ConcreteDecoratorB(ConcreteDecoratorA(ConcreteComponent))\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **5.3 代理模式**\\r\\n\\r\\n### **定义与特点**\\r\\n\\r\\n代理模式为某对象提供一个代理，以控制对该对象的访问。代理可以在访问对象时添加额外的操作，例如权限检查、延迟加载等。\\r\\n\\r\\n### **静态代理与动态代理**\\r\\n\\r\\n- **静态代理**：手动编写代理类。\\r\\n- **动态代理**：运行时动态生成代理类。\\r\\n\\r\\n### **示例：远程代理、虚拟代理**\\r\\n\\r\\n```python\\r\\n# 抽象主题\\r\\nclass Subject:\\r\\n    def request(self):\\r\\n        pass\\r\\n\\r\\n# 真实主题\\r\\nclass RealSubject(Subject):\\r\\n    def request(self):\\r\\n        return \\\"RealSubject: Handling request.\\\"\\r\\n\\r\\n# 代理\\r\\nclass Proxy(Subject):\\r\\n    def __init__(self, real_subject):\\r\\n        self.real_subject = real_subject\\r\\n\\r\\n    def request(self):\\r\\n        if self.check_access():\\r\\n            result = self.real_subject.request()\\r\\n            self.log_access()\\r\\n            return result\\r\\n\\r\\n    def check_access(self):\\r\\n        print(\\\"Proxy: Checking access prior to firing a real request.\\\")\\r\\n        return True\\r\\n\\r\\n    def log_access(self):\\r\\n        print(\\\"Proxy: Logging the time of request.\\\")\\r\\n\\r\\n# 使用示例\\r\\nreal_subject = RealSubject()\\r\\nproxy = Proxy(real_subject)\\r\\nprint(proxy.request())\\r\\n# 输出:\\r\\n# Proxy: Checking access prior to firing a real request.\\r\\n# RealSubject: Handling request.\\r\\n# Proxy: Logging the time of request.\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **5.4 外观模式**\\r\\n\\r\\n### **定义与特点**\\r\\n\\r\\n外观模式为子系统中的一组接口提供一个统一的接口，简化客户端与子系统的交互。\\r\\n\\r\\n### **提供统一接口简化子系统**\\r\\n\\r\\n- 外观模式隐藏了子系统的复杂性，使客户端只需与外观类交互。\\r\\n\\r\\n### **示例：复杂系统的简化接口**\\r\\n\\r\\n```python\\r\\n# 子系统类\\r\\nclass SubsystemA:\\r\\n    def operation_a(self):\\r\\n        return \\\"SubsystemA: Operation A\\\"\\r\\n\\r\\nclass SubsystemB:\\r\\n    def operation_b(self):\\r\\n        return \\\"SubsystemB: Operation B\\\"\\r\\n\\r\\nclass SubsystemC:\\r\\n    def operation_c(self):\\r\\n        return \\\"SubsystemC: Operation C\\\"\\r\\n\\r\\n# 外观类\\r\\nclass Facade:\\r\\n    def __init__(self):\\r\\n        self.subsystem_a = SubsystemA()\\r\\n        self.subsystem_b = SubsystemB()\\r\\n        self.subsystem_c = SubsystemC()\\r\\n\\r\\n    def operation(self):\\r\\n        results = []\\r\\n        results.append(self.subsystem_a.operation_a())\\r\\n        results.append(self.subsystem_b.operation_b())\\r\\n        results.append(self.subsystem_c.operation_c())\\r\\n        return \\\"\\\\n\\\".join(results)\\r\\n\\r\\n# 使用示例\\r\\nfacade = Facade()\\r\\nprint(facade.operation())\\r\\n# 输出:\\r\\n# SubsystemA: Operation A\\r\\n# SubsystemB: Operation B\\r\\n# SubsystemC: Operation C\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **5.5 桥接模式**\\r\\n\\r\\n### **定义与特点**\\r\\n\\r\\n桥接模式将抽象部分与实现部分分离，使它们可以独立变化。它通过组合的方式实现解耦。\\r\\n\\r\\n### **分离抽象与实现**\\r\\n\\r\\n- 抽象类持有实现类的引用，而不是继承实现类。\\r\\n\\r\\n### **示例：跨平台图形绘制**\\r\\n\\r\\n```python\\r\\n# 实现类接口\\r\\nclass DrawingAPI:\\r\\n    def draw_circle(self, x, y, radius):\\r\\n        pass\\r\\n\\r\\n# 具体实现类\\r\\nclass DrawingAPI1(DrawingAPI):\\r\\n    def draw_circle(self, x, y, radius):\\r\\n        return f\\\"DrawingAPI1.circle at ({x}, {y}) with radius {radius}\\\"\\r\\n\\r\\nclass DrawingAPI2(DrawingAPI):\\r\\n    def draw_circle(self, x, y, radius):\\r\\n        return f\\\"DrawingAPI2.circle at ({x}, {y}) with radius {radius}\\\"\\r\\n\\r\\n# 抽象类\\r\\nclass Shape:\\r\\n    def __init__(self, drawing_api):\\r\\n        self.drawing_api = drawing_api\\r\\n\\r\\n    def draw(self):\\r\\n        pass\\r\\n\\r\\n# 扩展抽象类\\r\\nclass CircleShape(Shape):\\r\\n    def __init__(self, x, y, radius, drawing_api):\\r\\n        super().__init__(drawing_api)\\r\\n        self.x = x\\r\\n        self.y = y\\r\\n        self.radius = radius\\r\\n\\r\\n    def draw(self):\\r\\n        return self.drawing_api.draw_circle(self.x, self.y, self.radius)\\r\\n\\r\\n# 使用示例\\r\\napi1 = DrawingAPI1()\\r\\ncircle1 = CircleShape(1, 2, 3, api1)\\r\\nprint(circle1.draw())\\r\\n# 输出: DrawingAPI1.circle at (1, 2) with radius 3\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **5.6 组合模式**\\r\\n\\r\\n### **定义与特点**\\r\\n\\r\\n组合模式允许将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户端可以统一处理单个对象和组合对象。\\r\\n\\r\\n### **树形结构的处理**\\r\\n\\r\\n- 叶节点和组合节点共享相同的接口。\\r\\n\\r\\n### **示例：文件系统**\\r\\n\\r\\n```python\\r\\nfrom abc import ABC, abstractmethod\\r\\n\\r\\n# 抽象组件\\r\\nclass Component(ABC):\\r\\n    @abstractmethod\\r\\n    def show(self):\\r\\n        pass\\r\\n\\r\\n# 叶节点\\r\\nclass File(Component):\\r\\n    def __init__(self, name):\\r\\n        self.name = name\\r\\n\\r\\n    def show(self):\\r\\n        return f\\\"File: {self.name}\\\"\\r\\n\\r\\n# 组合节点\\r\\nclass Directory(Component):\\r\\n    def __init__(self, name):\\r\\n        self.name = name\\r\\n        self.children = []\\r\\n\\r\\n    def add(self, component):\\r\\n        self.children.append(component)\\r\\n\\r\\n    def show(self):\\r\\n        results = [f\\\"Directory: {self.name}\\\"]\\r\\n        for child in self.children:\\r\\n            results.append(child.show())\\r\\n        return \\\"\\\\n\\\".join(results)\\r\\n\\r\\n# 使用示例\\r\\nfile1 = File(\\\"file1.txt\\\")\\r\\nfile2 = File(\\\"file2.txt\\\")\\r\\ndirectory = Directory(\\\"root\\\")\\r\\ndirectory.add(file1)\\r\\ndirectory.add(file2)\\r\\nprint(directory.show())\\r\\n# 输出:\\r\\n# Directory: root\\r\\n# File: file1.txt\\r\\n# File: file2.txt\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## **5.7 享元模式**\\r\\n\\r\\n### **定义与特点**\\r\\n\\r\\n享元模式通过共享技术实现相同或相似对象的重用，从而节省内存。\\r\\n\\r\\n### **共享对象以节省内存**\\r\\n\\r\\n- 适用于需要大量细粒度对象的场景。\\r\\n\\r\\n### **示例：字符串池**\\r\\n\\r\\n```python\\r\\nclass Flyweight:\\r\\n    def __init__(self, shared_state):\\r\\n        self.shared_state = shared_state\\r\\n\\r\\n    def operation(self, unique_state):\\r\\n        return f\\\"Flyweight: Shared ({self.shared_state}) and Unique ({unique_state})\\\"\\r\\n\\r\\nclass FlyweightFactory:\\r\\n    _flyweights = {}\\r\\n\\r\\n    def get_flyweight(self, shared_state):\\r\\n        if shared_state not in self._flyweights:\\r\\n            self._flyweights[shared_state] = Flyweight(shared_state)\\r\\n        return self._flyweights[shared_state]\\r\\n\\r\\n# 使用示例\\r\\nfactory = FlyweightFactory()\\r\\nflyweight1 = factory.get_flyweight(\\\"shared_state_1\\\")\\r\\nflyweight2 = factory.get_flyweight(\\\"shared_state_1\\\")\\r\\nprint(flyweight1 is flyweight2)  # 输出: True\\r\\nprint(flyweight1.operation(\\\"unique_state_1\\\"))\\r\\n# 输出: Flyweight: Shared (shared_state_1) and Unique (unique_state_1)\\r\\n```\\r\\n\\r\\n---\";"],"names":[],"sourceRoot":""}