"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[14569],{14569:function(r,n,e){e.r(n),n["default"]="## **3. 贪心算法**\r\n\r\n### **霍夫曼编码（最小带权路径）**  \r\n\r\n```python\r\n# 定义一个节点类\r\nclass HuffmanNode:\r\n    def __init__(self, char=None, freq=0, left=None, right=None):\r\n        self.char = char  # 字符\r\n        self.freq = freq  # 频率\r\n        self.left = left  # 左子节点\r\n        self.right = right  # 右子节点\r\n\r\n    # 比较运算符重载，用于优先队列排序\r\n    def __lt__(self, other):\r\n        return self.freq < other.freq\r\n\r\n# 构建霍夫曼树\r\ndef build_huffman_tree(freq_map):\r\n    # 使用最小堆来存储节点\r\n    heap = []\r\n    for char, freq in freq_map.items():\r\n        heapq.heappush(heap, HuffmanNode(char, freq))  # 将每个字符作为叶子节点加入堆中\r\n\r\n    # 合并节点直到只剩下一个根节点\r\n    while len(heap) > 1:\r\n        left = heapq.heappop(heap)\r\n        right = heapq.heappop(heap)\r\n        merged = HuffmanNode(None, left.freq + right.freq, left, right)  # 创建新节点\r\n        heapq.heappush(heap, merged)\r\n\r\n    return heap[0]  # 返回霍夫曼树的根节点\r\n```\r\n\r\n### **区间调度（最多不重叠区间**\r\n\r\n>**问题描述**:给定一组区间，每个区间表示为 [start, end]，表示一个任务从 start 时间开始到 end 时间结束。要求从中选择尽可能多的区间，使得这些区间互不重叠。\r\n\r\n```python\r\ndef interval_scheduling(intervals):\r\n    # 按照结束时间排序\r\n    intervals.sort(key=lambda x: x[1])\r\n\r\n    # 初始化结果集\r\n    result = []\r\n    current_end = float('-inf')  # 当前已选区间的结束时间\r\n\r\n    # 贪心选择\r\n    for start, end in intervals:\r\n        if start >= current_end:  # 如果当前区间与已选区间不重叠\r\n            result.append([start, end])\r\n            current_end = end  # 更新当前结束时间\r\n\r\n    return result\r\n```"}}]);
//# sourceMappingURL=14569.c4105658.js.map