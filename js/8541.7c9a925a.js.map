{"version":3,"file":"js/8541.7c9a925a.js","mappings":"mHAAA,qgJ","sources":["webpack://myblog/./src/assets/md/javascript/content/029-基础知识.md"],"sourcesContent":["export default \"## **基础知识**\\r\\n\\r\\nJavaScript 的基础知识是每个开发者必须掌握的核心内容。以下是关于 `==` 与 `===`、`null` 与 `undefined` 以及 `this` 指向规则的详细讲解。\\r\\n\\r\\n---\\r\\n\\r\\n### **1. `==` 与 `===` 的区别**\\r\\n\\r\\n#### **1.1 `==`（宽松相等）**\\r\\n\\r\\n- **定义**：比较两个值是否相等，会进行类型转换后再比较。\\r\\n- **特点**：\\r\\n  - 如果两个值的类型不同，JavaScript 会尝试将它们转换为相同的类型再比较。\\r\\n  - 可能导致意外的结果，因此不推荐使用。\\r\\n- **示例**：\\r\\n\\r\\n  ```javascript\\r\\n  console.log(5 == \\\"5\\\"); // true（字符串 \\\"5\\\" 被转换为数字 5）\\r\\n  console.log(false == 0); // true（false 被转换为数字 0）\\r\\n  console.log(null == undefined); // true（特殊规则）\\r\\n  ```\\r\\n\\r\\n#### **1.2 `===`（严格相等）**\\r\\n\\r\\n- **定义**：比较两个值是否完全相等，既比较值也比较类型。\\r\\n- **特点**：\\r\\n  - 不进行类型转换，要求值和类型都相同才返回 `true`。\\r\\n  - 推荐使用，避免隐式类型转换带来的问题。\\r\\n- **示例**：\\r\\n\\r\\n  ```javascript\\r\\n  console.log(5 === \\\"5\\\"); // false（类型不同）\\r\\n  console.log(false === 0); // false（类型不同）\\r\\n  console.log(null === undefined); // false（类型不同）\\r\\n  ```\\r\\n\\r\\n#### **总结**\\r\\n\\r\\n| 运算符 | 类型转换 | 使用场景 |\\r\\n|--------|----------|----------|\\r\\n| `==`   | 有       | 避免使用，可能导致意外结果 |\\r\\n| `===`  | 无       | 推荐使用，确保类型安全 |\\r\\n\\r\\n---\\r\\n\\r\\n### **2. `null` 与 `undefined` 的区别**\\r\\n\\r\\n#### **2.1 定义**\\r\\n\\r\\n- **`null`**：\\r\\n  - 表示一个空值或“无”的对象。\\r\\n  - 是一个显式的赋值，通常用于表示某个变量没有值。\\r\\n- **`undefined`**：\\r\\n  - 表示变量已声明但未赋值，或者函数没有返回值。\\r\\n  - 是 JavaScript 的默认值。\\r\\n\\r\\n#### **2.2 区别**\\r\\n\\r\\n| 特性                | `null`                        | `undefined`                     |\\r\\n|---------------------|--------------------------------|----------------------------------|\\r\\n| **数据类型**         | 对象类型（历史遗留问题）        | 原始类型                        |\\r\\n| **含义**             | 显式地表示“无”                  | 默认值，表示未初始化或未定义     |\\r\\n| **比较**             | `null == undefined` 返回 `true` | `null === undefined` 返回 `false` |\\r\\n| **常见场景**         | 手动赋值表示空值                | 变量声明后未赋值或函数无返回值   |\\r\\n\\r\\n#### **示例**\\r\\n\\r\\n```javascript\\r\\nlet a = null;\\r\\nlet b;\\r\\n\\r\\nconsole.log(a); // 输出：null\\r\\nconsole.log(b); // 输出：undefined\\r\\n\\r\\nconsole.log(typeof a); // 输出：object（JS 历史遗留问题）\\r\\nconsole.log(typeof b); // 输出：undefined\\r\\n\\r\\nconsole.log(a == b); // 输出：true\\r\\nconsole.log(a === b); // 输出：false\\r\\n```\\r\\n\\r\\n#### **注意**\\r\\n\\r\\n- **`typeof null`**：\\r\\n  - 由于历史原因，`typeof null` 返回 `\\\"object\\\"`，但这并不意味着 `null` 是对象。\\r\\n  - 实际上，`null` 是一个原始值。\\r\\n\\r\\n---\\r\\n\\r\\n### **3. `this` 的指向规则**\\r\\n\\r\\n`this` 是 JavaScript 中的一个关键字，其值取决于函数的调用方式。以下是 `this` 的四种主要指向规则：\\r\\n\\r\\n#### **3.1 默认绑定**\\r\\n\\r\\n- **定义**：在普通函数调用中，`this` 指向全局对象（浏览器中为 `window`，严格模式下为 `undefined`）。\\r\\n- **示例**：\\r\\n\\r\\n  ```javascript\\r\\n  function showThis() {\\r\\n      console.log(this);\\r\\n  }\\r\\n\\r\\n  showThis(); // 非严格模式：输出 window；严格模式：输出 undefined\\r\\n  ```\\r\\n\\r\\n#### **3.2 隐式绑定**\\r\\n\\r\\n- **定义**：当函数作为对象的方法调用时，`this` 指向调用该方法的对象。\\r\\n- **示例**：\\r\\n\\r\\n  ```javascript\\r\\n  const obj = {\\r\\n      name: \\\"Alice\\\",\\r\\n      greet: function () {\\r\\n          console.log(`Hello, my name is ${this.name}.`);\\r\\n      }\\r\\n  };\\r\\n\\r\\n  obj.greet(); // 输出：Hello, my name is Alice.\\r\\n  ```\\r\\n\\r\\n#### **3.3 显式绑定**\\r\\n\\r\\n- **定义**：通过 `call`、`apply` 或 `bind` 显式指定 `this` 的值。\\r\\n- **示例**：\\r\\n\\r\\n  ```javascript\\r\\n  function greet() {\\r\\n      console.log(`Hello, my name is ${this.name}.`);\\r\\n  }\\r\\n\\r\\n  const person = { name: \\\"Alice\\\" };\\r\\n\\r\\n  greet.call(person); // 输出：Hello, my name is Alice.\\r\\n  greet.apply(person); // 输出：Hello, my name is Alice.\\r\\n\\r\\n  const boundGreet = greet.bind(person);\\r\\n  boundGreet(); // 输出：Hello, my name is Alice.\\r\\n  ```\\r\\n\\r\\n#### **3.4 箭头函数的 `this`**\\r\\n\\r\\n- **定义**：箭头函数没有自己的 `this`，而是继承自外层作用域的 `this`。\\r\\n- **示例**：\\r\\n\\r\\n  ```javascript\\r\\n  const obj = {\\r\\n      name: \\\"Alice\\\",\\r\\n      greet: () => {\\r\\n          console.log(`Hello, my name is ${this.name}.`);\\r\\n      }\\r\\n  };\\r\\n\\r\\n  obj.greet(); // 输出：Hello, my name is undefined.\\r\\n  ```\\r\\n\\r\\n#### **3.5 构造函数与类中的 `this`**\\r\\n\\r\\n- **定义**：在构造函数或类中，`this` 指向新创建的实例。\\r\\n- **示例**：\\r\\n\\r\\n  ```javascript\\r\\n  function Person(name) {\\r\\n      this.name = name;\\r\\n  }\\r\\n\\r\\n  const alice = new Person(\\\"Alice\\\");\\r\\n  console.log(alice.name); // 输出：Alice\\r\\n\\r\\n  class MyClass {\\r\\n      constructor(name) {\\r\\n          this.name = name;\\r\\n      }\\r\\n  }\\r\\n\\r\\n  const instance = new MyClass(\\\"Bob\\\");\\r\\n  console.log(instance.name); // 输出：Bob\\r\\n  ```\\r\\n\\r\\n#### **总结**\\r\\n\\r\\n| 调用方式           | `this` 指向                     |\\r\\n|--------------------|---------------------------------|\\r\\n| 默认绑定           | 全局对象（非严格模式）或 `undefined`（严格模式） |\\r\\n| 隐式绑定           | 调用该方法的对象               |\\r\\n| 显式绑定           | 通过 `call`、`apply` 或 `bind` 指定的对象 |\\r\\n| 箭头函数           | 继承自外层作用域的 `this`       |\\r\\n| 构造函数/类        | 新创建的实例                   |\\r\\n\\r\\n---\";"],"names":[],"sourceRoot":""}