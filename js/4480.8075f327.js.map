{"version":3,"file":"js/4480.8075f327.js","mappings":"oHAAA,wkJ","sources":["webpack://myblog/./src/assets/md/java/content/040-2网络编程.md"],"sourcesContent":["export default \"## **2.网络编程**\\r\\n\\r\\n网络编程是指通过计算机网络实现不同设备之间的通信。Java 提供了丰富的网络编程 API，主要包括 TCP/IP 和 UDP 协议的支持。\\r\\n\\r\\n---\\r\\n\\r\\n### **2.1 TCP/IP 协议与 UDP 协议**\\r\\n\\r\\n- **TCP/IP**\\r\\n  - 面向连接的协议，提供可靠的、有序的数据传输。\\r\\n  - 常用于需要高可靠性的场景，如文件传输、电子邮件等。\\r\\n  - 基于三次握手建立连接。\\r\\n\\r\\n- **UDP**\\r\\n  - 面向无连接的协议，不保证数据包的可靠性，但效率更高。\\r\\n  - 常用于实时性要求较高的场景，如视频会议、在线游戏等。\\r\\n\\r\\n---\\r\\n\\r\\n### **2.2 Socket 编程**\\r\\n\\r\\nSocket 是网络通信的基础，Java 提供了 `java.net.Socket` 和 `java.net.ServerSocket` 类分别用于客户端和服务器端的通信。\\r\\n\\r\\n#### **服务器端实现**\\r\\n\\r\\n```java\\r\\nimport java.io.*;\\r\\nimport java.net.*;\\r\\n\\r\\npublic class Server {\\r\\n    public static void main(String[] args) throws IOException {\\r\\n        ServerSocket serverSocket = new ServerSocket(8080);\\r\\n        System.out.println(\\\"Server is listening on port 8080...\\\");\\r\\n\\r\\n        while (true) {\\r\\n            Socket clientSocket = serverSocket.accept(); // 接受客户端连接\\r\\n            System.out.println(\\\"Client connected: \\\" + clientSocket.getInetAddress());\\r\\n\\r\\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\\r\\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\\r\\n\\r\\n            String inputLine;\\r\\n            while ((inputLine = in.readLine()) != null) {\\r\\n                System.out.println(\\\"Received: \\\" + inputLine);\\r\\n                out.println(\\\"Echo: \\\" + inputLine); // 返回响应\\r\\n            }\\r\\n\\r\\n            clientSocket.close();\\r\\n        }\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n#### **客户端实现**\\r\\n\\r\\n```java\\r\\nimport java.io.*;\\r\\nimport java.net.*;\\r\\n\\r\\npublic class Client {\\r\\n    public static void main(String[] args) throws IOException {\\r\\n        Socket socket = new Socket(\\\"localhost\\\", 8080);\\r\\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\\r\\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\\r\\n\\r\\n        BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in));\\r\\n        String userInput;\\r\\n\\r\\n        while ((userInput = stdIn.readLine()) != null) {\\r\\n            out.println(userInput); // 发送数据到服务器\\r\\n            System.out.println(\\\"Server response: \\\" + in.readLine()); // 接收服务器响应\\r\\n        }\\r\\n\\r\\n        socket.close();\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n### **2.3 NIO 在网络编程中的应用**\\r\\n\\r\\nNIO（New I/O）是 Java 提供的一种高效 I/O 模型，基于缓冲区和通道，可以实现非阻塞式网络通信。\\r\\n\\r\\n#### **NIO 示例：非阻塞服务器**\\r\\n\\r\\n```java\\r\\nimport java.io.IOException;\\r\\nimport java.net.InetSocketAddress;\\r\\nimport java.nio.ByteBuffer;\\r\\nimport java.nio.channels.SelectionKey;\\r\\nimport java.nio.channels.Selector;\\r\\nimport java.nio.channels.ServerSocketChannel;\\r\\nimport java.nio.channels.SocketChannel;\\r\\nimport java.util.Iterator;\\r\\n\\r\\npublic class NIOServer {\\r\\n    public static void main(String[] args) throws IOException {\\r\\n        Selector selector = Selector.open();\\r\\n        ServerSocketChannel serverSocket = ServerSocketChannel.open();\\r\\n        serverSocket.bind(new InetSocketAddress(8080));\\r\\n        serverSocket.configureBlocking(false);\\r\\n        serverSocket.register(selector, SelectionKey.OP_ACCEPT);\\r\\n\\r\\n        ByteBuffer buffer = ByteBuffer.allocate(256);\\r\\n\\r\\n        while (true) {\\r\\n            selector.select();\\r\\n            Iterator<SelectionKey> keys = selector.selectedKeys().iterator();\\r\\n\\r\\n            while (keys.hasNext()) {\\r\\n                SelectionKey key = keys.next();\\r\\n                keys.remove();\\r\\n\\r\\n                if (key.isAcceptable()) {\\r\\n                    ServerSocketChannel server = (ServerSocketChannel) key.channel();\\r\\n                    SocketChannel client = server.accept();\\r\\n                    client.configureBlocking(false);\\r\\n                    client.register(selector, SelectionKey.OP_READ);\\r\\n                    System.out.println(\\\"Client connected: \\\" + client.getRemoteAddress());\\r\\n                } else if (key.isReadable()) {\\r\\n                    SocketChannel client = (SocketChannel) key.channel();\\r\\n                    buffer.clear();\\r\\n                    int read = client.read(buffer);\\r\\n                    if (read == -1) {\\r\\n                        client.close();\\r\\n                    } else {\\r\\n                        buffer.flip();\\r\\n                        byte[] data = new byte[buffer.remaining()];\\r\\n                        buffer.get(data);\\r\\n                        System.out.println(\\\"Received: \\\" + new String(data));\\r\\n                        client.write(ByteBuffer.wrap((\\\"Echo: \\\" + new String(data)).getBytes()));\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n---\";"],"names":[],"sourceRoot":""}