"use strict";(self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[]).push([[3534],{3534:function(r,n,e){e.r(n),n["default"]='## **5. 二分搜索**\r\n\r\n### **二分查找**\r\n\r\n#### **有序数组(元素唯一)**：\r\n\r\n```python\r\ndef binary_search(arr, target):\r\n\r\n    left, right = 0, len(arr) - 1\r\n    while left <= right:\r\n        mid = (left + right) // 2\r\n        if arr[mid] == target:\r\n            return mid\r\n        elif arr[mid] < target:\r\n            left = mid + 1\r\n        else:\r\n            right = mid - 1\r\n    return -1\r\n```\r\n\r\n#### **有序数组(元素重复)**：\r\n\r\n```python\r\ndef binary_search_left(arr, target):\r\n    left, right = 0, len(arr) - 1\r\n    result=-1\r\n    while left <= right:\r\n        mid = (left + right) // 2\r\n        if arr[mid] == target:\r\n            result=mid\r\n            right = mid - 1\r\n        elif arr[mid] < target:\r\n            left = mid + 1\r\n        else:\r\n            right = mid - 1\r\n    return result\r\n\r\n```\r\n\r\n#### **旋转数组**\r\n\r\n```python\r\ndef search_in_rotated_sorted_array(nums, target):\r\n    left, right = 0, len(nums) - 1\r\n    \r\n    while left <= right:\r\n        mid = (left + right) // 2\r\n        \r\n        if nums[mid] == target:\r\n            return mid\r\n        \r\n        # 左侧子数组有序\r\n        if nums[left] <= nums[mid]:\r\n            if nums[left] <= target < nums[mid]:\r\n                right = mid - 1\r\n            else:\r\n                left = mid + 1\r\n        # 右侧子数组有序\r\n        else:\r\n            if nums[mid] < target <= nums[right]:\r\n                left = mid + 1\r\n            else:\r\n                right = mid - 1\r\n                \r\n    return -1  # 未找到目标值\r\n```\r\n### **二分除法**\r\n\r\n> **问题描述**:\r\n给定两个整数 dividend 和 divisor，计算它们的商（结果为整数），并满足以下要求：\r\n\r\n1. 不使用乘法 $*$、除法 $/$ 和取模 $\\%$ 运算符。\r\n2. 结果需要向零取整（即截断小数部分）\r\n\r\n```python\r\ndef divide(dividend, divisor):\r\n    # 处理特殊情况：溢出\r\n    if divisor==0:\r\n       raise ZeroDivisionError("division by zero")\r\n    # 确定结果的符号\r\n    negative = (dividend < 0) ^ (divisor < 0)\r\n    dividend, divisor = abs(dividend), abs(divisor)\r\n\r\n    quotient = 0\r\n    while dividend >= divisor:\r\n        # 快速找到当前最大的倍数\r\n        temp_divisor, multiple = divisor, 1\r\n        while dividend >= (temp_divisor << 1):  # 左移一位相当于乘以 2\r\n            temp_divisor <<= 1\r\n            multiple <<= 1\r\n\r\n        # 减去当前的最大倍数，并累加结果\r\n        dividend -= temp_divisor\r\n        quotient += multiple\r\n\r\n    # 调整符号\r\n    return -quotient if negative else quotient\r\n\r\n```\r\n\r\n### **快速幂**\r\n\r\n```python\r\ndef fast_power(base, exponent):\r\n    result = 1\r\n    while exponent > 0:\r\n        if exponent % 2 == 1:  # 检查指数是否为奇数\r\n            result *= base\r\n        base *= base  # 底数自乘\r\n        exponent //= 2  # 指数右移一位（整除2）\r\n    return result\r\n```'}}]);
//# sourceMappingURL=3534.2c8ad1ee.js.map