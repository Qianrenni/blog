{"version":3,"file":"js/7473.db1282e3.js","mappings":"mHAAA,g7I","sources":["webpack://myblog/./src/assets/md/c-plus/content/022-类模板.md"],"sourcesContent":["export default \"## **类模板**\\r\\n\\r\\n类模板是 C++ 中实现泛型编程的另一种重要工具。与函数模板类似，类模板允许我们定义可以处理多种数据类型的通用类。通过类模板，我们可以创建适用于不同数据类型的容器、算法和其他复杂结构。\\r\\n\\r\\n以下是关于类模板的详细讲解，包括**定义与实例化**、**特化与偏特化**等内容。\\r\\n\\r\\n---\\r\\n\\r\\n### **1. 模板类的定义与实例化**\\r\\n\\r\\n#### **1.1 类模板的定义**\\r\\n\\r\\n类模板通过 `template` 关键字定义，其语法类似于函数模板。类模板允许我们定义一个通用类，其中的成员变量和成员函数可以使用模板参数作为类型。\\r\\n\\r\\n**语法**：\\r\\n\\r\\n```cpp\\r\\ntemplate <typename T>\\r\\nclass 类名 {\\r\\nprivate:\\r\\n    // 私有成员变量\\r\\npublic:\\r\\n    // 构造函数、析构函数、成员函数等\\r\\n};\\r\\n```\\r\\n\\r\\n- **模板参数**：`typename T` 或 `class T` 声明模板参数。\\r\\n- **成员变量和函数**：可以使用模板参数作为类型。\\r\\n\\r\\n**示例**：\\r\\n以下是一个简单的类模板，用于表示一个动态数组：\\r\\n\\r\\n```cpp\\r\\n#include <iostream>\\r\\nusing namespace std;\\r\\n\\r\\n// 定义类模板\\r\\ntemplate <typename T>\\r\\nclass DynamicArray {\\r\\nprivate:\\r\\n    T* data;       // 动态分配的数组\\r\\n    int size;      // 数组大小\\r\\n\\r\\npublic:\\r\\n    // 构造函数\\r\\n    DynamicArray(int s) : size(s) {\\r\\n        data = new T[size];\\r\\n    }\\r\\n\\r\\n    // 析构函数\\r\\n    ~DynamicArray() {\\r\\n        delete[] data;\\r\\n    }\\r\\n\\r\\n    // 设置元素值\\r\\n    void setElement(int index, const T& value) {\\r\\n        if (index >= 0 && index < size) {\\r\\n            data[index] = value;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // 获取元素值\\r\\n    T getElement(int index) const {\\r\\n        if (index >= 0 && index < size) {\\r\\n            return data[index];\\r\\n        }\\r\\n        return T(); // 返回默认值\\r\\n    }\\r\\n};\\r\\n\\r\\nint main() {\\r\\n    DynamicArray<int> intArray(5); // 创建一个存储整数的动态数组\\r\\n    intArray.setElement(0, 10);\\r\\n    cout << \\\"Element at index 0: \\\" << intArray.getElement(0) << endl;\\r\\n\\r\\n    DynamicArray<double> doubleArray(3); // 创建一个存储浮点数的动态数组\\r\\n    doubleArray.setElement(1, 3.14);\\r\\n    cout << \\\"Element at index 1: \\\" << doubleArray.getElement(1) << endl;\\r\\n}\\r\\n```\\r\\n\\r\\n#### **1.2 模板类的实例化**\\r\\n\\r\\n类模板的实例化与函数模板类似，分为显式实例化和隐式实例化。\\r\\n\\r\\n- **显式实例化**：\\r\\n  我们可以手动指定模板参数类型，例如：\\r\\n\\r\\n  ```cpp\\r\\n  DynamicArray<int> intArray(5); // 显式指定模板参数为 int\\r\\n  ```\\r\\n\\r\\n- **隐式实例化**：\\r\\n  编译器会根据传递的实际参数类型推导模板参数。例如：\\r\\n\\r\\n  ```cpp\\r\\n  DynamicArray array(5); // 编译器推导出 T 为 int（C++17 起支持自动类型推导）\\r\\n  ```\\r\\n\\r\\n---\\r\\n\\r\\n### **2. 模板类的特化与偏特化**\\r\\n\\r\\n尽管类模板非常灵活，但在某些情况下，我们需要为特定类型提供特殊的实现。这时可以使用**模板特化**或**偏特化**。\\r\\n\\r\\n#### **2.1 模板特化**\\r\\n\\r\\n模板特化是指为某个特定类型提供专门的实现。当模板参数匹配特定类型时，编译器会选择特化的版本。\\r\\n\\r\\n**语法**：\\r\\n\\r\\n```cpp\\r\\ntemplate <>\\r\\nclass 类名<特定类型> {\\r\\n    // 特化实现\\r\\n};\\r\\n```\\r\\n\\r\\n**示例**：\\r\\n以下是对 `DynamicArray` 类模板的特化实现，用于处理字符数组：\\r\\n\\r\\n```cpp\\r\\ntemplate <>\\r\\nclass DynamicArray<char> {\\r\\nprivate:\\r\\n    char* data;\\r\\n    int size;\\r\\n\\r\\npublic:\\r\\n    DynamicArray(int s) : size(s) {\\r\\n        data = new char[size];\\r\\n    }\\r\\n\\r\\n    ~DynamicArray() {\\r\\n        delete[] data;\\r\\n    }\\r\\n\\r\\n    void setElement(int index, char value) {\\r\\n        if (index >= 0 && index < size) {\\r\\n            data[index] = value;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    char getElement(int index) const {\\r\\n        if (index >= 0 && index < size) {\\r\\n            return data[index];\\r\\n        }\\r\\n        return '\\\\0'; // 返回空字符\\r\\n    }\\r\\n\\r\\n    void printAll() const {\\r\\n        for (int i = 0; i < size; ++i) {\\r\\n            cout << data[i] << \\\" \\\";\\r\\n        }\\r\\n        cout << endl;\\r\\n    }\\r\\n};\\r\\n\\r\\nint main() {\\r\\n    DynamicArray<char> charArray(3); // 使用特化版本\\r\\n    charArray.setElement(0, 'A');\\r\\n    charArray.setElement(1, 'B');\\r\\n    charArray.printAll(); // 输出：A B \\\\0\\r\\n}\\r\\n```\\r\\n\\r\\n#### **2.2 偏特化**\\r\\n\\r\\n偏特化是指为部分模板参数提供专门的实现。它允许我们针对某些模板参数的子集进行特化。\\r\\n\\r\\n**语法**：\\r\\n\\r\\n```cpp\\r\\ntemplate <typename T1, typename T2>\\r\\nclass 类名<T1, 特定类型> {\\r\\n    // 偏特化实现\\r\\n};\\r\\n```\\r\\n\\r\\n**示例**：\\r\\n以下是一个偏特化的例子，假设我们有一个模板类 `Pair`，并为其第二个参数为 `int` 的情况提供特化：\\r\\n\\r\\n```cpp\\r\\n#include <iostream>\\r\\nusing namespace std;\\r\\n\\r\\n// 通用模板类\\r\\ntemplate <typename T1, typename T2>\\r\\nclass Pair {\\r\\npublic:\\r\\n    T1 first;\\r\\n    T2 second;\\r\\n\\r\\n    Pair(T1 f, T2 s) : first(f), second(s) {}\\r\\n\\r\\n    void print() const {\\r\\n        cout << \\\"Generic Pair: \\\" << first << \\\", \\\" << second << endl;\\r\\n    }\\r\\n};\\r\\n\\r\\n// 偏特化：第二个参数为 int\\r\\ntemplate <typename T1>\\r\\nclass Pair<T1, int> {\\r\\npublic:\\r\\n    T1 first;\\r\\n    int second;\\r\\n\\r\\n    Pair(T1 f, int s) : first(f), second(s) {}\\r\\n\\r\\n    void print() const {\\r\\n        cout << \\\"Specialized Pair: \\\" << first << \\\", \\\" << second << endl;\\r\\n    }\\r\\n};\\r\\n\\r\\nint main() {\\r\\n    Pair<double, double> p1(3.14, 2.71);\\r\\n    p1.print(); // 输出：Generic Pair: 3.14, 2.71\\r\\n\\r\\n    Pair<string, int> p2(\\\"Hello\\\", 42);\\r\\n    p2.print(); // 输出：Specialized Pair: Hello, 42\\r\\n}\\r\\n```\\r\\n\\r\\n---\";"],"names":[],"sourceRoot":""}