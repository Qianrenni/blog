{"version":3,"file":"js/3534.422435f9.js","mappings":"mHAAA,ytK","sources":["webpack://myblog/./src/assets/md/algorithm/content/013-5 二分搜索.md"],"sourcesContent":["export default \"## **5. 二分搜索**\\r\\n\\r\\n### **二分查找**\\r\\n\\r\\n#### **有序数组(元素唯一)**\\r\\n\\r\\n```python\\r\\ndef binary_search(arr, target):\\r\\n\\r\\n    left, right = 0, len(arr) - 1\\r\\n    while left <= right:\\r\\n        mid = (left + right) // 2\\r\\n        if arr[mid] == target:\\r\\n            return mid\\r\\n        elif arr[mid] < target:\\r\\n            left = mid + 1\\r\\n        else:\\r\\n            right = mid - 1\\r\\n    return -1\\r\\n```\\r\\n\\r\\n#### **有序数组(元素重复)**\\r\\n\\r\\n```python\\r\\ndef binary_search_left(arr, target):\\r\\n    left, right = 0, len(arr) - 1\\r\\n    result=-1\\r\\n    while left <= right:\\r\\n        mid = (left + right) // 2\\r\\n        if arr[mid] == target:\\r\\n            result=mid\\r\\n            right = mid - 1\\r\\n        elif arr[mid] < target:\\r\\n            left = mid + 1\\r\\n        else:\\r\\n            right = mid - 1\\r\\n    return result\\r\\n\\r\\n```\\r\\n\\r\\n#### **寻找两个有序数组的中间值**\\r\\n\\r\\n```python\\r\\nclass Solution:\\r\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\r\\n        if len(nums1)>len(nums2):\\r\\n            return self.findMedianSortedArrays(nums2,nums1)\\r\\n        m,n=len(nums1),len(nums2)\\r\\n        left,right=0,m\\r\\n        INF=float('inf')\\r\\n        left_max,right_min=-INF,INF\\r\\n        while left<=right:\\r\\n            i=(left+right)//2\\r\\n            j=(m+n+1)//2-i\\r\\n            num_i= INF  if i==m else nums1[i]\\r\\n            num_i_1=-INF if i==0 else nums1[i-1]\\r\\n            num_j=INF if j==n else nums2[j]\\r\\n            num_j_1=-INF if j==0 else nums2[j-1]\\r\\n            if num_i_1<=num_j:\\r\\n                left_max=max(num_i_1,num_j_1)\\r\\n                right_min=min(num_j,num_i)\\r\\n                left+=1\\r\\n            else:\\r\\n                right-=1\\r\\n        return (left_max+right_min)/2 if (m+n)%2==0 else left_max\\r\\n```\\r\\n\\r\\n#### **N个有序数组查找第k小数**\\r\\n\\r\\n```python\\r\\ndef count_less_equal(arrays, mid):\\r\\n    # 统计总共不超过 mid 的元素个数\\r\\n    total = 0\\r\\n    for arr in arrays:\\r\\n        # 使用 bisect_right 找出 <= mid 的元素个数\\r\\n        import bisect\\r\\n        total += bisect.bisect_right(arr, mid)\\r\\n    return total\\r\\n\\r\\ndef kth_smallest_n_arrays_binary(arrays, k):\\r\\n    # 初始左右边界\\r\\n    left = min(arr[0] for arr in arrays if arr)\\r\\n    right = max(arr[-1] for arr in arrays if arr)\\r\\n\\r\\n    while left < right:\\r\\n        mid = (left + right) // 2\\r\\n        cnt = count_less_equal(arrays, mid)\\r\\n        if cnt < k:\\r\\n            left = mid + 1\\r\\n        else:\\r\\n            right = mid\\r\\n    return left\\r\\n\\r\\nif __name__=='__main__':\\r\\n    arrays = [\\r\\n        [1, 4, 7],\\r\\n        [2, 5, 8],\\r\\n        [3, 6, 9]\\r\\n    ]\\r\\n    k = 5\\r\\n    print(kth_smallest_n_arrays_binary(arrays, k))  # 输出: 5\\r\\n\\r\\n```\\r\\n\\r\\n#### **旋转数组**\\r\\n\\r\\n```python\\r\\ndef search_in_rotated_sorted_array(nums, target):\\r\\n    left, right = 0, len(nums) - 1\\r\\n    \\r\\n    while left <= right:\\r\\n        mid = (left + right) // 2\\r\\n        \\r\\n        if nums[mid] == target:\\r\\n            return mid\\r\\n        \\r\\n        # 左侧子数组有序\\r\\n        if nums[left] <= nums[mid]:\\r\\n            if nums[left] <= target < nums[mid]:\\r\\n                right = mid - 1\\r\\n            else:\\r\\n                left = mid + 1\\r\\n        # 右侧子数组有序\\r\\n        else:\\r\\n            if nums[mid] < target <= nums[right]:\\r\\n                left = mid + 1\\r\\n            else:\\r\\n                right = mid - 1\\r\\n                \\r\\n    return -1  # 未找到目标值\\r\\n```\\r\\n\\r\\n#### **旋转数组找最小值**\\r\\n\\r\\n```python\\r\\nfrom typing import List\\r\\nclass Solution:\\r\\n    def minInRotateArray(self, rotateArray: List[int]) -> int:\\r\\n        left, right = 0, len(rotateArray) - 1\\r\\n        \\r\\n        while left < right:\\r\\n            mid = (left + right) // 2\\r\\n            \\r\\n            if rotateArray[mid] > rotateArray[right]:\\r\\n                # 最小值在右边\\r\\n                left = mid + 1\\r\\n            elif rotateArray[mid] < rotateArray[right]:\\r\\n                # 最小值在左边\\r\\n                right = mid\\r\\n            else:\\r\\n                # 相等时，缩小右边界（不能确定在哪边）\\r\\n                right -= 1\\r\\n        \\r\\n        # 最终 left == right，指向最小值\\r\\n        return rotateArray[left]\\r\\n```\\r\\n\\r\\n### **二分除法**\\r\\n\\r\\n> **问题描述**:\\r\\n给定两个整数 dividend 和 divisor，计算它们的商（结果为整数），并满足以下要求：\\r\\n\\r\\n1. 不使用乘法 $*$、除法 $/$ 和取模 $\\\\%$ 运算符。\\r\\n2. 结果需要向零取整（即截断小数部分）\\r\\n\\r\\n```python\\r\\ndef divide(dividend, divisor):\\r\\n    # 处理特殊情况：溢出\\r\\n    if divisor==0:\\r\\n       raise ZeroDivisionError(\\\"division by zero\\\")\\r\\n    # 确定结果的符号\\r\\n    negative = (dividend < 0) ^ (divisor < 0)\\r\\n    dividend, divisor = abs(dividend), abs(divisor)\\r\\n\\r\\n    quotient = 0\\r\\n    while dividend >= divisor:\\r\\n        # 快速找到当前最大的倍数\\r\\n        temp_divisor, multiple = divisor, 1\\r\\n        while dividend >= (temp_divisor << 1):  # 左移一位相当于乘以 2\\r\\n            temp_divisor <<= 1\\r\\n            multiple <<= 1\\r\\n\\r\\n        # 减去当前的最大倍数，并累加结果\\r\\n        dividend -= temp_divisor\\r\\n        quotient += multiple\\r\\n\\r\\n    # 调整符号\\r\\n    return -quotient if negative else quotient\\r\\n\\r\\n```\\r\\n\\r\\n### **快速幂**\\r\\n\\r\\n```python\\r\\ndef fast_power(base, exponent):\\r\\n    result = 1\\r\\n    while exponent > 0:\\r\\n        if exponent % 2 == 1:  # 检查指数是否为奇数\\r\\n            result *= base\\r\\n        base *= base  # 底数自乘\\r\\n        exponent //= 2  # 指数右移一位（整除2）\\r\\n    return result\\r\\n```\";"],"names":[],"sourceRoot":""}